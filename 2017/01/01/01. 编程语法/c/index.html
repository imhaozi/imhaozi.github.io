
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 8.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>C语言 - Blog</title>

  
    <meta name="description" content="C语言学习笔记，刚学的时候写的，虽然后面也不会看，但是学的时候写过一遍就认为是学会了。">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言">
<meta property="og:url" content="http://example.com/2017/01/01/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/c/">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="C语言学习笔记，刚学的时候写的，虽然后面也不会看，但是学的时候写过一遍就认为是学会了。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2017/01/01/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/c/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98.jpg">
<meta property="og:image" content="http://example.com/2017/01/01/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/c/%E5%85%B1%E7%94%A8%E4%BD%93%E5%86%85%E5%AD%98.jpg">
<meta property="og:image" content="http://example.com/2017/01/01/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/c/%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6.jpg">
<meta property="article:published_time" content="2017-01-01T03:11:11.000Z">
<meta property="article:modified_time" content="2025-11-13T02:00:38.522Z">
<meta property="article:author" content="imhaozi">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2017/01/01/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/c/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98.jpg">
  
  
  
  <meta name="keywords" content="C语言">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  
    <link rel="shortcut icon" href="/images/avatar.jpg">
  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"imhaozi","sameAs":[]},"dateCreated":"2017-01-01T11:11:11+08:00","dateModified":"2025-11-13T10:00:38+08:00","datePublished":"2017-01-01T11:11:11+08:00","description":"","headline":"C语言","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2017/01/01/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/c/"},"publisher":{"@type":"Organization","name":"imhaozi","sameAs":[]},"url":"http://example.com/2017/01/01/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/c/","keywords":"C语言","image":[]}</script>
  
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">Blog</div><div class="sub normal cap">装备锻造中</div><div class="sub hover cap" style="opacity:0"> Write By imhaozi</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="文档" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="关于" href="/about/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>



<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2024/10/08/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/lvgl%E7%A7%BB%E6%A4%8D/"><span class="title">lvgl移植</span></a><a class="item title" href="/2025/11/15/04.%20Linux%E5%BA%94%E7%94%A8/TspRosCar/"><span class="title">ros1小车diy记录</span></a><a class="item title" href="/2020/10/01/03.%20RTOS/rtthread_nano/"><span class="title">rtthread_nano移植</span></a><a class="item title" href="/2025/06/01/04.%20Linux%E5%BA%94%E7%94%A8/v3s%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%B6%E4%BD%9C/"><span class="title">v3s开发板制作</span></a><a class="item title" href="/2025/08/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"><span class="title">博客搭建指南</span></a><a class="item title" href="/2025/06/01/10.%20%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86/%E5%85%85%E7%94%B5%E6%A1%A9%E5%9B%BD%E6%A0%87/"><span class="title">充电桩国标协议解析</span></a><a class="item title" href="/2025/11/05/08.%20%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/candbc/"><span class="title">CanDBC文件制作</span></a><a class="item title" href="/2023/01/01/07.%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/ymodem/"><span class="title">Ymodem</span></a><a class="item title" href="/2023/01/01/07.%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/modbus/"><span class="title">Modbus</span></a><a class="item title" href="/2023/07/01/07.%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/canopen/"><span class="title">CanOpen</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/imhaozi" target="_blank" rel="external nofollow noopener noreferrer"><img no-lazy src="/images/github.svg" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="social" href="https://space.bilibili.com/330622220" target="_blank" rel="external nofollow noopener noreferrer"><img no-lazy src="/images/bilibili.svg" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder/social/942ebbf1a4b91.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/">编程语法</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2017-01-01T03:11:11.000Z">2017-01-01</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-11-13T02:00:38.522Z">2025-11-13</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>C语言</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="1-C语言概述"><a href="#1-C语言概述" class="headerlink" title="1. C语言概述"></a>1. C语言概述</h1><h2 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h2><ol>
<li><strong>代码级别的跨平台</strong>：由于标准的存在，使得几乎同样的C代码可用于多种操作系统。</li>
<li><strong>允许直接访问物理地址</strong>，对硬件进行操作。</li>
<li>C语言是一个有结构化程序设计、具有变量作用域（variable scope）以及递归功能的过程式语言。</li>
<li>C语言传递参数可以是值传递（pass by value，值），也可以传递指针（apointer passed by value，地址）。</li>
<li>C语言中，<strong>没有对象</strong>，不同的变量类型可以用结构体（struct）组合在一起。</li>
<li><strong>预编译处理（preprocessor）,生成目标代码质量高，程序执行效率高</strong>。</li>
</ol>
<h2 id="1-2-运行机制"><a href="#1-2-运行机制" class="headerlink" title="1.2 运行机制"></a>1.2 运行机制</h2><ol>
<li>编辑：比如编写我们的 hello.c 文件，就是源代码.</li>
<li>编译：将 hello.c 程序翻译成目标文件 (hello.obj) &#x2F;&#x2F; 在计算机底层执行</li>
<li>链接：将目标文件 hello.obj + 库文件生成可执行文件(MyProject01.exe) &#x2F;&#x2F; 在计算机底层执行</li>
<li>运行：执行.exe文件，得到运行结果</li>
</ol>
<ul>
<li>编译<ol>
<li>有了C源文件，通过编译器将其编译成 obj文件(目标文件)。</li>
<li>如果程序没有错误，没有任何提示，但在Debug目录下会出现一个 Hello.obj 文件，该文件称为目标文件。</li>
</ol>
</li>
<li>链接<ol>
<li>有了目标文件(.obj文件)，通过链接程序将其和运行需要的c库文件链接成exe文件(可执行文件)。</li>
<li>如果程序没有错误，没有任何提示，但在 Debug 目录下会出现一个项目名.exe文件，该文件称为可执行文件。</li>
<li>为什么需要链接库文件呢？因为我们的C程序中会使用C程序库的内容，比如&lt;stdio.h&gt;&lt;stdlib.h&gt;中的函数 printf()、system() 等等,这些函数不是程序员自己写的，而是C程序库中提供的，因此需要链接。</li>
<li>你会发现链接后，生成的.exe文件，比obj文件大了很多.</li>
</ol>
</li>
<li>运行<ol>
<li>有了可执行的exe文件,也称为可执行程序(二进制文件)</li>
<li>在控制台下可以直接运行exe文件</li>
</ol>
</li>
</ul>
<h2 id="1-3-转义字符"><a href="#1-3-转义字符" class="headerlink" title="1.3 转义字符"></a>1.3 转义字符</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\t ：一个制表位，实现对齐的功能</span><br><span class="line">\n ：换行符</span><br><span class="line">\\ ：一个\</span><br><span class="line">\&quot; : 一个&quot;</span><br><span class="line">\&#x27; ：一个&#x27;</span><br><span class="line">\r : 一个回车printf(&quot;张无忌赵敏周\r芷若小昭&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="1-4-注释"><a href="#1-4-注释" class="headerlink" title="1.4 注释"></a>1.4 注释</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	多行注释1</span></span><br><span class="line"><span class="comment">	多行注释2</span></span><br><span class="line"><span class="comment">	注释不允许嵌套</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="1-5-标准库"><a href="#1-5-标准库" class="headerlink" title="1.5 标准库"></a>1.5 标准库</h2><p>C标准库是一组C内置函数、常量和头文件，比如&lt;stdio.h&gt;、&lt;stdlib.h&gt;、&lt;math.h&gt;，等等。</p>
<p>可以查手册来找需要使用的库和函数。</p>
<h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h1><h2 id="2-1-变量介绍"><a href="#2-1-变量介绍" class="headerlink" title="2.1 变量介绍"></a>2.1 变量介绍</h2><p>变量相当于<strong>内存中一个数据存储空间的表示</strong>，通过变量名可以访问到变量(值)。</p>
<ol>
<li>变量表示内存中的一个存储区域（不同的数据类型，占用的空间大小不一样）</li>
<li>该区域有自己的名称和类型</li>
<li>变量必须先声明，后使用</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量在同一个作用域内不能重名</li>
<li>变量三要素(变量名+值+数据类型)，这一点请大家注意。</li>
</ol>
<h2 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h2><ul>
<li>基本类型<ul>
<li>数值类型<ul>
<li>整型<ul>
<li>short短整型</li>
<li>int整形</li>
<li>long长整型</li>
</ul>
</li>
<li>浮点数<ul>
<li>float单精度</li>
<li>double双精度</li>
</ul>
</li>
</ul>
</li>
<li>char字符类型</li>
</ul>
</li>
<li>构造类型<ul>
<li>数组</li>
<li>结构体struct</li>
<li>共用体union</li>
<li>枚举类型enum</li>
</ul>
</li>
<li>指针类型</li>
<li>空类型void</li>
</ul>
<blockquote>
<p>在c中，没有字符串类型,使用字符数组表示字符串</p>
<p>在不同系统上，部分数据类型字节长度不一样，int 2 或者 4个字节</p>
</blockquote>
<h2 id="2-3-整数类型"><a href="#2-3-整数类型" class="headerlink" title="2.3 整数类型"></a>2.3 整数类型</h2><p>如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num=%d&quot;</span>, num);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小</th>
<th>值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1字节</td>
<td>-128 即 -(2^7)  到 127(2^7 -1)</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 字节</td>
<td>0 到 255 (2^8 - 1)</td>
</tr>
<tr>
<td>signed char</td>
<td>1 字节</td>
<td>-128 即-(2^7) 到 127 (2^7-1)</td>
</tr>
<tr>
<td>int signed int</td>
<td>2 或 4 字节</td>
<td>-32,768 (- 2^15 ) 到 32,767 (2^15-1) 或 -2,147,483,648 (- 2^31) 到 2,147,483,647 (2^31 -1)</td>
</tr>
<tr>
<td>unsigned int</td>
<td>2 或 4 字节</td>
<td>0 到 65,535 (2^16-1) 或 0 到 4,294,967,295 (2^32 -1)</td>
</tr>
<tr>
<td>short signed short</td>
<td>2 字节</td>
<td>-32,768 (- 2^15)到 32,767 (2^15 -1)</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2 字节</td>
<td>0 到 65,535 (2^16 - 1)</td>
</tr>
<tr>
<td>long signed long</td>
<td>4 字节</td>
<td>-2,147,483,648 (- 2^31) 到 2,147,483,647 (2^31 - 1)</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4 字节</td>
<td>0 到 4,294,967,295 (2^32 - 1)</td>
</tr>
</tbody></table>
<ul>
<li>使用细节<ol>
<li><strong>各种类型的存储大小与操作系统、系统位数和编译器有关</strong>，目前通用的以 64 位系统为主。 </li>
<li>C 语言的整型类型，分为有符号 signed 和无符号 unsigned 两种， 默认是 signed。</li>
<li>C 程序中整型常声明为 int 型，除非不足以表示大数，才使用 long long</li>
<li>bit(位): 计算机中的最小存储单位。 byte(字节):计算机中基本存储单元。</li>
</ol>
</li>
</ul>
<h2 id="2-4-浮点类型"><a href="#2-4-浮点类型" class="headerlink" title="2.4 浮点类型"></a>2.4 浮点类型</h2><p>如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> salary = <span class="number">10000.56</span>;</span><br><span class="line">    <span class="type">double</span> num1 = <span class="number">1.3</span>;</span><br><span class="line">    <span class="type">double</span> num2 = <span class="number">4.5</span>;</span><br><span class="line">    <span class="type">double</span> sum = num1 + num2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %.2f \n&quot;</span> , sum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %f&quot;</span> , sum);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="number">5.80</span> </span><br><span class="line">sum = <span class="number">5.800000</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储大小</th>
<th align="center">值范围</th>
<th align="center">精度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float 单精度</td>
<td align="center">4 字节</td>
<td align="center">1.2E-38 到 3.4E+38</td>
<td align="center">6 位小数</td>
</tr>
<tr>
<td align="center">double 双精度</td>
<td align="center">8 字节</td>
<td align="center">2.3E-308 到 1.7E+308</td>
<td align="center">15 位小数</td>
</tr>
</tbody></table>
<ul>
<li>注意<ol>
<li>关于浮点数在机器中存放形式的简单说明，浮点数 &#x3D; 符号位 + 指数位 + 尾数位，浮点数是近似值。</li>
<li>尾数部分可能丢失，造成精度损失。</li>
</ol>
</li>
<li>使用细节<ol>
<li>浮点型常量默认为 double 型，声明 float 型常量时，须后加‘f’ 或‘F’ 。</li>
<li>浮点型常量有两种表示形式<ol>
<li>十进制数形式： 如：5.12、512.0f、.512 (必须有小数点）</li>
<li>科学计数法形式：如：5.12e2、5.12E-2</li>
</ol>
</li>
<li>通常情况下，应该使用 double 型，因为它比 float 型更精确。</li>
<li>printf(“d1&#x3D;%f “, d1);  &#x2F;&#x2F; 在输出时，默认保留 小数点 6 位。</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><figcaption><span>main()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    //浮点型常量默认为 double 型 ， 声明 float 型常量时， 须后加‘f’ 或‘F’</span><br><span class="line">    float d1 = 1.18909095; //从“double” 到“float” 截断, 1.1 是 double</span><br><span class="line">    float d2 = 1.1f; // 1.1f 就是 float</span><br><span class="line">    double d3 = 1.3; // ok</span><br><span class="line">    double d4 = 5.12;</span><br><span class="line">    double d5 = .512; // 等价 0.512</span><br><span class="line">    double d6 = 5.12e2; //等价 5.12 * (10^2) = 512</span><br><span class="line">    double d7 = 5.12e-2; // 等价 5.12 * (10^-2) = 5.12 / 100 = 0.0512</span><br><span class="line">    //在输出时， 如果%f 默认保留小数点 6 位</span><br><span class="line">    printf(&quot;d1=%.15f d2=%f d3=%f d4=%f d5=%f d6=%f d7=%f&quot;, d1,d2,d3,d4,d5,d6,d7);</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d1=1.189090967178345 d2=1.100000 d3=1.300000 d4=5.120000 d5=0.512000 d6=512.000000 d7=0.051200</span><br></pre></td></tr></table></figure>

<h2 id="2-5-字符类型"><a href="#2-5-字符类型" class="headerlink" title="2.5 字符类型"></a>2.5 字符类型</h2><ul>
<li>字符类型可以表示单个字符，字符类型是 char，char 是 1 个字节(可以存字母或者数字)</li>
<li>多个字符称为字符串，在C 语言中 使用 char 数组 表示，数组不是基本数据类型，而是构造类型。</li>
</ul>
<p>如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> c2 = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> c3 = <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c1=%c c3=%c c2=%c&quot;</span>, c1, c3, c2); <span class="comment">// %c 表示以字符的形式输出</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c1=A c3=	 c2=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用细节<ol>
<li>字符常量是用单引号括起来的单个字符。 例如：char c1 &#x3D; ‘a’; char c3 &#x3D; ‘9’;  </li>
<li>C 中还允许使用转义字符‘\’ 来将其后的字符转变为特殊字符型常量。例如：char c3 &#x3D; ‘\n’ ; &#x2F;&#x2F; ‘\n’表示换行符</li>
<li>在 C 中，char 的本质是一个整数，在输出时，是 ASCII 码对应的字符。</li>
<li>可以直接给 char 赋一个整数，然后输出时，会按照对应的 ASCII 字符输出 [97]。</li>
<li>char 类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="comment">//这时当我们以 %c 输出时，就会按照 ASCII 编码表(理解 字符 &lt;==&gt; 数字 对应关系 ) 对应的 97 对应字符输出</span></span><br><span class="line">    <span class="type">char</span> c3 = <span class="number">97</span>;</span><br><span class="line">    <span class="type">int</span> num = c2 + <span class="number">10</span>; <span class="comment">// 98 + 10 = 108</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c1=%c c2=%c c3=%c \n&quot;</span>, c1, c2, c3); <span class="comment">// c3= &#x27;a&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num=%d&quot;</span>, num); <span class="comment">// 108</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c1=a c2=b c3=a </span><br><span class="line">num=<span class="number">108</span> </span><br></pre></td></tr></table></figure>

<h2 id="2-6-布尔类型"><a href="#2-6-布尔类型" class="headerlink" title="2.6 布尔类型"></a>2.6 布尔类型</h2><ul>
<li>C 语言标准(C89)没有定义布尔类型，所以 C 语言判断真假时以 0 为假，非 0 为真。</li>
<li>但这种做法不直观，所以我们可以借助 C 语言的宏定义。</li>
</ul>
<blockquote>
<p>C 语言标准(C99)提供了 _Bool 型， _Bool 仍是整数类型， 但与一般整型不同的是， _Bool 变量只能赋值为 0 或 1，非 0 的值都会被存储为 1。</p>
<p>_ C99 还提供了一个头文件 &lt;stdbool.h&gt; 定义了 bool 代表_Bool，true 代表 1，false 代表 0。只要导入 stdbool.h，就能方便的操作布尔类型了 , 比如 bool flag &#x3D; false;</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOL int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TURE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> isPass = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//定义一个布尔变量</span></span><br><span class="line">    BOOL isOk = TURE; <span class="comment">// 等价 int isOK = 0</span></span><br><span class="line">    <span class="keyword">if</span>(isPass) &#123; <span class="comment">// 0 表示假， 非 0 表示真</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;通过考试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isOk) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-基本类型转换"><a href="#2-7-基本类型转换" class="headerlink" title="2.7 基本类型转换"></a>2.7 基本类型转换</h2><p>当 C 程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转<br>换。  </p>
<p><strong>数据类型按精度(容量)大小排序（从低到高）：</strong></p>
<ol>
<li>short</li>
<li>int</li>
<li>unsigned int</li>
<li>long</li>
<li>unsigned long</li>
<li>float</li>
<li>double</li>
<li>long double</li>
</ol>
<p><strong>自动转换表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line"></span><br><span class="line">A[Char, short] --&gt; B(int)</span><br><span class="line">B --&gt; C[unsigned]</span><br><span class="line">C --&gt; D[long]</span><br><span class="line">D --&gt; E[double]</span><br><span class="line">F[float] --&gt; E[double]</span><br></pre></td></tr></table></figure>

<ul>
<li>细节说明<ol>
<li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度最大的那种数据类型，然后再进行计算（如int 型 和 short 型 运算时，先把 short 转成 int 型后再进行运算）。</li>
<li>若两种类型的字节数不同，转换成字节数大的类型，若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型。</li>
<li>在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边的类型将转换为左边的类型， 如果右边变量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按四舍五入向前舍入。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//举例 1</span></span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> num1 = c1; <span class="comment">// ok</span></span><br><span class="line">    <span class="type">double</span> d1 = num1; <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d1=%f \n&quot;</span>, d1);</span><br><span class="line">    <span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//举例 2</span></span><br><span class="line">    <span class="type">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> num3 = s1 + num2; <span class="comment">//ok</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num3=%d \n&quot;</span>, num3);</span><br><span class="line">    <span class="comment">//举例 3</span></span><br><span class="line">    <span class="type">float</span> f1 = <span class="number">1.1f</span>; <span class="comment">//ok</span></span><br><span class="line">    <span class="type">double</span> d2 = <span class="number">4.58667435</span>;</span><br><span class="line">    f1 = d2; <span class="comment">// 出现精度损失 (double -&gt; float )</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f1=%.8f&quot;</span>, f1); <span class="comment">// 期望： 4.58667435</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d1=<span class="number">97.000000</span> </span><br><span class="line">num3=<span class="number">30</span> </span><br><span class="line">f1=<span class="number">4.58667421</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-强制类型转换"><a href="#2-8-强制类型转换" class="headerlink" title="2.8 强制类型转换"></a>2.8 强制类型转换</h2><p>将<strong>精度高</strong>的数据类型转换为<strong>精度小</strong>的数据类型。 使用时要加上<strong>强制转换符 ( )</strong>，但可能造成精度降低或溢出，格外要注意。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="number">1.934</span>;</span><br><span class="line">    <span class="type">int</span> num = (<span class="type">int</span>) d1; <span class="comment">//这里注意， 不是进行四舍五入， 而是直接截断小数后的部分</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n num=%d d1=%f&quot;</span> , num, d1); <span class="comment">// d1 仍然是 double</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 强制转换只对最近的数有效, 如果希望针对更多的表达式转换， 使用（）</span></span><br><span class="line">    <span class="comment">// int num2 = (int) 3.5 * 10 + 6 * 1.5; // 3 * 10 + 6 * 1.5 = 30 + 9.0 = 39.0</span></span><br><span class="line">    <span class="type">int</span> num3 = (<span class="type">int</span>) (<span class="number">3.5</span> * <span class="number">10</span> + <span class="number">6</span> * <span class="number">1.5</span>); <span class="comment">// 35.0 + 9.0 = 44.0 -&gt; int = 44</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n num3=%d&quot;</span>, num3); <span class="comment">// num3 = 44</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num=<span class="number">1</span> d1=<span class="number">1.934000</span></span><br><span class="line">num3=<span class="number">44</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意<ol>
<li>当进行数据的从 精度高 ——&gt; 精度低，就需要使用到强制转换。</li>
<li>强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="type">float</span> d = .<span class="number">314F</span>;</span><br><span class="line"><span class="type">double</span> d2 = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">double</span> result = c+i+d; <span class="comment">// c+i+d 类型是 float -&gt; double ok</span></span><br><span class="line"><span class="type">char</span> result = c+i+d+d2; <span class="comment">// 提示? // 警告 double -&gt; char</span></span><br></pre></td></tr></table></figure>

<h2 id="2-9-指针入门"><a href="#2-9-指针入门" class="headerlink" title="2.9 指针入门"></a>2.9 指针入门</h2><p>指针表示一个地址（存放的是地址）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//定义一个指针变量， 指针</span></span><br><span class="line">    <span class="comment">// 1. int * 表示类型为 指针类型</span></span><br><span class="line">    <span class="comment">// 2. 名称 ptr , ptr 就是一个 int * 类型</span></span><br><span class="line">    <span class="comment">// 3. ptr 指向了一个 int 类型的变量的地址</span></span><br><span class="line">    <span class="type">int</span> *ptr = &amp;num;</span><br><span class="line">    <span class="comment">// num 的地址是多少</span></span><br><span class="line">    <span class="comment">// 说明 1：如果要输出一个变量的地址， 使用格式是 %p</span></span><br><span class="line">    <span class="comment">// 说明 2: &amp;num 表示取出 num 这个变量对应地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n num的值=%d num的地址=%p&quot;</span>, num, &amp;num);</span><br><span class="line">    <span class="comment">// 1.指针变量，本身也有地址 &amp;ptr</span></span><br><span class="line">    <span class="comment">// 2.指针变量, 存放的地址 ptr</span></span><br><span class="line">    <span class="comment">// 3.获取指针指向的值 *ptr</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n ptr的地址是 %p ptr存放的值是一个地址为 %p ptr 指向的值=%d&quot;</span>, &amp;ptr, ptr, *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;  // 定义了一个值</span><br><span class="line">int <span class="emphasis">*ptr = &amp;num;  // 定义了一个指针，指针存放的是 num的地址</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&amp;ptr 表示 ptr这个指针本身的地址</span></span><br><span class="line"><span class="emphasis">ptr  表示 ptr这个变量存放的那个地址值，也就是num的地址</span></span><br><span class="line"><span class="emphasis">*</span>ptr 表示 ptr存放的地址值上，对应的值，也就是num的值</span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line">像输出地址，格式为 %p</span><br><span class="line">像输出数值，格式和数值格式一样，%d等。</span><br></pre></td></tr></table></figure>

<ul>
<li>细节说明<ol>
<li>基本类型，都有对应的指针类型，形式为 数据类型 *，比如 int 的对应的指针就是 int *, float 对应的指针类型就是 float * ，依次类推。</li>
<li>此外还有<strong>指向数组的指针</strong>、<strong>指向结构体的指针</strong>，<strong>指向共用体的指针</strong>， (二级指针， 多级指针)。</li>
</ol>
</li>
</ul>
<h2 id="2-10-值传递和地址传递"><a href="#2-10-值传递和地址传递" class="headerlink" title="2.10 值传递和地址传递"></a>2.10 值传递和地址传递</h2><p>C 语言传递参数（或者赋值）可以是值传递（pass by value），也可以传递指针（a pointer passed by value），传递指针也叫地址传递。  </p>
<ol>
<li>默认传递值的类型： <strong>基本数据类型 (整型类型、 小数类型， 字符类型), 结构体, 共用体</strong>。</li>
<li>默认传递地址的类似： 指针、 数组。</li>
</ol>
<ul>
<li>特点<ul>
<li>值传递：将变量指向的存储内容， 在传递&#x2F;赋值时，拷贝一份给接收变量。</li>
<li>地址传递 也叫 指针传递：如果是指针，就将指针变量存储的地址，传递给接收变量，如果是数组， 就将数组的首地址传递给接收变量。</li>
</ul>
</li>
</ul>
<h1 id="3-常量"><a href="#3-常量" class="headerlink" title="3. 常量"></a>3. 常量</h1><ul>
<li>常量是<strong>固定值</strong>， 在程序执行期间不能改变。 这些固定的值， 又叫做<strong>字面量</strong>。</li>
<li>常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。</li>
<li>常量的值在定义后不能进行修改。</li>
</ul>
<h2 id="3-1-经常使用的常量"><a href="#3-1-经常使用的常量" class="headerlink" title="3.1 经常使用的常量"></a>3.1 经常使用的常量</h2><p><strong>整数常量</strong></p>
<p>整数常量可以是十进制、 八进制或十六进制的常量。 </p>
<p>前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 </p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合， U 表示无符号整数（unsigned） ， L 表示长整数（long） 。 后缀可以是大写， 也可以是小写， U 和 L 的顺序任意。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">85      /* 十进制 <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">0213 	/*</span> 八进制 <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">0x4b 	/*</span> 十六进制 <span class="emphasis">*/ 八进制和十六进制后面解释</span></span><br><span class="line"><span class="emphasis">30 		/*</span> 整数 <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">30u 	/*</span> 无符号整数 <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">30l 	/*</span> 长整数 <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">30ul 	/*</span> 无符号长整数 <span class="emphasis">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>浮点常量</strong></p>
<p>浮点常量由整数部分、 小数点、 小数部分和指数部分组成。 您可以使用小数形式或者指数形式来表示浮点常量。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.14159; 	//double 常量</span><br><span class="line">314159E-5; 	// 科学计数法</span><br><span class="line">3.1f; 		//float 常量</span><br></pre></td></tr></table></figure>

<p><strong>字符常量</strong></p>
<p>字符常量是括在单引号中，例如，’x’ 可以存储在 char 类型的变量中。字符常量可以是一个普通的字符（例如’x’）、一个转义序列（例如 ‘\t’）。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;X&#x27;</span><br><span class="line">&#x27;Y&#x27;</span><br><span class="line">&#x27;A&#x27;</span><br><span class="line">&#x27;b&#x27;</span><br><span class="line">&#x27;1&#x27;</span><br><span class="line">&#x27;\t&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>字符串常量</strong></p>
<p>字符串字面值或常量是括在双引号 “” 中的。 一个字符串包含类似于字符常量的字符： 普通的字符、 转义序列和通用的字符。 可以使用空格做分隔符， 把一个很长的字符串常量进行分行。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello, world&quot;</span><br><span class="line">&quot;北京&quot;</span><br><span class="line">&quot;hello \</span><br><span class="line">world&quot;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-常量的定义"><a href="#3-2-常量的定义" class="headerlink" title="3.2 常量的定义"></a>3.2 常量的定义</h2><ul>
<li>方式一<ul>
<li>使用 #define 预处理器。</li>
</ul>
</li>
<li>方式二<ul>
<li>使用 const 关键字。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14 <span class="comment">//定义常量 PI 常量值 3.14</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// PI = 3.1415 可以吗?=》 不可以修改， 因为 PI 是常量</span></span><br><span class="line">    <span class="comment">// 可以修改 PI 值?</span></span><br><span class="line">    <span class="comment">// PI = 3.1415; // 提示 = 左值 必须是可修改的值</span></span><br><span class="line">    <span class="type">double</span> area;</span><br><span class="line">    <span class="type">double</span> r = <span class="number">1.2</span>;<span class="comment">//半径</span></span><br><span class="line">    area = PI * r * r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;面积 : %.2f&quot;</span>, area);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">面积 : <span class="number">4.52</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. const 是一个关键字，规定好，表示后面定义了一个常量</span></span><br><span class="line"><span class="comment">//2. PI 是常量名，即是一个常量，常量值就是 3.14</span></span><br><span class="line"><span class="comment">//3. PI 因为是常量，因此不可以修改</span></span><br><span class="line"><span class="comment">//4. const 定义常量时，需要加 分号</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//PI = 3.1415 可以吗? =&gt; 不可以</span></span><br><span class="line">    <span class="type">double</span> area;</span><br><span class="line">    <span class="type">double</span> r = <span class="number">1.2</span>;</span><br><span class="line">    area = PI * r * r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;面积 : %.2f&quot;</span>, area);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>const 和 #define 的区别<ol>
<li>const 定义的常量时，带类型，define 不带类型。</li>
<li>const 是在 编译、运行的时候起作用，而 define 是在编译的预处理阶段起作用。</li>
<li>define 只是简单的替换，没有类型检查。简单的字符串替换会导致边界效应。</li>
<li>const 常量可以进行调试的，define 是不能进行调试的，主要是预编译阶段就已经替换掉了， 调试的时候就没它了。</li>
<li>const 不能重定义，不可以定义两个一样的，而 define 通过 undef 取消某个符号的定义，再重新定义。</li>
<li>define 可以配合#ifdef、#ifndef、#endif 来使用，可以让代码更加灵活，比如我们可以通过#define 来 启动或者关闭 调试信息。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B (A+3) <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C A/B*3 <span class="comment">//</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const不能重定义，不可以定义两个一样的，而define通过undef取消某个符号的定义，再重新定义</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// const double PI=3.145;  // 错误</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI2 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI2 <span class="comment">// 取消 PI2 的定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI2 3.145</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 分析过程</span></span><br><span class="line">    <span class="comment">// #define 就是一个简单的替换!!!</span></span><br><span class="line">    <span class="comment">// C 其实是 A/A+3*3 = 1/1 + 3 * 3 = 1 + 9 = 10</span></span><br><span class="line">    <span class="comment">// C 其实是 A/(A+3)*3 = 1/(1+3) * 3 = 1/4 *3 = ?</span></span><br><span class="line">    <span class="type">double</span> d1 = <span class="number">1.0</span>/<span class="number">4</span> *<span class="number">3</span> ; <span class="comment">// 0.25 * 3 = 0.75</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nc=%.2f&quot;</span>, C);<span class="comment">// 问 c = ?</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nd1=%.2f&quot;</span>, d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c=<span class="number">0.00</span></span><br><span class="line">d1=<span class="number">0.75</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define DEBUG</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG <span class="comment">//如果定义过 DEBUF</span></span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;ok, 调试信息&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> DEBUG <span class="comment">//如果没有定义过 DEBUF</span></span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;hello, 另外的信息&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h1><h2 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a>4.1 算术运算符</h2><p>算术运算符是对数值类型的变量进行运算的， 在 C 程序中使用的非常多。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">运算</th>
<th align="center">实例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">除</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取余</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">++</td>
<td align="center"></td>
<td align="center">a&#x3D;2;b&#x3D;++a;<br>a&#x3D;2;b&#x3D;a++;</td>
<td align="center">a&#x3D;3;b&#x3D;3<br>a&#x3D;3;b&#x3D;2</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center"></td>
<td align="center">a&#x3D;2;b&#x3D;–a;<br>a&#x3D;2;b&#x3D;a–;</td>
<td align="center">a&#x3D;1;b&#x3D;1<br>a&#x3D;1;b&#x3D;2</td>
</tr>
</tbody></table>
<ul>
<li>细节说明<ol>
<li>对于除号“&#x2F;” ， 它的整数除和小数除是有区别的： 整数之间做除法时， 只保留整数部分而舍弃小数部分。 例如： int x&#x3D; 10&#x2F;3 ,结果是 3。如果想要保留小数，参与运算数必须有浮点数。</li>
<li>当对一个数取模时， 可以等价 a%b&#x3D;a-a&#x2F;b*b ， 这样我们可以看到 取模的一个本质运算。  </li>
<li>当 自增 当做一个 表达式使用时 j &#x3D; ++i 等价 i &#x3D; i + 1; j &#x3D; i;  </li>
<li>当 自增 当做一个 表达式使用时 j &#x3D; i++ 等价 j &#x3D; i; i &#x3D; i + 1;</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理的流程 10 / 4 = 2.5 == 截取整数 ==&gt; 2 =&gt; 2.00000</span></span><br><span class="line"><span class="type">double</span> d1 = <span class="number">10</span> / <span class="number">4</span>; <span class="comment">//</span></span><br><span class="line"><span class="type">double</span> d2 = <span class="number">10.0</span> / <span class="number">4</span>; <span class="comment">//如果希望保留小数， 参与运算数必须有浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res1 = <span class="number">10</span> % <span class="number">3</span>; <span class="comment">// 求 10/3 的余数 1</span></span><br><span class="line"><span class="type">int</span> res2 = <span class="number">-10</span> % <span class="number">3</span>; <span class="comment">// = -10 - (-10) / 3 * 3 = -10- (-3) * 3 = -10 + 9 = -1</span></span><br><span class="line"><span class="type">int</span> res3 = <span class="number">10</span> % <span class="number">-3</span>; <span class="comment">// 10 - 10 / (-3) * (-3) = 10 - 9 = 1</span></span><br><span class="line"><span class="type">int</span> res4 = <span class="number">-10</span> % <span class="number">-3</span>; <span class="comment">// ? -1</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-关系运算符"><a href="#4-2-关系运算符" class="headerlink" title="4.2 关系运算符"></a>4.2 关系运算符</h2><p>结果只有 false 和 非0</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">== 等于</span><br><span class="line">!= 不等于</span><br><span class="line">&lt; 小于</span><br><span class="line"><span class="quote">&gt; 大于</span></span><br><span class="line">&lt;= 小于等于</span><br><span class="line">&gt;= 大于等于</span><br></pre></td></tr></table></figure>

<h2 id="4-3-逻辑运算符"><a href="#4-3-逻辑运算符" class="headerlink" title="4.3 逻辑运算符"></a>4.3 逻辑运算符</h2><p>用于连接多个条件（一般来讲就是关系表达式），最终的结果要么是真(非 0 表示)，要么是假(0 表示) 。  </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;</span><br><span class="line">||</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在进行 &amp;&amp; 操作时, 如果第一个条件为 false ,则后面的条件不在判断；</p>
<p>该现象称为 短路现象， 所以 逻辑与 也称为 短路逻辑与。</p>
</blockquote>
<h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><p>赋值运算符就是将某个运算后的值， 赋给指定的变量。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+&#x3D;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-&#x3D;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">*&#x3D;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x3D;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">%&#x3D;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&lt;&lt;&#x3D;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&gt;&gt;&#x3D;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&amp;&#x3D;</td>
<td align="center">按位与之后赋值</td>
<td align="center">C&amp;&#x3D;2 等同于C&#x3D;C&amp;2</td>
</tr>
<tr>
<td align="center">^&#x3D;</td>
<td align="center">按位异或之后赋值</td>
<td align="center">C^&#x3D;2 等同于C&#x3D;C^2</td>
</tr>
<tr>
<td align="center">|&#x3D;</td>
<td align="center">按位或之后赋值</td>
<td align="center">C|&#x3D;2 等同于C&#x3D;C|2</td>
</tr>
</tbody></table>
<h2 id="4-5-位运算符"><a href="#4-5-位运算符" class="headerlink" title="4.5 位运算符"></a>4.5 位运算符</h2><p>位运算符作用于位，并逐位执行操作。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp; 按位与</span><br><span class="line">| 按位或</span><br><span class="line">^ 按位异或，不一样为1，一样为0</span><br><span class="line">~ 按照二进制取反</span><br><span class="line">&lt;&lt; 左移，右边补0</span><br><span class="line">&gt;&gt; 右移，正数左边补0，负数左边补1。也可以直接认为左边补的就是符号位。</span><br></pre></td></tr></table></figure>

<h2 id="4-6-三元运算符"><a href="#4-6-三元运算符" class="headerlink" title="4.6 三元运算符"></a>4.6 三元运算符</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">条件表达式 ? 表达式 1: 表达式 2;</span><br><span class="line"></span><br><span class="line">如果条件表达式为非 0 (真)， 运算后的结果是表达式 1；</span><br><span class="line">如果条件表达式为 0 (假)， 运算后的结果是表达式 2；</span><br></pre></td></tr></table></figure>

<ul>
<li>注意细节<ol>
<li>表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换), 否则会有精度损失。</li>
<li>三元运算符可以转成 if–else 语句。</li>
</ol>
</li>
</ul>
<h2 id="4-7-运算符优先级"><a href="#4-7-运算符优先级" class="headerlink" title="4.7 运算符优先级"></a>4.7 运算符优先级</h2><table>
<thead>
<tr>
<th align="center"><strong>优先级</strong></th>
<th align="center"><strong>运算符</strong></th>
<th align="center"><strong>名称或含义</strong></th>
<th align="center"><strong>使用形式</strong></th>
<th align="center"><strong>结合方向</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">[]</td>
<td align="center">数组下标</td>
<td align="center">数组名[常量表达式]</td>
<td align="center">左到右</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">()</td>
<td align="center">圆括号</td>
<td align="center">(表达式)   函数名(形参表)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">.</td>
<td align="center">成员选择（对象）</td>
<td align="center">对象.成员名</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-&gt;</td>
<td align="center">成员选择（指针）</td>
<td align="center">对象指针-&gt;成员名</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">-</td>
<td align="center">负号运算符</td>
<td align="center">-表达式</td>
<td align="center">右到左</td>
<td align="center">单目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">(类型)</td>
<td align="center">强制类型转换</td>
<td align="center">(数据类型)表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">++</td>
<td align="center">自增运算符</td>
<td align="center">++变量名   变量名++</td>
<td align="center"></td>
<td align="center">单目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">–</td>
<td align="center">自减运算符</td>
<td align="center">–变量名   变量名–</td>
<td align="center"></td>
<td align="center">单目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">*</td>
<td align="center">取值运算符</td>
<td align="center">*指针变量</td>
<td align="center"></td>
<td align="center">单目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&amp;</td>
<td align="center">取地址运算符</td>
<td align="center">&amp;变量名</td>
<td align="center"></td>
<td align="center">单目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">!</td>
<td align="center">逻辑非运算符</td>
<td align="center">!表达式</td>
<td align="center"></td>
<td align="center">单目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">~</td>
<td align="center">按位取反运算符</td>
<td align="center">~表达式</td>
<td align="center"></td>
<td align="center">单目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">sizeof</td>
<td align="center">长度运算符</td>
<td align="center">sizeof(表达式)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">&#x2F;</td>
<td align="center">除</td>
<td align="center">表达式 &#x2F; 表达式</td>
<td align="center">左到右</td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">*</td>
<td align="center">乘</td>
<td align="center">表达式*表达式</td>
<td align="center"></td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">%</td>
<td align="center">余数（取模）</td>
<td align="center">整型表达式%整型表达式</td>
<td align="center"></td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">+</td>
<td align="center">加</td>
<td align="center">表达式+表达式</td>
<td align="center">左到右</td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-</td>
<td align="center">减</td>
<td align="center">表达式-表达式</td>
<td align="center"></td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">&lt;&lt;</td>
<td align="center">左移</td>
<td align="center">变量&lt;&lt;表达式</td>
<td align="center">左到右</td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&gt;&gt;</td>
<td align="center">右移</td>
<td align="center">变量&gt;&gt;表达式</td>
<td align="center"></td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">&gt;</td>
<td align="center">大于</td>
<td align="center">表达式&gt;表达式</td>
<td align="center">左到右</td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&gt;&#x3D;</td>
<td align="center">大于等于</td>
<td align="center">表达式&gt;&#x3D;表达式</td>
<td align="center"></td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&lt;</td>
<td align="center">小于</td>
<td align="center">表达式&lt;表达式</td>
<td align="center"></td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&lt;&#x3D;</td>
<td align="center">小于等于</td>
<td align="center">表达式&lt;&#x3D;表达式</td>
<td align="center"></td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">&#x3D;&#x3D;</td>
<td align="center">等于</td>
<td align="center">表达式&#x3D;&#x3D;表达式</td>
<td align="center">左到右</td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">!&#x3D;</td>
<td align="center">不等于</td>
<td align="center">表达式!&#x3D; 表达式</td>
<td align="center"></td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">&amp;</td>
<td align="center">按位与</td>
<td align="center">表达式&amp;表达式</td>
<td align="center">左到右</td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">^</td>
<td align="center">按位异或</td>
<td align="center">表达式^表达式</td>
<td align="center">左到右</td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">|</td>
<td align="center">按位或</td>
<td align="center">表达式|表达式</td>
<td align="center">左到右</td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">&amp;&amp;</td>
<td align="center">逻辑与</td>
<td align="center">表达式&amp;&amp;表达式</td>
<td align="center">左到右</td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">||</td>
<td align="center">逻辑或</td>
<td align="center">表达式||表达式</td>
<td align="center">左到右</td>
<td align="center">双目运算符</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">?:</td>
<td align="center">条件运算符</td>
<td align="center">表达式1? 表达式2: 表达式3</td>
<td align="center">右到左</td>
<td align="center">三目运算符</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">&#x3D;</td>
<td align="center">赋值运算符</td>
<td align="center">变量&#x3D;表达式</td>
<td align="center">右到左</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&#x2F;&#x3D;</td>
<td align="center">除后赋值</td>
<td align="center">变量&#x2F;&#x3D;表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">*&#x3D;</td>
<td align="center">乘后赋值</td>
<td align="center">变量*&#x3D;表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">%&#x3D;</td>
<td align="center">取模后赋值</td>
<td align="center">变量%&#x3D;表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">+&#x3D;</td>
<td align="center">加后赋值</td>
<td align="center">变量+&#x3D;表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-&#x3D;</td>
<td align="center">减后赋值</td>
<td align="center">变量-&#x3D;表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&lt;&lt;&#x3D;</td>
<td align="center">左移后赋值</td>
<td align="center">变量&lt;&lt;&#x3D;表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&gt;&gt;&#x3D;</td>
<td align="center">右移后赋值</td>
<td align="center">变量&gt;&gt;&#x3D;表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&amp;&#x3D;</td>
<td align="center">按位与后赋值</td>
<td align="center">变量&amp;&#x3D;表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">^&#x3D;</td>
<td align="center">按位异或后赋值</td>
<td align="center">变量^&#x3D;表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">|&#x3D;</td>
<td align="center">按位或后赋值</td>
<td align="center">变量|&#x3D;表达式</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">,</td>
<td align="center">逗号运算符</td>
<td align="center">表达式,表达式,…</td>
<td align="center">左到右</td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>算术运算符 &gt; 关系运算符 &gt; 逻辑运算符(逻辑非! 除外) &gt; 赋值运算符 &gt; 逗号运算符  </p>
</blockquote>
<h2 id="4-8-表示符名命规范"><a href="#4-8-表示符名命规范" class="headerlink" title="4.8 表示符名命规范"></a>4.8 表示符名命规范</h2><p>C 语言 对各种变量、函数等命名时使用的字符序列称为标识符。</p>
<p>凡是自己可以起名字的地方都叫标识符。</p>
<ul>
<li><p>命名规则</p>
<ol>
<li>由 26 个英文字母大小写， 0-9 ， _或 $ 组成。</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>C 语言中严格区分大小写， 长度无限制。</li>
<li>标识符不能包含空格。</li>
</ol>
</li>
<li><p>规范</p>
<ol>
<li>程序中不得出现仅靠大小写区分的相似的标识符</li>
<li>所有宏定义、 枚举常数、 常量(只读变量)全用大写字母命名， 用下划线分隔单词</li>
<li>定义变量别忘了初始化。 定义变量时编译器并不一定清空了这块内存，它的值可能是无效的数据，运行程序，会异常退出。</li>
<li>变量名、函数名：多单词组成时，第一个单词首字母小写， 第二个单词开始每个单词首字母大写。小驼峰。</li>
</ol>
</li>
</ul>
<h2 id="4-9-关键字"><a href="#4-9-关键字" class="headerlink" title="4.9 关键字"></a>4.9 关键字</h2><p>被C语言用作特殊用途的字符串</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto、break、case、char、const、continue、default、do、</span><br><span class="line">double、else、enum、extern、float、for、goto、if、</span><br><span class="line">int、long、register、return、short、signed、sizeof、static、</span><br><span class="line">struct、switch、typedef、union、unsigned、void、volatile、while</span><br></pre></td></tr></table></figure>

<p>C99标准中有增加了5个</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline、retrict、<span class="emphasis">_Bool、_</span>Complex、<span class="emphasis">_Imaginary</span></span><br></pre></td></tr></table></figure>

<p>C11标准中新增了7个</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_Alignas、_</span>Alignof、<span class="emphasis">_Atomic、_</span>Static<span class="emphasis">_assert、_</span>Noreturn、</span><br><span class="line"><span class="emphasis">_Thread_</span>local、<span class="emphasis">_Generic</span></span><br></pre></td></tr></table></figure>

<h2 id="4-10-键盘输入语句"><a href="#4-10-键盘输入语句" class="headerlink" title="4.10 键盘输入语句"></a>4.10 键盘输入语句</h2><p>步骤</p>
<ol>
<li>include &lt;stdio.h&gt; </li>
<li>使用 scanf 函数</li>
<li>使用适当的格式接收</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用字符数组接收名</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> sal = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">char</span> gender = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提示用户输入信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入名字： &quot;</span>);</span><br><span class="line">    <span class="comment">// scanf(&quot;%s&quot;, name) 表示接收 一个字符串， 存放到 name 字符数组</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入年龄： &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age); <span class="comment">// 因为我们将得到输入存放到 age 变量指向地址,因此需要加 &amp;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入薪水： &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;sal); <span class="comment">// 接收一个 double 时， 格式参数 %lf</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入性别(m/f)： &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;gender); <span class="comment">// 这里是接收到了上面的回车字符</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;gender); <span class="comment">// 等待用户输入.</span></span><br><span class="line">    <span class="comment">//输 出得到信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nname %s age %d sal %.2f gender %c&quot;</span>, name, age,sal,gender);</span><br><span class="line">    getchar(); <span class="comment">// 接收到一个回车</span></span><br><span class="line">    getchar(); <span class="comment">// 这个 getchar() 才会让控制台暂停</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-二进制和位运算"><a href="#5-二进制和位运算" class="headerlink" title="5. 二进制和位运算"></a>5. 二进制和位运算</h1><h2 id="5-1-进制"><a href="#5-1-进制" class="headerlink" title="5.1 进制"></a>5.1 进制</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num2 = <span class="number">210</span>;     	<span class="comment">// 十进制</span></span><br><span class="line"><span class="type">int</span> num3 = <span class="number">01010</span>; 		<span class="comment">// 八进制</span></span><br><span class="line"><span class="type">int</span> num4 = <span class="number">0x1010</span>;		<span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-位运算"><a href="#5-2-位运算" class="headerlink" title="5.2 位运算"></a>5.2 位运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>&gt;&gt;<span class="number">2</span>; <span class="comment">// 1 向右位移 2 位 , 这里还涉及到二进制中 原码， 反码， 补码</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">-1</span>&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">-1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// a,b,c,d,e 结果是多少</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d c=%d d=%d &quot;</span>,a,b,c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：a=<span class="number">0</span> b=<span class="number">-1</span> c=<span class="number">4</span> d=<span class="number">-4</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>二进制最高位 表示符号位。0表示正，1表示负。</p>
<p>原码：正数 0000 1111、0000 0001、负数 1000 0001、1000 1111</p>
<p>反码：         0000 1111、0000 0001、         1111 1110、1111 0000</p>
<p>补码：         0000 1111、0000 0001、         1111 1111、1111 0001（就是反码+1）</p>
<p>计算机中存储的都是补码。没有原码和反码，移动的也都是补码。</p>
<p>对于正数好理解、就按照原码移动理解就好了。</p>
<p>对于负数，比如-1，补码是 1111 1111，除去符号位剩下 111 1111，不管右移几位，左边都要补上1，最后加上符号位还是 1111 1111，对应的数还是-1.所以 -1不管左移几位都还是 -1。</p>
<p><strong>计算按位与 按位或等 都是这样的逻辑，用反码算。</strong></p>
</blockquote>
<h1 id="6-程序与流程控制"><a href="#6-程序与流程控制" class="headerlink" title="6. 程序与流程控制"></a>6. 程序与流程控制</h1><ul>
<li>顺序控制</li>
<li>分支控制</li>
<li>循环控制</li>
</ul>
<h2 id="6-1-if-分支控制"><a href="#6-1-if-分支控制" class="headerlink" title="6.1 if 分支控制"></a>6.1 if 分支控制</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    <span class="comment">// 这是单分支语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    <span class="comment">// 分支1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 分支2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 分支1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(条件表达式<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 分支2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(条件表达式<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">// 分支3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 分支n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-switch-分支结构"><a href="#6-2-switch-分支结构" class="headerlink" title="6.2 switch 分支结构"></a>6.2 switch 分支结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">3</span>:</span><br><span class="line">        语句块<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">4</span>:</span><br><span class="line">        语句块<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">default</span>语句块<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>细节<ol>
<li>switch 语句中的 expression 是一个常量表达式， 必须是一个<strong>整型(char、 short, int, long 等) 或枚举类型</strong>。</li>
<li>case 子句中的值必须是常量，而不能是变量。</li>
<li>default 子句是可选的，当没有匹配的 case 时，执行 default。</li>
<li>break 语句用来在执行完一个 case 分支后使程序跳出 switch 语句块。</li>
<li>如果没有写 break，会执行下一个 case 语句块，直到遇到 break 或者执行到 switch 结尾，这个现象称为穿透。</li>
</ol>
</li>
</ul>
<h2 id="6-3-for循环控制"><a href="#6-3-for循环控制" class="headerlink" title="6.3 for循环控制"></a>6.3 for循环控制</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world, i=%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用细节<ol>
<li>循环条件是 返回一个表示真(非 0)假(0) 的表达式。</li>
<li>**for(;循环判断条件;)**中的初始化和变量迭代可以不写（写到其它地方），但是两边的分号不能省略。</li>
<li>循环初始值可以有多条初始化语句， 但要求类型一样， 并且中间用逗号隔开， 循环变量迭代也可以有多条变量迭代语句， 中间用逗号隔开。  <strong>for(i &#x3D; 0, j &#x3D; 0; j &lt; count; i++, j +&#x3D; 2)</strong></li>
</ol>
</li>
</ul>
<h2 id="6-4-while循环控制"><a href="#6-4-while循环控制" class="headerlink" title="6.4 while循环控制"></a>6.4 while循环控制</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">5</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world, i=%d&quot;</span>, i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-do…while循环控制"><a href="#6-5-do…while循环控制" class="headerlink" title="6.5 do…while循环控制"></a>6.5 do…while循环控制</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//循环变量初始化</span></span><br><span class="line"><span class="type">int</span> max = <span class="number">5</span>; <span class="comment">//循环的最大次数</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n hello，world i=%d&quot;</span>, i); <span class="comment">//循环体</span></span><br><span class="line">    i++; <span class="comment">//循环变量迭代</span></span><br><span class="line">&#125;<span class="keyword">while</span>(i &lt;= max); <span class="comment">// 循环条件 后面有一个分号，不能省略.</span></span><br></pre></td></tr></table></figure>

<h2 id="6-6-跳转控制语句break"><a href="#6-6-跳转控制语句break" class="headerlink" title="6.6 跳转控制语句break"></a>6.6 跳转控制语句break</h2><p>结束循环。</p>
<h2 id="6-7-跳转控制语句continue"><a href="#6-7-跳转控制语句continue" class="headerlink" title="6.7 跳转控制语句continue"></a>6.7 跳转控制语句continue</h2><p>结束本轮循环。直接开始下一轮循环。<strong>只能配合循环语言使用，不能单独和 switch&#x2F;if 使用</strong>。  </p>
<h2 id="6-8-跳转控制语句goto"><a href="#6-8-跳转控制语句goto" class="headerlink" title="6.8 跳转控制语句goto"></a>6.8 跳转控制语句goto</h2><ol>
<li>C 语言的 goto 语句可以无条件地转移到程序中指定的行。</li>
<li>goto 语句通常与条件语句配合使用。可用来实现条件转移，跳出循环体等功能。</li>
<li>在 C 程序设计中一般不主张使用 goto 语句，以免造成程序流程的混乱，使理解和调试程序都产生困难。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> lable1; <span class="comment">//lable1 称为标签</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ok1\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ok2\n&quot;</span>);</span><br><span class="line">lable1:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ok3\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ok4\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="6-9-跳转控制语句return"><a href="#6-9-跳转控制语句return" class="headerlink" title="6.9 跳转控制语句return"></a>6.9 跳转控制语句return</h2><p>return 使用在函数，表示跳出所在的函数。</p>
<h1 id="7-枚举"><a href="#7-枚举" class="headerlink" title="7. 枚举"></a>7. 枚举</h1><p>举个例子， 比如： 一星期有 7 天， 请定义数据表示星期一到星期天. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MON 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WED 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THU 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRI 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAT 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN 7</span></span><br></pre></td></tr></table></figure>

<h2 id="7-1-基本介绍"><a href="#7-1-基本介绍" class="headerlink" title="7.1 基本介绍"></a>7.1 基本介绍</h2><ol>
<li>枚举是 C 语言中的一种构造数据类型，它可以让数据更简洁，更易读, 对于只有几个有限的特定数据，可以使用枚举。</li>
<li>枚举对应英文(enumeration, 简写 enum)。</li>
<li>枚举是一组常量的集合，包含一组有限的特定的数据。</li>
<li>枚举语法定义格式为：<code>enum 枚举名 &#123;枚举元素1,枚举元素2,……&#125;;  </code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span>&#123;</span></span><br><span class="line">        MON=<span class="number">1</span>, TUE=<span class="number">2</span>, WED=<span class="number">3</span>, THU=<span class="number">4</span>, FRI=<span class="number">5</span>, SAT=<span class="number">6</span>, SUN=<span class="number">7</span></span><br><span class="line">    &#125;; <span class="comment">// 这里 DAY 就是枚举类型, 包含了 7 个枚举元素</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span> <span class="comment">// enum DAY 是枚举类型， day 就是枚举变量</span></span><br><span class="line">    day = WED; <span class="comment">//给枚举变量 day 赋值， 值就是某个枚举元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, day); <span class="comment">// 3 ， 每个枚举元素对应一个值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-枚举的遍历"><a href="#7-2-枚举的遍历" class="headerlink" title="7.2 枚举的遍历"></a>7.2 枚举的遍历</h2><p>C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，枚举类型必须连续是可以实现有条件的遍历。</p>
<p>以下实例使用 for 来遍历枚举的元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历枚举元素</span></span><br><span class="line"><span class="comment">// day++ 会给出警告， 但是可以运行</span></span><br><span class="line"><span class="keyword">for</span> (day = MON; day &lt;= SUN; day++) &#123; <span class="comment">// 要求枚举元素是连续赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;枚举元素： %d \n&quot;</span>, day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-switch-中使用枚举"><a href="#7-3-switch-中使用枚举" class="headerlink" title="7.3 switch 中使用枚举"></a>7.3 switch 中使用枚举</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">SEASONS</span> &#123;</span>SPRING=<span class="number">1</span>, SUMMER, AUTUMN, WINTER&#125;; <span class="comment">//定义枚举类型 enum SEASONS</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">SEASONS</span> <span class="title">season</span>;</span><span class="comment">//定义了一个枚举类型变量 season(类型 enum SEASONS )</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你喜欢的季节: (1. spring, 2. summer, 3. autumn 4. winter): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;season);</span><br><span class="line">    <span class="keyword">switch</span> (season) &#123;</span><br><span class="line">        <span class="keyword">case</span> SPRING:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你喜欢的季节是春天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUMMER:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你喜欢的季节是夏天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AUTUMN:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你喜欢的季节是秋天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WINTER:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你喜欢的季节是冬天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你没有选择你喜欢的季节&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用细节</p>
<ol>
<li><p>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。 我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
</li>
<li><p>在定义枚举类型时改变枚举元素的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> &#123;</span></span><br><span class="line">MON, TUE, WED, THU=<span class="number">9</span>, FRI, SAT, SUN <span class="comment">// 如果没有给赋值， 就会按照顺序赋值</span></span><br><span class="line">&#125; day; <span class="comment">// 表示 定义了一个枚举类型 enum Day ,同时定义了一个变量 day(类型是 enum DAY)</span></span><br><span class="line"><span class="comment">// 说明 FRI, SAT, SUN 就是 10, 11, 12</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举类型的 三种定义方式。</p>
<ol>
<li><pre><code class="language-c">enum DAY &#123;
    MON=1, TUE, WED, THU, FRI, SAT, SUN
&#125;;
enum DAY day;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ~~~ c</span><br><span class="line">   enum DAY &#123;</span><br><span class="line">   	MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">   &#125; day;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="language-c">enum &#123;
    MON=1, TUE, WED, THU, FRI, SAT, SUN
&#125; day; // 这样使用枚举， 该枚举类型只能使用一次.
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 不能直接将一个整数，赋给枚举变量，但是可以将整数，转成枚举类型，再赋给枚举变量.  </span><br><span class="line"></span><br><span class="line">   ~~~ c</span><br><span class="line">   enum SEASONS &#123;SPRING=1, SUMMER, AUTUMN, WINTER&#125;;</span><br><span class="line">   enum SEASONS season;</span><br><span class="line">   int n = 4;</span><br><span class="line">   season = (enum SEASONS) n;</span><br><span class="line">   printf(&quot;season=:%d&quot;,season);</span><br><span class="line">   </span><br><span class="line">   标准输出：season=:4</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h1><ul>
<li>为完成某一功能的程序指令(语句)的集合，称为函数。</li>
<li>在 C 语言中，函数分为：自定义函数、系统函数(查看 C 语言函数手册)</li>
<li>函数还有其它叫法，比如方法等，我们统一称为 函数。</li>
</ul>
<h2 id="8-1-函数的定义"><a href="#8-1-函数的定义" class="headerlink" title="8.1 函数的定义"></a>8.1 函数的定义</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(形参列表)&#123;</span><br><span class="line"><span class="code">	执行语句;</span></span><br><span class="line"><span class="code">	return 返回值;  // 如果 返回类型为void 可以没有返回值</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">double cal(int n1, int n2) &#123;</span><br><span class="line"><span class="code">	double res = 0.0;</span></span><br><span class="line"><span class="code">	res = n1 + n2</span></span><br><span class="line"><span class="code">	return res;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">int main()&#123;</span><br><span class="line"><span class="code">    int num1 = 10; //第一个数</span></span><br><span class="line"><span class="code">    int num2 = 20; //第二个数</span></span><br><span class="line"><span class="code">	return cal(num1, num2);</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-2-头文件"><a href="#8-2-头文件" class="headerlink" title="8.2 头文件"></a>8.2 头文件</h2><p>在实际的开发中，我们往往需要在不同的文件中，去调用其它文件的定义的函数， 比如 hello.c 中，去使用myfuns.c 文件中的函数。</p>
<ul>
<li>头文件<ol>
<li>头文件是<strong>扩展名为 .h</strong>的文件， 包含了<strong>C 函数声明和宏定义</strong>， 被多个源文件中引用共享。 有两种类型的头文件：程序员编写的头文件和 C 标准库自带的头文件。</li>
<li>在程序中要使用头文件，需要使用<strong>C 预处理指令 #include</strong>来引用它。 前面我们已经看过 stdio.h 头文件，它是C 标准库自带的头文件。</li>
<li>#include 叫做文件包含命令， 用来引入对应的头文件（.h 文件）。#include 也是 C 语言预处理命令的一种。#include 的处理过程很简单， 就是将头文件的内容插入到该命令所在的位置， 从而把头文件和当前源文件连接成一个源文件， 这与复制粘贴的效果相同。 </li>
<li><strong>建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</strong></li>
</ol>
</li>
</ul>
<p>如</p>
<p>myfun.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myCal</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">char</span> oper)</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个变量 res ,保存运算的结果</span></span><br><span class="line">    <span class="type">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(oper) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">            res = n1 + n2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            res = n1 - n2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            res = n1 * n2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            res = n1 / n2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你的运算符有误~&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d %c %d = %.2f\n&quot;</span>, n1, oper, n2, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123; <span class="comment">//定义函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;say Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>myfun.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">myCal</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">char</span> oper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>hello.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//引入我们需要的头文件(用户头文件)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfun.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用 myCal 完成计算任务</span></span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">50</span>;</span><br><span class="line">    <span class="type">char</span> oper = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">//调用 myfun.c 中定义的函数 myCal</span></span><br><span class="line">    res = myCal(n1, n2, oper);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nres=%.2f&quot;</span>, res);</span><br><span class="line">    sayHello();</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用细节<ol>
<li>引用头文件相当于复制头文件的内容。</li>
<li>源文件的名字 可以不和头文件一样，但是为了好管理，一般头文件名和源文件名一样。</li>
<li>C 语言中 include &lt;&gt; 与 include “” 的区别<ol>
<li>include &lt;&gt;：引用的是编译器的类库路径里面的头文件，用于引用系统头文件。</li>
<li>include “”：引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件，用于引用用户头文件。</li>
<li><strong>引用系统头文件，两种形式都会可以，include &lt;&gt; 效率高。引用用户头文件，只能使用 include “”。</strong></li>
</ol>
</li>
<li>一个 #include 命令只能包含一个头文件，多个头文件需要多个 #include 命令。</li>
<li>同一个头文件如果被多次引入，多次引入的效果和一次引入的效果相同，因为头文件在代码层面有防止重复引入的机制。</li>
<li>在一个被包含的文件(.c)中又可以包含另一个文件头文件(.h)</li>
<li>不管是标准头文件，还是自定义头文件，都只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误。</li>
</ol>
</li>
</ul>
<h2 id="8-3-函数细节"><a href="#8-3-函数细节" class="headerlink" title="8.3 函数细节"></a>8.3 函数细节</h2><ol>
<li><p>函数的形参列表可以是多个。</p>
</li>
<li><p>C 语言传递参数可以是值传递（pass by value） ， 也可以传递指针（a pointer passed by value） 也叫引用传递。</p>
</li>
<li><p>函数的命名遵循标识符命名规范，首字母不能是数字，可以采用 驼峰法 或者 下划线法。</p>
</li>
<li><p>函数中的变量是局部的，函数外不生效。</p>
</li>
<li><p>基本数据类型默认是值传递的， 即进行值拷贝。在函数内修改，不会影响到原来的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型默认是值传递的， 即进行值拷贝。 在函数内修改， 不会影响到原来的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n f2中的n=%d&quot;</span>, n); <span class="comment">// n=10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//函数中的变量是局部的， 函数外不生效</span></span><br><span class="line">    <span class="comment">//printf(&quot;num=%d&quot;, num);</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    f2(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n main 函数中 n=%d&quot;</span>, n); <span class="comment">// 9</span></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，函数内以指针的方式操作变量。从效果上看类似引用(即传递指针)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，</span></span><br><span class="line"><span class="comment">// 函数内以指针的方式操作变量。 从效果上看类似引用(即传递指针)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">    (*p)++; <span class="comment">// 修改会对函数外的变量有影响</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 函数中的变量是局部的， 函数外不生效</span></span><br><span class="line">    <span class="comment">// printf(&quot;num=%d&quot;, num);</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    f3(&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nmain 函数中 n=%d&quot;</span>, n); <span class="comment">//10</span></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C 语言 不支持函数重载。</p>
</li>
<li><p>C 语言支持可变参数函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// num 表示传递的参数格式</span></span><br><span class="line"><span class="comment">// ... 表示可以传递多个参数和 num 一致即可</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> num, ...)</span> <span class="comment">// 可变函数， 即参数的个数可以不确定, 使用... 表示</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, totalSum=<span class="number">0</span>;  <span class="comment">// totalSum 一定要初始化</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    va_list v1;  <span class="comment">// v1 实际是一个字符指针，从头文件里可以找到</span></span><br><span class="line">    va_start(v1, num); <span class="comment">// 使 v1 指向可变列表中第一个值， 即 num 后的第一个参数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*v = %d \n&quot;</span>, *v1);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++) <span class="comment">//num 减一是为了防止下标超限</span></span><br><span class="line">    &#123;</span><br><span class="line">        val = va_arg(v1, <span class="type">int</span>); <span class="comment">// 该函数返回 v1 指向的值， 并使 v1 向下移动一个 int 的距离， 使其指向下一个 int</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;val = %d\n&quot;</span>, val); <span class="comment">// val = 10 val=30 val=60</span></span><br><span class="line">        totalSum += val;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(v1); <span class="comment">//关闭 v1 指针， 使其指向 null</span></span><br><span class="line">    <span class="keyword">return</span> totalSum;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = fun(<span class="number">8</span>, <span class="number">10</span>,<span class="number">30</span>,<span class="number">60</span>, <span class="number">-100</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">98</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;和是=%d&quot;</span>, res);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="8-4-函数参数的传递方式"><a href="#8-4-函数参数的传递方式" class="headerlink" title="8.4 函数参数的传递方式"></a>8.4 函数参数的传递方式</h2><p>C 语言传递参数可以是值传递（pass by value） ， 也可以传递指针（a pointer passed by value） 也叫传递地址或者 引用传递。  </p>
<blockquote>
<p>其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的数据大小，数据越大，效率越低。</p>
</blockquote>
<ul>
<li>值传递和引用传递使用特点<ul>
<li>值传递：变量直接存储值，内存通常在栈中分类。</li>
<li><strong>默认是值传递的数据类型有</strong>：1. 基本数据类型；2. 结构体；3. 共用体；4. 枚举。</li>
<li>引用传递：变量存储的是一个地址，这个地址对应的空间才真正存储数据（值）。</li>
<li><strong>默认是引用传递的数据类型有</strong>：指针和数组。</li>
</ul>
</li>
</ul>
<p>如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，函数内以指针的方式操作变量(*指针)。<br>从效果上看类似引用，比如修改结构体的属性。</p>
<h2 id="8-5-变量作用域"><a href="#8-5-变量作用域" class="headerlink" title="8.5 变量作用域"></a>8.5 变量作用域</h2><p>所谓变量作用域（Scope），就是指变量的有效范围。</p>
<ol>
<li>函数内部声明&#x2F;定义的局部变量，作用域仅限于函数内部。</li>
<li>函数的参数，形式参数，被当作该<strong>函数内的局部变量</strong>，如果与<strong>全局变量同名</strong>它们会优先使用<strong>局部变量</strong>(编译器使用就近原则)。</li>
<li>在一个代码块，比如 for &#x2F; if 中 的局部变量，那么这个变量的的作用域就在该代码块。</li>
<li>在所有函数外部定义的变量叫全局变量，作用域在整个程序有效。</li>
</ol>
<ul>
<li><p>初始化</p>
<ol>
<li>局部变量，系统不会对其默认初始化，必须对局部变量初始化后才能使用，否则，程序运行后可能会异常退出。</li>
<li>全局变量，系统会自动对其初始化，如下所示。<ol>
<li>int   0</li>
<li>char   ‘\0’</li>
<li>float   0.0</li>
<li>double  0.0</li>
<li>pointer指针  NULL</li>
</ol>
</li>
<li>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</li>
</ol>
</li>
<li><p>使用细节</p>
<ol>
<li><p><strong>全局变量(Global Variable)保存在内存的全局存储区中</strong>，占用静态的存储单元，它的作用域默认是整个程序，也就是所有的代码文件，包括源文件（.c 文件）和头文件（.h 文件）。</p>
<p><img src="/2017/01/01/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/c/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98.jpg" alt="计算机内存"></p>
</li>
<li><p><strong>局部变量(Local Variable)保存在栈中</strong>，函数被调用时才动态地为变量分配存储单元，它的作用域仅限于函数内部。 </p>
</li>
<li><p>C 语言规定，<strong>只能从小的作用域向大的作用域中去寻找变量</strong>，而不能反过来。</p>
</li>
<li><p>在<strong>同一个作用域，变量名不能重复</strong>，在不同的作用域，变量名可以重复，使用时编译器采用就近原则。</p>
</li>
<li><p>由**{ }包围的代码块也拥有独立的作用域**。</p>
</li>
</ol>
</li>
</ul>
<h2 id="8-6-static关键字"><a href="#8-6-static关键字" class="headerlink" title="8.6 static关键字"></a>8.6 static关键字</h2><p>static 关键字在 c 语言中比较常用，使用恰当能够大大提高程序的模块化特性，有利于扩展和维护。</p>
<ul>
<li><p>局部变量使用 static 修饰</p>
<ol>
<li><p>局部变量被 static 修饰后，我们称为静态局部变量。</p>
</li>
<li><p>对应静态局部变量在声明时未赋初值，编译器也会把它初始化为 0。</p>
</li>
<li><p>静态局部变量存储于进程的静态存储区(全局性质)，只会被初始一次，即使函数返回，它的值也会保持不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;  <span class="comment">//普通变量, 每次执行都会初始化， n 在栈区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n=%d \n&quot;</span>, n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n++=%d \n&quot;</span>, n);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fn_static</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n = <span class="number">10</span>; <span class="comment">//静态局部变量， 放在静态存储区， 全局性质空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n static n=%d \n&quot;</span>, n); <span class="comment">// 10</span></span><br><span class="line">    n++; <span class="comment">// n = 11</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n n++=%d \n&quot;</span>, n); <span class="comment">// 11</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    fn_static();</span><br><span class="line">    fn_static();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：  <span class="comment">// 可以看出  第二次运行的初始化 并没有成功</span></span><br><span class="line"><span class="type">static</span> n=<span class="number">10</span> </span><br><span class="line">n++=<span class="number">11</span></span><br><span class="line"><span class="type">static</span> n=<span class="number">11</span> </span><br><span class="line">n++=<span class="number">12</span> </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>全局变量使用 static 修饰</p>
<ol>
<li><p>普通全局变量对整个工程可见，其他文件可以使用 extern 外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了。静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。</p>
</li>
<li><p>定义不需要与其他文件共享的全局变量时，加上 static 关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">file01.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在一个文件中， 使用另外一个文件的全局变量, 使用 extern 引入即可</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line"><span class="comment">// extern int num2;  不可以</span></span><br><span class="line"><span class="type">int</span> num2 = <span class="number">60</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nnum=%d num2=%d&quot;</span>, num, num2);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file02.c</span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>; <span class="comment">// 普通全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num2 = <span class="number">20</span>;  <span class="comment">// 静态全局变量, 只能在本文件中使用， 而不能在其它文件使用</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>函数使用 static 修饰</p>
<ol>
<li>函数的使用方式与全局变量类似，<strong>在函数的返回类型前加上 static，就是静态函数。</strong></li>
<li>非静态函数可以在另一个文件中通过 extern 引用。</li>
<li>静态函数<strong>只能在声明它的文件中可见</strong>，其他文件不能引用该函数。</li>
<li><strong>不同的文件可以使用相同名字的静态函数</strong>，互不影响。</li>
</ol>
</li>
</ul>
<h2 id="8-7-字符串中常用的系统函数"><a href="#8-7-字符串中常用的系统函数" class="headerlink" title="8.7 字符串中常用的系统函数"></a>8.7 字符串中常用的系统函数</h2><p>头文件 &lt;string.h&gt;</p>
<ol>
<li>得到字符串的长度	<code>size_t strlen(const char *str)</code></li>
<li>拷贝字符串  <code>char *strcpy(char *dest, const char *src)</code>   把 src 所指向的字符串复制到 dest。</li>
<li>连接字符串   <code>char *strcat(char *dest, const char *src)</code>    把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> src[<span class="number">50</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];  <span class="comment">// 定义了两个字符数组(字符串) , 大小为 50</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;abcdff&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str.len=%d \n&quot;</span>, <span class="built_in">strlen</span>(str));  <span class="comment">// 统计字符串的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示将 &quot;hello&quot; 拷贝到 src</span></span><br><span class="line">    <span class="comment">// 注意， 拷贝字符串会将原来的内容覆盖</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\s src=%s \n&quot;</span>, src);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(dest, <span class="string">&quot;world &quot;</span>);</span><br><span class="line">    <span class="comment">//strcat 是将 src 字符串的内容连接到 dest ,但是不会覆盖 dest 原来的内容， 而是连接!!</span></span><br><span class="line">    <span class="built_in">strcat</span>(dest, src); <span class="comment">// &quot;hello 尚硅谷&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最终的目标字符串： dest=%s \n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：str.len=<span class="number">6</span> </span><br><span class="line">s src=hello </span><br><span class="line">最终的目标字符串： dest=world hello </span><br></pre></td></tr></table></figure>

<h2 id="8-8-时间和日期相关函数"><a href="#8-8-时间和日期相关函数" class="headerlink" title="8.8 时间和日期相关函数"></a>8.8 时间和日期相关函数</h2><p>头文件 &lt;time.h&gt;</p>
<ol>
<li>获取当前时间  <code>char *ctime(const time_t *timer)</code>    返回一个表示当地时间的字符串， 当地时间是基于参数 timer。  </li>
<li>编写一段代码来统计 函数 test 执行的时间  <code>double difftime(time_t time1, time_t time2)</code>返回 time1 和 time2 之间相差的秒数 (time1-time2)。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123; <span class="comment">// 运行 test 函数， 看看执行花费时间</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">77777777</span>;i++) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt; <span class="number">10</span>;j++) &#123;</span><br><span class="line">            sum += j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">time_t</span> curtime; <span class="comment">// time_h 是一个结构体类型</span></span><br><span class="line">    time(&amp;curtime); <span class="comment">// time() 完成初始化</span></span><br><span class="line">    <span class="comment">// ctime 返回一个表示当地时间的字符串， 当地时间是基于参数 timer</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前时间 = %s&quot;</span>, ctime(&amp;curtime));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先得到执行 test 前的时间</span></span><br><span class="line">    <span class="type">time_t</span> <span class="type">start_t</span>, <span class="type">end_t</span>;</span><br><span class="line">    <span class="type">double</span> <span class="type">diff_t</span>; <span class="comment">//存放时间差</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序启动...\n&quot;</span>);</span><br><span class="line">    time(&amp;<span class="type">start_t</span>); <span class="comment">//初始化得到当前时间</span></span><br><span class="line">    test(); <span class="comment">//执行 test</span></span><br><span class="line">    <span class="comment">//再得到执行 test 后的时间</span></span><br><span class="line">    time(&amp;<span class="type">end_t</span>);<span class="comment">//得到当前时间</span></span><br><span class="line">    <span class="type">diff_t</span> = difftime(<span class="type">end_t</span>, <span class="type">start_t</span>); <span class="comment">//时间差， 按秒 ent_t - start_t</span></span><br><span class="line">    <span class="comment">//然后得到两个时间差就是耗用的时间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行 test()函数 耗用了%.2f 秒&quot;</span>, <span class="type">diff_t</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：当前时间 = Wed Sep  <span class="number">7</span> <span class="number">10</span>:<span class="number">05</span>:<span class="number">00</span> <span class="number">2022</span></span><br><span class="line">程序启动...</span><br><span class="line">执行 test()函数 耗用了<span class="number">1.00</span> 秒</span><br></pre></td></tr></table></figure>

<h2 id="8-9-数学相关函数"><a href="#8-9-数学相关函数" class="headerlink" title="8.9 数学相关函数"></a>8.9 数学相关函数</h2><p>math.h 头文件定义了各种数学函数和一个宏。 在这个库中所有可用的功能都带有一个 double 类型的参数， 且都返回 double 类型的结果。</p>
<ol>
<li><code>double exp(double x)  </code>  返回 e 的 x 次幂的值  </li>
<li><code>double log(double x)  </code>返回 x 的自然对数（基数为 e 的对数）  </li>
<li><code>double pow(double x, double y)  </code>  返回 x 的 y 次幂。  </li>
<li><code>double sqrt(double x)  </code>返回 x 的平方根</li>
<li><code>double fabs(double x)  </code>返回 x 的绝对值。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="built_in">pow</span>(<span class="number">2.0</span>,<span class="number">3.0</span>);</span><br><span class="line">    <span class="type">double</span> d2 = <span class="built_in">sqrt</span>(<span class="number">5.0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d1=%.2f&quot;</span>, d1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d2=%.2f&quot;</span>, d2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-10-基本数据类型和字符串类型的转换"><a href="#8-10-基本数据类型和字符串类型的转换" class="headerlink" title="8.10 基本数据类型和字符串类型的转换"></a>8.10 基本数据类型和字符串类型的转换</h2><p>我们经常需要将基本数据类型转成字符串类型(即 char 数组 )。  或者将字符串类型转成基本数据类型。</p>
<ul>
<li>sprintf 函数的用法<ol>
<li>sprintf 和平时我们常用的 printf 函数的功能很相似。sprintf 函数打印到字符串中，而 printf 函数打印输出到屏幕上。sprintf 函数在我们完成其他数据类型转换成字符串类型的操作中应用广泛。</li>
<li>该函数包含在 stdio.h 的头文件中。</li>
</ol>
</li>
</ul>
<p><strong>基本类型转字符串类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>];  <span class="comment">// 字符数组， 即字符串</span></span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20984</span>, b = <span class="number">48090</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">14.309948</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. sprintf 是一个系统函数， 可以将结果存放到字符串中</span></span><br><span class="line">    <span class="comment">// 2. 格式化的结果， 会存放到 str1 中</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">&quot;%d %d&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">sprintf</span>(str2, <span class="string">&quot;%.2f&quot;</span>, d);</span><br><span class="line">    <span class="built_in">sprintf</span>(str3, <span class="string">&quot;%8.2f&quot;</span>, d); </span><br><span class="line">    <span class="comment">// %8.2f 含义是格式化后， 一共有 8 位， 小数点后占用 2 位， 不够用空格占位</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1=%s str2=%s str3=%s&quot;</span>, str1, str2, str3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：str1=<span class="number">20984</span> <span class="number">48090</span> str2=<span class="number">14.31</span> str3=   <span class="number">14.31</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串类型转基本数据类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 字符数组</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">10</span>] = <span class="string">&quot;12.67423&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">3</span>] = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str4[<span class="number">4</span>] = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. atoi(str) 将 str 转成整数</span></span><br><span class="line">    <span class="type">int</span> num1 = atoi(str);</span><br><span class="line">    <span class="type">short</span> s1 = atoi(str4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. atof(str2); 将 str2 转成小数</span></span><br><span class="line">    <span class="type">double</span> d = atof(str2);</span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. str3[0] 表示获取到 str3 这个字符串(数组)的第一个元素 &#x27;a&#x27;</span></span><br><span class="line">    <span class="type">char</span> c = str3[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num1=%d d=%f c=%c s1=%d&quot;</span>, num1, d, c, s1);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：num1=<span class="number">123456</span> d=<span class="number">12.674230</span> c=a s1=<span class="number">111</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项<ol>
<li>在将 char 数组 类型转成 基本数据类型时，要确保能够转成有效的数据，比如 我们可以把 “123” , 转成一个整数，但是不能把 “hello” 转成一个整数。</li>
<li>如果格式不正确，会默认转成 0 或者 0.0。</li>
</ol>
</li>
</ul>
<h1 id="9-预处理命令"><a href="#9-预处理命令" class="headerlink" title="9. 预处理命令"></a>9. 预处理命令</h1><ul>
<li>使用库函数之前，应该用 #include 引入对应的头文件。这种以#号开头的命令称为预处理命令。</li>
<li>这些在编译之前对源文件进行简单加工的过程，就称为预处理（即预先处理、 提前处理）</li>
<li>预处理主要是处理以#开头的命令， 例如#include &lt;stdio.h&gt;等。 预处理命令要放在所有函数之外， 而且一般都放在源文件的前面。</li>
<li>预处理是 C 语言的一个重要功能，由预处理程序完成。当对一个源文件进行编译时，系统将自动调用预处理程序对源程序中的预处理部分作处理， 处理完毕自动进入对源程序的编译。</li>
<li>C 语言提供了多种预处理功能，如宏定义、文件包含、条件编译等，合理地使用它们会使编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。</li>
</ul>
<h2 id="9-1-预处理命令快速入门"><a href="#9-1-预处理命令快速入门" class="headerlink" title="9.1 预处理命令快速入门"></a>9.1 预处理命令快速入门</h2><ul>
<li>要求<ul>
<li>开发一个 C 语言程序，让它暂停 5 秒以后再输出内容 “helllo, 尚硅谷!~”，并且要求跨平台，在 Windows 和Linux 下都能运行，如何处理。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Windows 平台下的暂停函数的原型是 void Sleep(DWORD dwMilliseconds)，参数的单位是“ 毫秒” ，位于 &lt;windows.h&gt; 头文件。 </p>
<p>Linux 平台下暂停函数的原型是 unsigned int sleep (unsigned int seconds)， 参数的单位是“秒” ， 位于 &lt;unistd.h&gt; 头文件。</p>
<p>#if、 #elif、 #endif 就是预处理命令， 它们都是在编译之前由预处理程序来执行的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> _WIN32 <span class="comment">//如果是 windows 平台, 就执行 #include &lt;windows.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__ <span class="comment">//否则判断是不是 linux ,如果是 linux 就引入&lt;unistd.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 不同的平台下调用不同的函数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> _WIN32  <span class="comment">// 识别 windows 平台</span></span></span><br><span class="line">        Sleep(<span class="number">5000</span>); <span class="comment">//毫秒</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> __linux__ <span class="comment">//识别 linux 平台</span></span></span><br><span class="line">        sleep(<span class="number">5</span>); <span class="comment">//秒</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello, world~&quot;</span>); <span class="comment">//输出</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-C-语言宏定义"><a href="#9-2-C-语言宏定义" class="headerlink" title="9.2 C 语言宏定义"></a>9.2 C 语言宏定义</h2><ul>
<li><p>基本介绍</p>
</li>
<li><p><code>#define</code> 叫做宏定义命令，它也是 C 语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。</p>
</li>
<li><p>宏定义的形式</p>
<ul>
<li><code>#define 宏名 字符串</code></li>
<li>#表示这是一条预处理命令，所有的预处理命令都以 # 开头。宏名是标识符的一种，命名规则和变量相同。字符串可以是数字、表达式、if 语句、函数等。</li>
<li>这里所说的字符串是一般意义上的字符序列，不要和 C 语言中的字符串等同，它不需要双引号。</li>
<li>程序中反复使用的表达式就可以使用宏定义。</li>
</ul>
</li>
<li><p>注意细节</p>
<ol>
<li><p>宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单的替换。字符串中可以含任何字符，它可以是常数、表达式、if 语句、函数等，预处理程序对它不作任何检查， 如有错误，只能在编译已被宏展开后的源程序时发现。</p>
</li>
<li><p>宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。</p>
</li>
<li><p>宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef 命令。</p>
</li>
<li><p>代码中的宏名如果被引号包围， 那么预处理程序不对其作宏代替。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 100</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OK \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。</p>
</li>
<li><p>习惯上宏名用大写字母表示， 以便于与变量区别。 但也允许用小写字母。</p>
</li>
<li><p>可用宏定义表示数据类型， 使书写方便。</p>
</li>
<li><p><strong>宏定义表示数据类型</strong>和用 <strong>typedef 定义数据说明符</strong>的区别：<strong>宏定义只是简单的字符串替换，由预处理器来处理</strong>；而 <strong>typedef 是在编译阶段由编译器处理的</strong>， 它并不是简单的字符串替换， 而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。</p>
</li>
</ol>
</li>
</ul>
<h2 id="9-3-带参数的宏定义"><a href="#9-3-带参数的宏定义" class="headerlink" title="9.3 带参数的宏定义"></a>9.3 带参数的宏定义</h2><ul>
<li>C 语言允许宏带有参数。在宏定义中的参数称为“形式参数” ，在宏调用中的参数称为“实际参数” ，这点和<br>函数有些类似。</li>
<li>对带参数的宏， 在展开过程中不仅要进行字符串替换， 还要用实参去替换形参。</li>
<li>带参宏定义的一般形式为 #define 宏名(形参列表) 字符串 ,在字符串中可以含有各个形参。</li>
<li>带参宏调用的一般形式为 : <code>宏名(实参列表)</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. MAX 就是带参数的宏</span></span><br><span class="line"><span class="comment">// 2. (a,b) 就是形参</span></span><br><span class="line"><span class="comment">// 3. (a&gt;b) ? a : b 是带参数的宏对应字符串， 该字符串中可以使用形参</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) (a&gt;b) ? a : b</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x , y, max;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input two numbers: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. MAX(x, y); 调用带参数宏定义</span></span><br><span class="line">    <span class="comment">// 2. 在宏替换时(预处理， 由预处理器)， 会进行字符串的替换， 同时会使用实参， 去替换形参</span></span><br><span class="line">    <span class="comment">// 3. 即 MAX(x, y) 宏替换后 (x&gt;y) ? x : y</span></span><br><span class="line">    max = MAX(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：input two numbers: max=<span class="number">32764</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用细节</p>
<ol>
<li><p>带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现。</p>
<p><code>#define MAX(a,b) (a&gt;b)?a:b</code> 如果写成了<code>#define MAX (a, b) (a&gt;b)?a:b</code>  </p>
</li>
<li><p>在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。</p>
</li>
<li><p>在宏定义中，字符串内的形参通常要用括号括起来以避免出错。</p>
<p><code>#define SQ(y) (y)*(y)</code> &#x2F;&#x2F; 带参宏定义,字符串内的形参通常要用括号括起来以避免出错</p>
</li>
</ol>
</li>
</ul>
<h2 id="9-4-带参宏定义和函数的区别"><a href="#9-4-带参宏定义和函数的区别" class="headerlink" title="9.4 带参宏定义和函数的区别"></a>9.4 带参宏定义和函数的区别</h2><ol>
<li>宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。</li>
<li>函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。</li>
</ol>
<h2 id="9-5-预处理命令总结"><a href="#9-5-预处理命令总结" class="headerlink" title="9.5 预处理命令总结"></a>9.5 预处理命令总结</h2><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#</td>
<td align="center">空指令， 无任何效果</td>
</tr>
<tr>
<td align="center">#include</td>
<td align="center">包含一个源代码文件</td>
</tr>
<tr>
<td align="center">#define</td>
<td align="center">定义宏</td>
</tr>
<tr>
<td align="center">#undef</td>
<td align="center">取消已定义的宏</td>
</tr>
<tr>
<td align="center">#if</td>
<td align="center">如果给定条件为真， 则编译下面代码</td>
</tr>
<tr>
<td align="center">#ifdef</td>
<td align="center">如果宏已经定义， 则编译下面代码</td>
</tr>
<tr>
<td align="center">#ifndef</td>
<td align="center">如果宏没有定义， 则编译下面代码</td>
</tr>
<tr>
<td align="center">#elif</td>
<td align="center">如果前面的#if 给定条件不为真， 当前条件 为真， 则编译下面代码</td>
</tr>
<tr>
<td align="center">#endif</td>
<td align="center">结束一个#if……#else 条件编译块</td>
</tr>
</tbody></table>
<ul>
<li>注意事项<ol>
<li>预处理功能是 C 语言特有的功能， 它是在对源程序正式编译前由预处理程序完成的， 程序员在程序中用预处理命令来调用这些功能。</li>
<li>宏定义可以带有参数，宏调用时是以实参代换形参，而不是“值传送” 。</li>
<li>为了避免宏代换时发生错误，宏定义中的字符串应加括号，字符串中出现的形式参数两边也应加括号。</li>
<li>文件包含是预处理的一个重要功能，它可用来把多个源文件连接成一个源文件进行编译，结果将生成一个目标文件。</li>
<li>条件编译允许只编译源程序中满足条件的程序段，使生成的目标程序较短，从而减少了内存的开销并提高了程序的效率。</li>
<li>使用预处理功能便于程序的修改、阅读、移植和调试，也便于实现模块化程序设计</li>
</ol>
</li>
</ul>
<h1 id="10-数组"><a href="#10-数组" class="headerlink" title="10. 数组"></a>10. 数组</h1><p><strong>数组可以存放多个同一类型数据</strong>。数组也是一种数据类型，是<strong>构造类型</strong>。传递是以<strong>引用的方式传递</strong>(即传递的是地址)</p>
<h2 id="10-1-数组定义"><a href="#10-1-数组定义" class="headerlink" title="10.1 数组定义"></a>10.1 数组定义</h2><ul>
<li><code>数据类型 数组名 [数组大小];</code> 如 <code>int a[5]</code>  赋初值 a[0] &#x3D; 1; a[1] &#x3D; 30;  </li>
<li>内存<ol>
<li><code>数组名</code> 就代表 <code>该数组的首地址</code>， 即 a[0]地址。</li>
<li><strong>数组的各个元素是连续分布的</strong><ol>
<li>假如 a[0] 地址 0x1122</li>
<li>a[1] 地址 &#x3D; a[0]的地址 + int 字节数(4) &#x3D; 0x1122 + 4 &#x3D;  0x1126</li>
<li>a[2] 地址 &#x3D; a[1]地址 + int 字节数(4) &#x3D; 0x1126 + 4 &#x3D; 0x112A</li>
</ol>
</li>
</ol>
</li>
<li>访问：数组名[下标]</li>
</ul>
<p><strong>三种初始化方式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 方式</span></span><br><span class="line">    <span class="type">int</span> arr1[<span class="number">3</span>];</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    arr1[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">    arr1[<span class="number">2</span>] = <span class="number">300</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    <span class="type">int</span> arr2[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式3</span></span><br><span class="line">    <span class="type">int</span> arr3[] = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr3) / <span class="keyword">sizeof</span>(<span class="type">int</span>); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr3[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用细节<ol>
<li>数组是多个相同类型数据的组合，一个数组一旦声明&#x2F;定义了，其<strong>长度是固定的</strong>，不能动态变化。</li>
<li>数组创建后，如果没有赋值，则遵守如下规则。<ol>
<li>全局数组默认值 0</li>
<li>非全局数组初值是机器垃圾值(即： 原来系统分配给这块空间的值)</li>
</ol>
</li>
<li>使用数组的步骤 1. 定义数组 2 给数组各个元素赋值 3 使用数组, 也可以一步到位</li>
<li>C 的数组属构造类型，是引用传递(传递的是地址)，因此当把一个数组传递给一个函数时&#x2F;或者变量，函数&#x2F;变量操作数组会影响到原数组。</li>
</ol>
</li>
</ul>
<h2 id="10-2-字符数组与字符串"><a href="#10-2-字符数组与字符串" class="headerlink" title="10.2 字符数组与字符串"></a>10.2 字符数组与字符串</h2><p>用来存放字符的数组称为字符数组。</p>
<ol>
<li><code>char a[10]; </code>  &#x2F;&#x2F;  一维字符数组, 长度为 10</li>
<li><code>char b[5][10]</code>;   &#x2F;&#x2F;  二维字符数组</li>
<li><code>char c[20]=&#123;&#39;c&#39;, &#39; &#39;, &#39;p&#39;, &#39;r&#39;, &#39;o&#39;, &#39;g&#39;, &#39;r&#39;, &#39;a&#39;,&#39;m&#39;&#125;;</code>  &#x2F;&#x2F;  给部分数组元素赋值</li>
</ol>
<p>字符数组实际上是一系列字符的集合，也就是字符串（String）。在 C 语言中，没有专门的字符串变量，没有string 类型，通常就用一个字符数组来存放一个字符串。</p>
<blockquote>
<p>在 C 语言中，字符串实际上是使用 null 字符 (‘\0’) 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>‘\0’ 是 ASCII 码表中的第 0 个字符，用 NUL 表示，称为空字符。该字符既不能显示，也不是控制字符，输出该字符不会有任何效果，它在 C 语言中仅作为字符串的结束标志。</p>
</blockquote>
<p>如果在给某个字符数组赋值时，</p>
<ol>
<li>赋给的元素的个数小于该数组的长度，则会自动在后面加 ‘\0’，表示字符串结束。</li>
<li>赋给的元素的个数等于该数组的长度，则不会自动添加 ‘\0’</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// c 是一个一维字符数组， 给部分元素赋值</span></span><br><span class="line">    <span class="type">char</span> c[<span class="number">7</span>]=&#123;<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;m&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">4</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> str2[] = &#123;<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;k&#x27;</span>&#125;; <span class="comment">// 这个后面系统也不会自动添加 &#x27;\0&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出 c , 系统会这样处理</span></span><br><span class="line">    <span class="comment">//1. 从第一个字符开始输出， 直到遇到 \0 , 表示该字符串结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n c=%s&quot;</span>, c);  <span class="comment">// tom</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n str=%s&quot;</span>, str); <span class="comment">// abc（最后一个结束符不会输出）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n str2=%s&quot;</span>, str2); <span class="comment">// jack 乱码（乱码直到碰到结束符为止）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出： </span><br><span class="line">c=tom</span><br><span class="line">str=abd</span><br><span class="line">str2=jackabd</span><br></pre></td></tr></table></figure>

<ul>
<li><p>访问和遍历</p>
<ul>
<li><p>因为字符串的本质就是字符数组，因此可以按照数组的方式遍历和访问某个元素即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(greeting); <span class="comment">// len = 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n greeting=%s&quot;</span>, greeting);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n len=%d&quot;</span>, len); <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 字符串第 3 个字符是=%c&quot;</span>, greeting[<span class="number">2</span>]); <span class="comment">//l</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//遍历</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, greeting[i]); <span class="comment">//H e l l o</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出： greeting=Hello</span><br><span class="line">len=<span class="number">5</span></span><br><span class="line">字符串第 <span class="number">3</span> 个字符是=l</span><br><span class="line">H e l l o </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="10-3-字符串的表示形式"><a href="#10-3-字符串的表示形式" class="headerlink" title="10.3 字符串的表示形式"></a>10.3 字符串的表示形式</h2><ul>
<li><p>两种表示形式</p>
<ol>
<li>用字符数组存放一个字符串<ol>
<li><code>char str[] = &quot;hello tom&quot;;</code></li>
<li><code>char str2[] = &#123;&#39;h&#39;, &#39;e&#39;&#125;;</code></li>
</ol>
</li>
<li>用字符指针指向一个字符串<ol>
<li><code>char* pStr = &quot; hello tom&quot;;</code></li>
<li>C 语言对字符串常量” hello tom”是按字符数组处理的，在内存中开辟了一个字符数组用来存放字符串常量，程序在定义字符串指针变量 pStr 时只是把字符串首地址（即存放字符串的字符数组的首地址） 赋给 pStr。</li>
<li><code>printf(&quot;%s \n&quot;,pStr);</code> 可以输出 str 指向的字符串</li>
</ol>
</li>
</ol>
</li>
<li><p>区别</p>
<ol>
<li>字符数组由若干个元素组成，每个元素放一个字符；而字符指针变量中存放的是地址（字符串&#x2F;字符数组的首地址），绝不是将字符串放到字符指针变量中（是字符串首地址）</li>
<li>对字符数组只能对各个元素赋值，不能用<code>char str[14]; str=&quot;hello tom&quot;;</code>对字符数组赋值。</li>
<li>对字符指针变量，采用下面方法赋值，是可以的<code>char* a=&quot;yes&quot;; a=&quot; hello tom&quot;;</code></li>
<li>如果定义了一个字符数组，那么它有确定的内存地址(即字符数组名是一个常量)；而定义一个字符指针变量时，它并未指向某个确定的字符数据，并且可以多次赋值。</li>
</ol>
</li>
</ul>
<h2 id="10-4-字符串相关函数"><a href="#10-4-字符串相关函数" class="headerlink" title="10.4 字符串相关函数"></a>10.4 字符串相关函数</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>strcpy(s1, s2)</td>
<td>复制字符串S2到S1</td>
</tr>
<tr>
<td>strcat(s1, s2)</td>
<td>链接字符串S2到字符串S1的末尾</td>
</tr>
<tr>
<td>strlen(s1)</td>
<td>返回字符串S1的长度</td>
</tr>
<tr>
<td>strcmp(s1, s2)</td>
<td>如果S1和S2是相同的，则返回0，如果S1&lt;S2则返回小于0，如果S1&gt;S2返回大于0</td>
</tr>
<tr>
<td>strchr(s1, ch)</td>
<td>返回一个指针，指向字符串S1中字符ch第一次出现的位置</td>
</tr>
<tr>
<td>strstr(s1, s2)</td>
<td>返回一个指针，指向字符串S1中字符串S2第一次出现的位置</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">12</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">12</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">12</span>];</span><br><span class="line">    <span class="type">int</span> len ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 复制 str1 到 str3 */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str3, str1); <span class="comment">// str3 内容 &quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strcpy( str3, str1) : %s \n&quot;</span>, str3 ); <span class="comment">//&quot;Hello&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 连接 str1 和 str2 */</span></span><br><span class="line">    <span class="built_in">strcat</span>( str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strcat( str1, str2): %s\n&quot;</span>, str1 ); <span class="comment">//&quot;HelloWorld&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 连接后， str1 的总长度 */</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(str1);<span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen(str1) : %d\n&quot;</span>, len );<span class="comment">//10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：<span class="built_in">strcpy</span>( str3, str1) : Hello </span><br><span class="line"><span class="title function_">strcat</span><span class="params">( str1, str2)</span>: HelloWorld</span><br><span class="line"><span class="title function_">strlen</span><span class="params">(str1)</span> : 10</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用注意事项和细节</p>
<ol>
<li><p>程序中往往依靠检测 ‘\0’ 的位置来判定字符串是否结束，而不是根据数组的长度来决定字符串长度。 因此，字符串长度不会统计 ‘\0’, 字符数组长度会统计。</p>
</li>
<li><p>在定义字符数组时应估计实际字符串长度，保证数组长度始终大于字符串实际长度，否则，在输出字符数组时可能出现未知字符。</p>
</li>
<li><p>系统对字符串常量也自动加一个’\0’作为结束符。例如”C Program” 共有 9 个字符，但在内存中占 10 个字节，最后一个字节’\0’是系统自动加上的。 </p>
</li>
<li><p>定义字符数组时，如果给的字符个数比数组的长度小，则系统会默认将剩余的元素空间，全部设置为 ‘\0’, 比如 char str[6] &#x3D; “ab” , str 内存布局就是<code>[a][b][\0][\0][\0][\0]</code>。</p>
</li>
<li><p>字符数组定义和初始化的方式比较多</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[ ] = &#123;<span class="string">&quot;I am happy&quot;</span>&#125;; <span class="comment">// 默认后面加 &#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> str2[ ] = <span class="string">&quot;I am happy&quot;</span>; <span class="comment">// 省略&#123;&#125;号 ,默认后面加 &#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> str3[ ] = &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;y&#x27;</span>&#125;; <span class="comment">// 字符数组后面不会加 &#x27;\0&#x27;, 可能有乱码</span></span><br><span class="line"><span class="type">char</span> str4[<span class="number">5</span>] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;; <span class="comment">//字符数组后面不会加 &#x27;\0&#x27;, 可能有乱码</span></span><br><span class="line"><span class="type">char</span> * pStr = <span class="string">&quot;hello&quot;</span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="11-排序和查找"><a href="#11-排序和查找" class="headerlink" title="11. 排序和查找"></a>11. 排序和查找</h1><h2 id="11-1-冒泡排序"><a href="#11-1-冒泡排序" class="headerlink" title="11.1 冒泡排序"></a>11.1 冒泡排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> arrLen)</span> &#123;</span><br><span class="line">    <span class="comment">//因为每轮排序几乎一样， 因此， 我们可以使用 for 循环处理</span></span><br><span class="line">    <span class="type">int</span> j,i;</span><br><span class="line">    <span class="type">int</span> t;<span class="comment">//临时变量</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; arrLen - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; arrLen<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">        <span class="comment">//如果前面的数大于后面的数， 就交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            t = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">-1</span>, <span class="number">10</span>, <span class="number">-2</span>,<span class="number">-11</span>&#125; ;</span><br><span class="line">    <span class="type">int</span> arrLen = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">// 通过计算得到</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    bubbleSort(arr, arrLen); <span class="comment">// 数组默认是地址传递(指针)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 排序后(函数)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(j= <span class="number">0</span>; j &lt; arrLen; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-2-二分查找"><a href="#11-2-二分查找" class="headerlink" title="11.2 二分查找"></a>11.2 二分查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seqSearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> arrLen, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果在 for 循环中， 没有执行到 return ,说明没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 有一个数列： &#123;23， 1， 34,89， 101&#125;</span></span><br><span class="line">    <span class="comment">// 猜数游戏： 从键盘中任意输入一个数， 判断数列中是否包含该数【顺序查找】 要求: 如果找到了，</span></span><br><span class="line">    <span class="comment">// 就提示找到， 并给出下标值, 找不到提示 没有。</span></span><br><span class="line">    <span class="comment">// 分析思路</span></span><br><span class="line">    <span class="comment">// 1. 安装数组进行遍历， 一个一个的比较， 如果相等， 则找到</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">23</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">89</span>, <span class="number">101</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arrLen = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> index = seqSearch(arr, arrLen, <span class="number">101</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123; <span class="comment">//找到</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到 下标为 %d&quot;</span>, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-3-多维数组-二维数组"><a href="#11-3-多维数组-二维数组" class="headerlink" title="11.3 多维数组-二维数组"></a>11.3 多维数组-二维数组</h2><p><strong>使用方式1</strong></p>
<p><code>类型 数组名[大小][大小];</code>比如：比如: <code>int a[2][3]</code>;</p>
<p>二维数组在内存的存在形式，各个元素的地址是连续分布的，即在前一个元素基础上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>][<span class="number">6</span>]; <span class="comment">// 没有初始化， 则是分配的内存垃圾值</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="comment">//全部初始化 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">//先遍历行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;<span class="comment">//遍历列</span></span><br><span class="line">            a[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//看看二维数组的内存布局</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 二维数组 a 的首地址=%p&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 二维数组 a[0]的地址=%p&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 二维数组 a[0][0]的地址=%p&quot;</span>, &amp;a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 二维数组 a[0][1]的地址=%p&quot;</span>, &amp;a[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//将二维数组的各个元素得地址输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]的地址=%p &quot;</span>, i, a[i]);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]的地址=%p &quot;</span>, i, j , &amp;a[i][j]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出： 二维数组 a 的首地址=<span class="number">0x7ffdc984fb40</span></span><br><span class="line"> 二维数组 a[<span class="number">0</span>]的地址=<span class="number">0x7ffdc984fb40</span></span><br><span class="line"> 二维数组 a[<span class="number">0</span>][<span class="number">0</span>]的地址=<span class="number">0x7ffdc984fb40</span></span><br><span class="line"> 二维数组 a[<span class="number">0</span>][<span class="number">1</span>]的地址=<span class="number">0x7ffdc984fb44</span></span><br><span class="line">a[<span class="number">0</span>]的地址=<span class="number">0x7ffdc984fb40</span> a[<span class="number">0</span>][<span class="number">0</span>]的地址=<span class="number">0x7ffdc984fb40</span> a[<span class="number">0</span>][<span class="number">1</span>]的地址=<span class="number">0x7ffdc984fb44</span> a[<span class="number">0</span>][<span class="number">2</span>]的地址=<span class="number">0x7ffdc984fb48</span> a[<span class="number">0</span>][<span class="number">3</span>]的地址=<span class="number">0x7ffdc984fb4c</span> a[<span class="number">0</span>][<span class="number">4</span>]的地址=<span class="number">0x7ffdc984fb50</span> a[<span class="number">0</span>][<span class="number">5</span>]的地址=<span class="number">0x7ffdc984fb54</span> </span><br><span class="line">a[<span class="number">1</span>]的地址=<span class="number">0x7ffdc984fb58</span> a[<span class="number">1</span>][<span class="number">0</span>]的地址=<span class="number">0x7ffdc984fb58</span> a[<span class="number">1</span>][<span class="number">1</span>]的地址=<span class="number">0x7ffdc984fb5c</span> a[<span class="number">1</span>][<span class="number">2</span>]的地址=<span class="number">0x7ffdc984fb60</span> a[<span class="number">1</span>][<span class="number">3</span>]的地址=<span class="number">0x7ffdc984fb64</span> a[<span class="number">1</span>][<span class="number">4</span>]的地址=<span class="number">0x7ffdc984fb68</span> a[<span class="number">1</span>][<span class="number">5</span>]的地址=<span class="number">0x7ffdc984fb6c</span> </span><br><span class="line">a[<span class="number">2</span>]的地址=<span class="number">0x7ffdc984fb70</span> a[<span class="number">2</span>][<span class="number">0</span>]的地址=<span class="number">0x7ffdc984fb70</span> a[<span class="number">2</span>][<span class="number">1</span>]的地址=<span class="number">0x7ffdc984fb74</span> a[<span class="number">2</span>][<span class="number">2</span>]的地址=<span class="number">0x7ffdc984fb78</span> a[<span class="number">2</span>][<span class="number">3</span>]的地址=<span class="number">0x7ffdc984fb7c</span> a[<span class="number">2</span>][<span class="number">4</span>]的地址=<span class="number">0x7ffdc984fb80</span> a[<span class="number">2</span>][<span class="number">5</span>]的地址=<span class="number">0x7ffdc984fb84</span> </span><br><span class="line">a[<span class="number">3</span>]的地址=<span class="number">0x7ffdc984fb88</span> a[<span class="number">3</span>][<span class="number">0</span>]的地址=<span class="number">0x7ffdc984fb88</span> a[<span class="number">3</span>][<span class="number">1</span>]的地址=<span class="number">0x7ffdc984fb8c</span> a[<span class="number">3</span>][<span class="number">2</span>]的地址=<span class="number">0x7ffdc984fb90</span> a[<span class="number">3</span>][<span class="number">3</span>]的地址=<span class="number">0x7ffdc984fb94</span> a[<span class="number">3</span>][<span class="number">4</span>]的地址=<span class="number">0x7ffdc984fb98</span> a[<span class="number">3</span>][<span class="number">5</span>]的地址=<span class="number">0x7ffdc984fb9c</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用方式2</strong></p>
<p><code>类型 数组名[大小][大小] = &#123;&#123;值 1,值 2..&#125;,&#123;值 1,值 2..&#125;,&#123;值 1,值 2..&#125;&#125;;  </code></p>
<p><code>类型 数组名[大小][大小] = &#123; 值 1,值 2,值 3,值 4,值 5,值 6 ..&#125;;  </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="comment">// 先得到行</span></span><br><span class="line">    <span class="comment">// 1. sizeof(map) 得到这个 map 数组的大小 9 * 4 = 36</span></span><br><span class="line">    <span class="comment">// 2. sizeof(map[0]) 得到 map 中， 第一行有多大 3 * 4 = 12</span></span><br><span class="line">    <span class="type">int</span> rows = <span class="keyword">sizeof</span>(<span class="built_in">map</span>) / <span class="keyword">sizeof</span>(<span class="built_in">map</span>[<span class="number">0</span>]); <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 得到列</span></span><br><span class="line">    <span class="type">int</span> cols = <span class="keyword">sizeof</span>(<span class="built_in">map</span>[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">// 12 / 4 = 3</span></span><br><span class="line">    <span class="type">int</span> i,j, sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">map</span>[i][j]);</span><br><span class="line">            sum += <span class="built_in">map</span>[i][j];  <span class="comment">//累计到 sum</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n sum=%d&quot;</span>, sum);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用细节<ol>
<li>可以只对部分元素赋值，未赋值的元素自动取“零” 值。</li>
<li>如果对全部元素赋值，那么第一维的长度可以不给出。</li>
<li>二维数组可以看作是由一维数组嵌套而成的；如果一个数组的每个元素又是一个数组，那么它就是二维数组。</li>
</ol>
</li>
</ul>
<h1 id="12-指针"><a href="#12-指针" class="headerlink" title="12. 指针"></a>12. 指针</h1><ol>
<li><p>指针，也就是内存的地址；所谓指针变量，也就是保存了内存地址的变量。</p>
</li>
<li><p>获取变量的地址，用&amp;，比如：int num &#x3D; 10，获取 num 的地址：&amp;num。</p>
</li>
<li><p>指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值。</p>
<p>比如：<code>int *ptr = &amp;num;</code> ptr 就是指向 int 类型的指针变量，即 ptr 是 int * 类型。</p>
</li>
<li><p>获取指针类型所指向的值，使用：*(取值符号)，比如：int * ptr，使用 *ptr 获取 ptr 指向的值。</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int <span class="emphasis">*ip;   一个整型的指针 </span></span><br><span class="line"><span class="emphasis">double *</span>dp; 一个 double 型的指针</span><br><span class="line">float <span class="emphasis">*fp;  一个浮点型的指针</span></span><br><span class="line"><span class="emphasis">char *</span>ch; 一个字符型的指针 </span><br></pre></td></tr></table></figure>

<h2 id="12-1-指针的算术运算"><a href="#12-1-指针的算术运算" class="headerlink" title="12.1 指针的算术运算"></a>12.1 指针的算术运算</h2><p>指针是一个用数值表示的地址。可以对指针执行算术运算。可以对指针进行四种算术运算：++、 –、 +、 -。</p>
<p>当对指针进行++时，指针会按照它指向的数据类型字节数大小增加，比如 int * 指针，每++ ，就增加 4 个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>; <span class="comment">// 常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;; <span class="comment">// int 数组</span></span><br><span class="line">    <span class="type">int</span> i, *ptr; <span class="comment">// ptr 是一个 int* 指针</span></span><br><span class="line">    ptr = var; <span class="comment">// ptr 指向了 var 数组的首地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;var[%d] 地址= %p \n&quot;</span>, i, ptr );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;存储值： var[%d] = %d\n&quot;</span>, i, *ptr );</span><br><span class="line">        ptr++;<span class="comment">// ptr = ptr + 1(1 个 int 字节数); ptr 存放值+4 字节(int)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：var[<span class="number">0</span>] 地址= <span class="number">0x7fff2cdffde4</span> </span><br><span class="line">存储值： var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">var[<span class="number">1</span>] 地址= <span class="number">0x7fff2cdffde8</span> </span><br><span class="line">存储值： var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">var[<span class="number">2</span>] 地址= <span class="number">0x7fff2cdffdec</span> </span><br><span class="line">存储值： var[<span class="number">2</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指针中最后一个元素的地址 */</span></span><br><span class="line">ptr = &amp;var[MAX<span class="number">-1</span>]; <span class="comment">// &amp;var[2]</span></span><br><span class="line">ptr--;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是 ptr +&#x3D; 2；那就是一次增加8个字节（2个int类型的空间）。减法同理。</p>
</blockquote>
<h2 id="12-2-指针的比较"><a href="#12-2-指针的比较" class="headerlink" title="12.2 指针的比较"></a>12.2 指针的比较</h2><p>指针可以用关系运算符进行比较，如 &#x3D;&#x3D;、 &lt;、&lt;&#x3D;  和 &gt;、&gt;&#x3D;。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    ptr = var; <span class="comment">// ptr 指向 var 首地址(第一个元素)</span></span><br><span class="line">    <span class="comment">// if(ptr == var[0]) &#123;//错误,类型不一样 (int *) 和 (int )</span></span><br><span class="line">    <span class="comment">//     printf(&quot;ok1&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span>(ptr == &amp;var[<span class="number">0</span>]) &#123; <span class="comment">// 可以</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n ok2&quot;</span>); <span class="comment">//输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ptr == var) &#123; <span class="comment">//可以</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n ok3&quot;</span>); <span class="comment">//输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ptr &gt;= &amp;var[<span class="number">1</span>]) &#123; <span class="comment">//可以比较,但是返回 false</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n ok4&quot;</span>); <span class="comment">//不会输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实就是说 地址也是可以用来比较的。</p>
</blockquote>
<h2 id="12-3-指针数组"><a href="#12-3-指针数组" class="headerlink" title="12.3 指针数组"></a>12.3 指针数组</h2><p>要让数组的元素 指向 int 或其他数据类型的地址(指针)。可以使用指针数组。</p>
<p><code>数据类型 *指针数组名[大小];</code> 比如：int *ptr[3];   ptr 声明为一个指针数组。</p>
<p>由 3 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个指针数组， 该数组的每个元素， 指向的是一个字符串</span></span><br><span class="line">    <span class="type">char</span> *books[] = &#123;</span><br><span class="line">                    <span class="string">&quot;三国演义&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;西游记&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;红楼梦&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;水浒传&quot;</span></span><br><span class="line">                    &#125;;</span><br><span class="line">    <span class="type">char</span> * pStr = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="type">int</span> i, len = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nbooks[%d] 指向字符串是=%s pStr 指向的内容=%s&quot;</span>, i, books[i], pStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：books[<span class="number">0</span>] 指向字符串是=三国演义 pStr 指向的内容=abc</span><br><span class="line">books[<span class="number">1</span>] 指向字符串是=西游记 pStr 指向的内容=abc</span><br><span class="line">books[<span class="number">2</span>] 指向字符串是=红楼梦 pStr 指向的内容=abc</span><br><span class="line">books[<span class="number">3</span>] 指向字符串是=水浒传 pStr 指向的内容=abc</span><br></pre></td></tr></table></figure>

<h2 id="12-4-指向指针的指针"><a href="#12-4-指向指针的指针" class="headerlink" title="12.4 指向指针的指针"></a>12.4 指向指针的指针</h2><p>又叫<code>多重指针</code></p>
<p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。</p>
<p>当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p>
<p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。</p>
<p> <code>int **ptr; // ptr 的类型是 int **  </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="type">int</span> *ptr; <span class="comment">//一级指针</span></span><br><span class="line">    <span class="type">int</span> **pptr; <span class="comment">//二级指针</span></span><br><span class="line">    <span class="type">int</span> ***ppptr; <span class="comment">// 三级指针</span></span><br><span class="line">    var = <span class="number">3000</span>;</span><br><span class="line">    ptr = &amp;var; <span class="comment">// var 变量的地址赋给 ptr</span></span><br><span class="line">    pptr = &amp;ptr;<span class="comment">// 表示将 ptr 存放的地址， 赋给 pptr</span></span><br><span class="line">    ppptr = &amp;pptr; <span class="comment">// 表示将 pptr 存放的地址， 赋给 ppptr</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var 的地址=%p var = %d \n&quot;</span>, &amp;var, var );<span class="comment">// 0x1133 3000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr 的本身的地址=%p ptr 存放的地址=%p *ptr = %d \n&quot;</span>, &amp;ptr, ptr, *ptr );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pptr 本身地址 = %p pptr 存放的地址=%p **pptr = %d\n&quot;</span>, &amp;pptr, pptr, **pptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ppptr 本身地址 = %p ppptr 存放的地址=%p ***pptr = %d\n&quot;</span>, &amp;ppptr, ppptr, ***ppptr);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-5-传递指针-地址-给函数"><a href="#12-5-传递指针-地址-给函数" class="headerlink" title="12.5 传递指针(地址)给函数"></a>12.5 传递指针(地址)给函数</h2><p>当函数的形参类型是指针类型时，是使用该函数时，需要传递指针，或者地址，或者数组给该形参。</p>
<h2 id="12-6-传数组给指针变量"><a href="#12-6-传数组给指针变量" class="headerlink" title="12.6 传数组给指针变量"></a>12.6 传数组给指针变量</h2><p>数组名本身就代表该数组首地址，因此传数组的本质就是传地址。</p>
<h2 id="12-7-指针函数"><a href="#12-7-指针函数" class="headerlink" title="12.7 指针函数"></a>12.7 指针函数</h2><p>返回指针的函数</p>
<p>C 语言 允许函数的返回值是一个指针（地址），这样的函数称为指针函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请编写一个函数 strlong()， 返回两个字符串中较长的一个。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strlong</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2)</span>&#123; <span class="comment">// 函数返回的 char * (指针)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nstr1 的长度%d str2 的长度%d&quot;</span>, <span class="built_in">strlen</span>(str1), <span class="built_in">strlen</span>(str2));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(str1) &gt;= <span class="built_in">strlen</span>(str2))&#123;</span><br><span class="line">        <span class="keyword">return</span> str1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">30</span>], str2[<span class="number">30</span>], *str; <span class="comment">// str 是一个指针类型， 指向一个字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 请输入第 1 个字符串&quot;</span>);</span><br><span class="line">    gets(str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 请输入第 2 个字符串&quot;</span>);</span><br><span class="line">    gets(str2);</span><br><span class="line">    str = strlong(str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nLonger string: %s \n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输入：aaa bbbb</span><br><span class="line"></span><br><span class="line">标准输出： </span><br><span class="line">请输入第 <span class="number">1</span> 个字符串</span><br><span class="line">请输入第 <span class="number">2</span> 个字符串</span><br><span class="line">str1 的长度<span class="number">3</span> str2 的长度<span class="number">4</span></span><br><span class="line">Longer <span class="built_in">string</span>: bbbb </span><br></pre></td></tr></table></figure>

<ul>
<li><p>指针函数注意事项和细节</p>
<ol>
<li>用指针作为函数返回值时需要注意，<strong>函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数</strong>，函数返回的指针不能指向这些数据。</li>
<li>函数运行结束后会销毁该函数所有的局部数据，这里所谓的销毁并不是将局部数据所占用的内存全部清零，而是程序放弃对它的使用权限，后面的代码可以使用这块内存。</li>
<li><strong>C 语言不支持在调用函数时返回局部变量的地址， 如果确实有这样的需求， 需要定义局部变量为 static 变量</strong>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// int n = 100; //局部变量, 在 func 返回时，就会销毁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n = <span class="number">100</span>; <span class="comment">// 如果这个局部变量是 static 性质的，那么n存放数据的空间在静态数据区</span></span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = func(); <span class="comment">//func 返回指针</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;okoook~~&quot;</span>); <span class="comment">//可能是使用到 局部变量 int n = 100 占用空间</span></span><br><span class="line">    n = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n value = %d\n&quot;</span>, n);<span class="comment">// 思考，是否能够输出 100? 不一定</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="12-8-函数指针"><a href="#12-8-函数指针" class="headerlink" title="12.8 函数指针"></a>12.8 函数指针</h2><p>就是：指向函数的指针</p>
<ol>
<li>一个函数总是占用一段连续的内存区域， 函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。</li>
<li><strong>把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域</strong>，然后通过指针变量就可以找到并调用该函数。这种<strong>指针就是函数指针</strong>。</li>
</ol>
<ul>
<li>定义<code>returnType (*pointerName)(param list);</code><ol>
<li>returnType 为函数指针指向的函数返回值类型</li>
<li>pointerName 为函数指针名称</li>
<li>param list 为函数指针指向的函数的参数列表</li>
<li>参数列表中可以同时给出参数的类型和名称， 也可以只给出参数的类型， 省略参数的名称</li>
<li>注意( )的优先级高于*，第一个括号不能省略，如果写作 returnType *pointerName(param list);就成了函数原型，它表明函数的返回值类型为 returnType *</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用函数指针来实现对函数的调用, 返回两个整数中的最大值.</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. max 函数</span></span><br><span class="line"><span class="comment">// 2. 接收两个 int ,返回较大数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, maxVal;</span><br><span class="line">    <span class="comment">// 说明 函数指针</span></span><br><span class="line">    <span class="comment">// 1. 函数指针的名字 pmax</span></span><br><span class="line">    <span class="comment">// 2. int 表示 该函数指针指向的函数是返回 int 类型</span></span><br><span class="line">    <span class="comment">// 3. (int, int) 表示 该函数指针指向的函数形参是接收两个 int</span></span><br><span class="line">    <span class="comment">// 4. 在定义函数指针时， 也可以写上形参名 int (*pmax)(int x, int y) = max;</span></span><br><span class="line">    <span class="type">int</span> (*pmax)(<span class="type">int</span> , <span class="type">int</span>) = max; <span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="comment">// (*pmax)(x, y) 通过函数指针去调用 函数 max</span></span><br><span class="line">    maxVal = (*pmax)(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max value: %d pmax=%p pmax 本身的地址=%p\n&quot;</span>, maxVal, pmax, &amp;pmax);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-9-回调函数"><a href="#12-9-回调函数" class="headerlink" title="12.9 回调函数"></a>12.9 回调函数</h2><ol>
<li>函数指针变量可以作为某个函数的参数来使用的， 回调函数就是一个通过函数指针调用的函数。</li>
<li>回调函数是由别人的函数执行时调用你传入的函数（通过函数指针完成）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用回调函数的方式， 给一个整型数组 int arr[10] 赋 10 个随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="comment">// 1. int (*f)(void)</span></span><br><span class="line"><span class="comment">// 2. f 就是 函数指针, 它可以接收的函数是 (返回 int ,没有形参的函数)</span></span><br><span class="line"><span class="comment">// 3. f 在这里被 initArray 调用， 充当了回调函数角色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initArray</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> arraySize, <span class="type">int</span> (*f)(<span class="type">void</span>))</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 循环 10</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;arraySize; i++) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = f(); <span class="comment">//通过 函数指针调用了 getNextRandomValue 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取随机值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNextRandomValue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rand(); <span class="comment">// rand 系统函数， 会返回一个随机整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> myarray[<span class="number">10</span>],i; <span class="comment">//定义一个数组和 int</span></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. 调用 initArray 函数</span></span><br><span class="line">    <span class="comment">// 2. 传入了一个函数名 getNextRandomValue (地址), 需要使用函数指针接收</span></span><br><span class="line">    initArray(myarray, <span class="number">10</span>, getNextRandomValue);</span><br><span class="line">    <span class="comment">// 输出赋值后的数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, myarray[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指针的注意事项和细节<ol>
<li>指针变量存放的是地址，从这个角度看指针的本质就是地址。</li>
<li>变量声明的时候，如果没有确切的地址赋值，为指针变量赋一个 NULL 值是好的编程习惯。</li>
<li>赋为 NULL 值的指针被称为空指针，NULL 指针是一个定义在标准库 &lt;stdio.h&gt; 中的值为零的常量 #define NULL 0</li>
</ol>
</li>
</ul>
<h2 id="12-10-动态内存分配"><a href="#12-10-动态内存分配" class="headerlink" title="12.10 动态内存分配"></a>12.10 动态内存分配</h2><ol>
<li>全局变量——内存中的静态存储区</li>
<li>非静态的局部变量——内存中的动态存储区——stack 栈</li>
<li>临时使用的数据—建立动态内存分配区域， 需要时随时开辟， 不需要时及时释放——heap 堆</li>
<li>根据需要向系统申请所需大小的空间，由于未在声明部分定义其为变量或者数组，不能通过变量名或者数组名来引用这些数据，只能通过指针来引用</li>
</ol>
<ul>
<li>相关函数  头文件 <code>#include &lt;stdlib.h&gt;</code> 声明了四个关于内存动态分配的函数<ul>
<li>函数原型 <code>void * malloc（usigned int size） // memory allocation</code><ul>
<li>作用——在内存的动态存储区(堆区)中分配一个长度为 size 的连续空间。</li>
<li>形参 size 的类型为无符号整型， 函数返回值是所分配区域的第一个字节的地址， 即此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</li>
<li>malloc(100); 开辟 100 字节的临时空间， 返回值为其第一个字节的地址</li>
</ul>
</li>
<li>函数原型<code>void *calloc（unsigned n,unsigned size）</code><ul>
<li>作用——在内存的动态存储区中分配 n 个长度为 size 的连续空间， 这个空间一般比较大， 足以保存一个数组。</li>
<li>用 calloc 函数可以为一维数组开辟动态存储空间，n 为数组元素个数，每个元素长度为 size.  </li>
<li>函数返回指向所分配域的起始位置的指针； 分配不成功， 返回 NULL。 </li>
<li>p &#x3D; calloc(50, 4); &#x2F;&#x2F;开辟 50*4 个字节临时空间， 把起始地址分配给指针变量 p</li>
</ul>
</li>
<li>函数原型： <code>void free（void *p）</code><ul>
<li>作用——释放变量 p 所指向的动态空间， 使这部分空间能重新被其他变量使用。 </li>
<li>p 是最近一次调用 calloc 或 malloc 函数时的函数返回值</li>
<li>free 函数无返回值  </li>
<li>free(p); &#x2F;&#x2F; 释放 p 所指向的已分配的动态空间</li>
</ul>
</li>
<li>函数原型：<code>void *realloc（void *p，unsigned int size)</code>  <ul>
<li>作用——重新分配 malloc 或 calloc 函数获得的动态空间大小，将 p 指向的动态空间大小改变为 size，p 的值不变，分配失败返回 NULL</li>
<li>realloc(p, 50); &#x2F;&#x2F; 将 p 所指向的已分配的动态空间 改为 50 字节</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> *)</span>;</span><br><span class="line">    <span class="type">int</span> * p,i;</span><br><span class="line">    <span class="comment">// 在堆区开辟一个 5 * 4 的空间， 并将地址 (void *） ， 转成 (int *) , 赋给 p</span></span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p + i);</span><br><span class="line">    &#125; </span><br><span class="line">    check(p);</span><br><span class="line">    <span class="comment">// free(p); //销毁 堆区 p 指向的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 不及格的成绩 有: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] &lt; <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d &quot;</span>, p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态分配内存的基本原则<ol>
<li>避免分配大量的小内存块。分配堆上的内存有一些系统开销，所以分配许多小的内存块比分配几个大内存块的系统开销大。</li>
<li>仅在需要时分配内存。 只要使用完堆上的内存块， 就需要及时释放它(如果使用动态分配内存， 需要遵守原则：谁分配， 谁释放)， 否则可能出现内存泄漏。</li>
<li>总是确保释放以分配的内存。在编写分配内存的代码时，就要确定在代码的什么地方释放内存。</li>
<li>在释放内存之前， 确保不会无意中覆盖堆上已分配的内存地址， 否则程序就会出现内存泄漏。</li>
</ol>
</li>
</ul>
<h1 id="13-结构体和共用体"><a href="#13-结构体和共用体" class="headerlink" title="13. 结构体和共用体"></a>13. 结构体和共用体</h1><h2 id="13-1-结构体"><a href="#13-1-结构体" class="headerlink" title="13.1 结构体"></a>13.1 结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    张老太养了两只猫猫:一只名字叫小白,今年 3 岁,白色。 还有一只叫小花,今年 100 岁,花色。</span></span><br><span class="line"><span class="comment">    请编写一个程序， 当用户输入小猫的名字时， 就显示该猫的名字， 年龄， 颜色。</span></span><br><span class="line"><span class="comment">    如果用户输入的小猫名错误， 则显示 张老太没有这只猫猫。</span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment">    1. 猫猫有 三个成员(变量)组成</span></span><br><span class="line"><span class="comment">    2. 使用结构体解决</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 创建 结构体 Cat 【是数据类型】</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> &#123;</span> <span class="comment">// 结构体名 Cat, Cat 就是我们自己构造的一个数据类型</span></span><br><span class="line">        <span class="type">char</span> * name; <span class="comment">//名字， 使用指针， 指向一个字符串</span></span><br><span class="line">        <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">        <span class="type">char</span> *color; <span class="comment">//颜色</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 Cat 结构体， 创建变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> <span class="title">cat1</span>;</span> <span class="comment">// cat1 就是 struct Cat 的一个变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> <span class="title">cat2</span>;</span> <span class="comment">// cat2 就是 struct Cat 的一个变量</span></span><br><span class="line">    <span class="comment">// 给 cat1 的各个成员赋值</span></span><br><span class="line">    cat1.name = <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">    cat1.age = <span class="number">3</span>;</span><br><span class="line">    cat1.color = <span class="string">&quot;白色&quot;</span>;</span><br><span class="line">    <span class="comment">//给 cat2 的各个成员赋值</span></span><br><span class="line">    cat2.name = <span class="string">&quot;小花&quot;</span>;</span><br><span class="line">    cat2.age = <span class="number">100</span>;</span><br><span class="line">    cat2.color = <span class="string">&quot;花色&quot;</span>;</span><br><span class="line">    <span class="comment">//输出两只猫的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 第 1 只猫 name=%s age=%d color=%s&quot;</span>, cat1.name, cat1.age, cat1.color);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n 第 2 只猫 name=%s age=%d color=%s&quot;</span>, cat2.name, cat2.age, cat2.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体和结构体变量的区别和联系<ol>
<li>结构体是自定义的数据类型， 表示的是一种数据类型.</li>
<li>结构体变量代表一个具体变量</li>
</ol>
</li>
</ul>
<blockquote>
<p>其实就是面向对象里面说的，类 和 对象之间的关系。</p>
</blockquote>
<ul>
<li><p>声明结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称 &#123;</span> <span class="comment">// 结构体名首字母大写， 比如 Cat, Person</span></span><br><span class="line">    成员列表;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在学习小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">    <span class="comment">//成员也可以是结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员</p>
<ul>
<li>成员是结构体的一个组成部分，一般是基本数据类型、也可以是数组、指针、结构体等。 </li>
<li>成员声明语法同变量，示例：数据类型 成员名; </li>
<li>字段的类型可以为：基本类型、数组或指针、结构体等。</li>
<li>在创建一个结构体变量后，需要给成员赋值，如果没有赋值就使用可能导致程序异常终止。</li>
<li>不同结构体变量的成员是独立，互不影响，一个结构体变量的成员更改，不影响另外一个。</li>
</ul>
</li>
</ul>
<p><strong>创建方式1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在学习小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu1</span>, <span class="title">stu2</span>;</span></span><br><span class="line"><span class="comment">// 定义了两个变量 stu1 和 stu2， 它们都是 Stu 类型， 都由 5 个成员组成</span></span><br><span class="line"><span class="comment">// 注意关键字 struct 不能少</span></span><br></pre></td></tr></table></figure>

<p><strong>创建方式2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在学习小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2;</span><br><span class="line"><span class="comment">// 在定义结构体 Stu 的同时， 创建了两个结构体变量 stu1 和 stu2</span></span><br></pre></td></tr></table></figure>

<p><strong>创建方式3</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果只需要 stu1、 stu2 两个变量， 后面不需要再使用结构体数据类型， </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">// 没有写 Stu</span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">//所在学习小组</span></span><br><span class="line">    <span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2;</span><br><span class="line">stu1.name = <span class="string">&quot;tom&quot;</span>; stu1.num = <span class="number">100</span>;....</span><br><span class="line"><span class="comment">// 1. 该结构体数据类型， 没有名, 匿名结构体</span></span><br><span class="line"><span class="comment">// 2. stu1 和 stu2 就是 该结构体的两个变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>成员获取和赋值</p>
<ul>
<li><p>获取：结构体变量名.成员名;  </p>
</li>
<li><p>赋值：</p>
<ol>
<li><p>struct Student stu3 &#x3D; {“林黛玉 2”, 12, 16, ‘A’, 100 }; </p>
</li>
<li><pre><code class="language-c">struct Student&#123;
    char *name; //姓名
    int num; //学号
    int age; //年龄
    char group; //所在小组
    float score; //成绩
&#125; stu1 = &#123;&quot;贾宝玉&quot;, 11, 18, &#39;B&#39;, 90.50&#125;, stu2 = &#123; &quot;林黛玉&quot;, 12, 16, &#39;A&#39;, 100 &#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. ~~~ c</span><br><span class="line">   struct Student stu4;</span><br><span class="line">   //stu4 = &#123;&quot;林黛玉 2&quot;, 12, 16, &#x27;A&#x27;, 100 &#125;; // 这样赋值不可以</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>常用操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">rt_base_t</span> pin;</span><br><span class="line">    <span class="type">rt_base_t</span> mode;</span><br><span class="line">&#125;<span class="type">stu_t</span>;</span><br><span class="line"><span class="comment">// 定义一个名字叫stu的结构体类型，然后又把这个类型重定义了个叫stu_t的类型。</span></span><br><span class="line"><span class="comment">// 后续创建结构体的时候，就只需要</span></span><br><span class="line"><span class="comment">// stu_t studentA; 就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Stu_t *stu_ptr;</span><br><span class="line"><span class="comment">// 重定义了个指针类型</span></span><br><span class="line"><span class="comment">// stu_ptr studentA_t;</span></span><br><span class="line"><span class="comment">// 效果等同于</span></span><br><span class="line"><span class="comment">// stu_t * studentA_t;</span></span><br></pre></td></tr></table></figure>

<h2 id="13-2-共用体"><a href="#13-2-共用体" class="headerlink" title="13.2 共用体"></a>13.2 共用体</h2><p>共用体（Union）属于构造类型，它可以包含多个类型不同的成员。和结构体非常类似，但是也有不同的地方。</p>
<p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名&#123;</span></span><br><span class="line">    成员列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125;a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">&#125;a, b, c;</span><br></pre></td></tr></table></figure>

<p>内存问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span> <span class="comment">// data 就是一个共用体(内存布局)， 包含三个成员, 共享数据空间, 该空间的大小以占用最大的成员为准</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">short</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>;</span>  <span class="comment">// 定义一个 共用体变量 a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(<span class="keyword">union</span> data) ); <span class="comment">// 4, 4</span></span><br><span class="line">    a.n = <span class="number">0x40</span>;	   <span class="comment">// 16 进制</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %c, %d \n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.ch = <span class="string">&#x27;9&#x27;</span>; <span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %c, %d \n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.m = <span class="number">0x2059</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %c, %d \n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    a.n = <span class="number">0x3E25AD54</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %c, %d \n&quot;</span>, a.n, a.ch, a.m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">标准输出：<span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="number">64</span>, @, <span class="number">64</span></span><br><span class="line"><span class="number">57</span>, <span class="number">9</span>, <span class="number">57</span></span><br><span class="line"><span class="number">8281</span>, Y, <span class="number">8281</span></span><br><span class="line"><span class="number">1042656596</span>, T, <span class="number">-21164</span></span><br></pre></td></tr></table></figure>

<p><img src="/2017/01/01/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/c/%E5%85%B1%E7%94%A8%E4%BD%93%E5%86%85%E5%AD%98.jpg" alt="共用体内存"></p>
<p>现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：请使用共用体编程完成。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Num</th>
<th>Sex</th>
<th>Profession</th>
<th>Score &#x2F; Course</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>111</td>
<td>女</td>
<td>学生</td>
<td>80.1</td>
</tr>
<tr>
<td>李四</td>
<td>222</td>
<td>男</td>
<td>老师</td>
<td>math</td>
</tr>
<tr>
<td>王五</td>
<td>333</td>
<td>女</td>
<td>老师</td>
<td>English</td>
</tr>
<tr>
<td>赵六</td>
<td>444</td>
<td>男</td>
<td>学生</td>
<td>60.1</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL 2 <span class="comment">//人员总数</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>]; <span class="comment">//name</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">//编号</span></span><br><span class="line">    <span class="type">char</span> sex;<span class="comment">//性别 f =&gt; 女 m=&gt;男</span></span><br><span class="line">    <span class="type">char</span> profession; <span class="comment">//职员 s=&gt;学生 t=&gt;老师</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">float</span> score;</span><br><span class="line">        <span class="type">char</span> course[<span class="number">20</span>];</span><br><span class="line">    &#125; sc; <span class="comment">// sc 是一个共用体变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">persons</span>[<span class="title">TOTAL</span>];</span>  <span class="comment">// 定义了一个结构体数组</span></span><br><span class="line">    <span class="comment">// 输入人员信息</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;TOTAL; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input info: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %c %c&quot;</span>, persons[i].name, &amp;(persons[i].num), &amp;(persons[i].sex), &amp;(persons[i].profession));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(persons[i].profession == <span class="string">&#x27;s&#x27;</span>)&#123; <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入该学生成绩:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;persons[i].sc.score);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果是老师</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;请输入该老师课程:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, persons[i].sc.course);</span><br><span class="line">        &#125; </span><br><span class="line">        fflush(<span class="built_in">stdin</span>);<span class="comment">//刷新</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 输出人员信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nName\t\tNum\tSex\tProfession\tScore / Course\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;TOTAL; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(persons[i].profession == <span class="string">&#x27;s&#x27;</span>)&#123; <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t\t%d\t%c\t%c\t\t%f\n&quot;</span>, persons[i].name, persons[i].num, persons[i].sex, persons[i].profession,</span><br><span class="line">            persons[i].sc.score);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果是老师</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t\t%d\t%c\t%c\t\t%s\n&quot;</span>, persons[i].name, persons[i].num, persons[i].sex, persons[i].profession,</span><br><span class="line">            persons[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-文件操作"><a href="#14-文件操作" class="headerlink" title="14. 文件操作"></a>14. 文件操作</h1><ul>
<li>文件在程序中是以流的形式来操作的。<ul>
<li>流： 数据在数据源(文件)和程序(内存)之间经历的路径</li>
<li>输入流： 数据从数据源(文件)到程序(内存)的路径</li>
<li>输出流： 数据从程序(内存)到数据源(文件)的路径</li>
</ul>
</li>
</ul>
<p>C 标准库 - stdio .h 该头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出, 在开发过程中，可以来查询.  </p>
<p>C 语言中的 I&#x2F;O (输入&#x2F;输出) 通常使用 printf() 和 scanf() 两个函数。 scanf() 函数用于从标准输入（键盘） 读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）</p>
<h2 id="14-1-getchar-putchar-函数"><a href="#14-1-getchar-putchar-函数" class="headerlink" title="14.1 getchar() &amp; putchar() 函数"></a>14.1 getchar() &amp; putchar() 函数</h2><ol>
<li>int getchar(void) 函数从屏幕读取下一个可用的字符， 并把它返回为一个整数。 这个函数在同一个时间内只会读取一个单一的字符。 您可以在循环内使用这个方法， 以便从屏幕上读取多个字符。 </li>
<li>int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。 这个函数在同一个时间内只会输出一个单一的字符。 您可以在循环内使用这个方法， 以便在屏幕上输出多个字符。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">    c = getchar( );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>( c );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-gets-puts-函数"><a href="#14-2-gets-puts-函数" class="headerlink" title="14.2 gets() &amp; puts() 函数"></a>14.2 gets() &amp; puts() 函数</h2><ol>
<li>char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区， 直到一个终止符或 EOF。</li>
<li>int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">    gets( str );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>( str );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-3-scanf-和-printf-函数"><a href="#14-3-scanf-和-printf-函数" class="headerlink" title="14.3 scanf() 和 printf() 函数"></a>14.3 scanf() 和 printf() 函数</h2><ol>
<li>int scanf(const char *format, …) 函数从标准输入流 stdin 读取输入， 并根据提供的 format 来浏览输入。</li>
<li>int printf(const char *format, …) 函数把输出写入到标准输出流 stdout ， 并根据提供的格式产生输出。  </li>
<li>format 可以是一个简单的常量字符串， 但是您可以分别指定 %s、 %d、 %c、 %f 等来输出或读取字符串、整数、字符或浮点数。 还有许多其他可用的格式选项， 可以根据需要使用。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 您输入一个文本并按下回车键时， 程序读取输入，</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: %s %d &quot;</span>, str, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-4-文件操作"><a href="#14-4-文件操作" class="headerlink" title="14.4 文件操作"></a>14.4 文件操作</h2><p><strong>打开文件</strong></p>
<p>使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件， 这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。  </p>
<p>FILE *fopen( const char * filename, const char * mode );  </p>
<ol>
<li>filename 是字符串， 用来命名文件， 访问模式 mode 的值可以是下列值中的一个  </li>
<li>如果处理的是二进制文件(图片， 视频..)， 则需使用下面的访问模式: “rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”,  “ab+”, “a+b” &#x2F;&#x2F;b :binary 二进制</li>
</ol>
<p><img src="/2017/01/01/01.%20%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/c/%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6.jpg" alt="读取文件"></p>
<p><strong>关闭文件</strong></p>
<p>关闭文件， 使用 fclose( ) 函数。int fclose( FILE *fp );  </p>
<ol>
<li>如果成功关闭文件， fclose( ) 函数返回零， 如果关闭文件时发生错误， 函数返回 EOF。 这个函数实际上， 会清空缓冲区中的数据， 关闭文件， 并释放用于该文件的所有内存。 EOF 是一个定义在头文件 stdio.h 中的常量。</li>
<li>C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。</li>
<li>使用完文件后(读， 写)， 一定要将该文件关闭。</li>
</ol>
<p><strong>写入文件</strong></p>
<p>下面是把字符写入到流中的函数  </p>
<p>int fputc( int c, FILE *fp );  </p>
<p>说明：函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。 如果写入成功， 它会返回写入的字符，如果发生错误， 则会返回 EOF。 您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：</p>
<p> int fputs( const char *s, FILE *fp );  </p>
<p>说明： 函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。 如果写入成功， 它会返回一个非负值， 如果发生错误， 则会返回 EOF。 您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个文件指针</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 打开该文件</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;d:/test100.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>); <span class="comment">// w+ 模式是 文件会被截断为零长度</span></span><br><span class="line">    <span class="comment">// fp = fopen(&quot;d:/test100.txt&quot;, &quot;a+&quot;); //w+ 模式是 文件会被截断为零长度</span></span><br><span class="line">    <span class="comment">// 将内容写入到文件中</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    fprintf(fp, &quot;你好 北京~~ \n&quot;);</span></span><br><span class="line"><span class="comment">    fputs(&quot;你好，上海~~ \n&quot;, fp);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//关闭文件!!!</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建， 写入信息完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>读取文件</strong></p>
<p>下面是从文件读取单个字符的函数</p>
<p>int fgetc( FILE * fp );  </p>
<p>说明： fgetc() 函数从 fp 所指向的输入文件中读取一个字符。 返回值是读取的字符， 如果发生错误则返回 EOF。  </p>
<p>下面的函数从流中读取一个字符串：</p>
<p>char *fgets( char *buf, int n, FILE *fp );  </p>
<ol>
<li>说明： 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。 它会把读取的字符串复制到缓冲区 buf， 并在最后追加一个 null 字符来终止字符串。 </li>
<li>如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF， 则只会返回读取到的字符，包括换行符。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个文件指针</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 定义一个缓冲区</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;d:/test200.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 方法 1</span></span><br><span class="line">    <span class="comment">// fscanf(fp, &quot;%s&quot;, buff);</span></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, buff);</span></span><br><span class="line">    <span class="comment">// 方法 2 读取整个文件</span></span><br><span class="line">    <span class="comment">// 说明， 循环读取 fp 指向的文件内容， 如果读到 NULL,就结束</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(buff, <span class="number">1024</span>,fp)!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











</article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文由 imhaozi 编写，采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2020/09/01/03.%20RTOS/rtthread_standard/">rtthread使用</a></div><div class="item" id="next"></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">imhaozi</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-C%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-text">1. C语言概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%89%B9%E7%82%B9"><span class="toc-text">1.1 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">1.2 运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text">1.3 转义字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%B3%A8%E9%87%8A"><span class="toc-text">1.4 注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-text">1.5 标准库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F"><span class="toc-text">2. 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%8F%98%E9%87%8F%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1 变量介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.2 数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.3 整数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.4 浮点类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.5 字符类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.6 布尔类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.7 基本类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.8 强制类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E6%8C%87%E9%92%88%E5%85%A5%E9%97%A8"><span class="toc-text">2.9 指针入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92"><span class="toc-text">2.10 值传递和地址传递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%B8%B8%E9%87%8F"><span class="toc-text">3. 常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B8%B8%E9%87%8F"><span class="toc-text">3.1 经常使用的常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">3.2 常量的定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4. 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.1 算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.2 关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.3 逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.4 赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.5 位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.6 三元运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">4.7 运算符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E8%A1%A8%E7%A4%BA%E7%AC%A6%E5%90%8D%E5%91%BD%E8%A7%84%E8%8C%83"><span class="toc-text">4.8 表示符名命规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">4.9 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.10 键盘输入语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">5. 二进制和位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%BF%9B%E5%88%B6"><span class="toc-text">5.1 进制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">5.2 位运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%A8%8B%E5%BA%8F%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">6. 程序与流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-if-%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6"><span class="toc-text">6.1 if 分支控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-switch-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-text">6.2 switch 分支结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-for%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-text">6.3 for循环控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-while%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-text">6.4 while循环控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-do%E2%80%A6while%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-text">6.5 do…while循环控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5break"><span class="toc-text">6.6 跳转控制语句break</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5continue"><span class="toc-text">6.7 跳转控制语句continue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5goto"><span class="toc-text">6.8 跳转控制语句goto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5return"><span class="toc-text">6.9 跳转控制语句return</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%9E%9A%E4%B8%BE"><span class="toc-text">7. 枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">7.1 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%9E%9A%E4%B8%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">7.2 枚举的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-switch-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE"><span class="toc-text">7.3 switch 中使用枚举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%87%BD%E6%95%B0"><span class="toc-text">8. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">8.1 函数的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">8.2 头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82"><span class="toc-text">8.3 函数细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-text">8.4 函数参数的传递方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">8.5 变量作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">8.6 static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0"><span class="toc-text">8.7 字符串中常用的系统函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">8.8 时间和日期相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">8.9 数学相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">8.10 基本数据类型和字符串类型的转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-text">9. 预处理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">9.1 预处理命令快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-C-%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">9.2 C 语言宏定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">9.3 带参数的宏定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E5%B8%A6%E5%8F%82%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">9.4 带参宏定义和函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93"><span class="toc-text">9.5 预处理命令总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%95%B0%E7%BB%84"><span class="toc-text">10. 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89"><span class="toc-text">10.1 数组定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">10.2 字符数组与字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="toc-text">10.3 字符串的表示形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">10.4 字符串相关函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE"><span class="toc-text">11. 排序和查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">11.1 冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">11.2 二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">11.3 多维数组-二维数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E6%8C%87%E9%92%88"><span class="toc-text">12. 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-text">12.1 指针的算术运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E6%8C%87%E9%92%88%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">12.2 指针的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-text">12.3 指针数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">12.4 指向指针的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88-%E5%9C%B0%E5%9D%80-%E7%BB%99%E5%87%BD%E6%95%B0"><span class="toc-text">12.5 传递指针(地址)给函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-6-%E4%BC%A0%E6%95%B0%E7%BB%84%E7%BB%99%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-text">12.6 传数组给指针变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-7-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="toc-text">12.7 指针函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-8-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">12.8 函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-9-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">12.9 回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-10-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">12.10 动态内存分配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-text">13. 结构体和共用体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">13.1 结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-text">13.2 共用体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">14. 文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-getchar-putchar-%E5%87%BD%E6%95%B0"><span class="toc-text">14.1 getchar() &amp; putchar() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-gets-puts-%E5%87%BD%E6%95%B0"><span class="toc-text">14.2 gets() &amp; puts() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-scanf-%E5%92%8C-printf-%E5%87%BD%E6%95%B0"><span class="toc-text">14.3 scanf() 和 printf() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">14.4 文件操作</span></a></li></ol></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
