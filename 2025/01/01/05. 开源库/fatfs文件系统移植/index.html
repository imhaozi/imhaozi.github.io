
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 8.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>fatfs文件系统移植 - Blog</title>

  
    <meta name="description" content="fatfs文件系统的移植">
<meta property="og:type" content="article">
<meta property="og:title" content="fatfs文件系统移植">
<meta property="og:url" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="fatfs文件系统的移植">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/1.1.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/1.2.png">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.1.png">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.2.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.3.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.4.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.5.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.6.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.7.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.8.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/3.1.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/3.2.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/3.3.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/3.4.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.8.jpg">
<meta property="og:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/4.1.jpg">
<meta property="article:published_time" content="2025-01-01T02:00:00.000Z">
<meta property="article:modified_time" content="2025-11-13T02:00:38.592Z">
<meta property="article:author" content="imhaozi">
<meta property="article:tag" content="Fatfs">
<meta property="article:tag" content="SDCard">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/1.1.jpg">
  
  
  
  <meta name="keywords" content="Fatfs,SDCard">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  
    <link rel="shortcut icon" href="/images/avatar.jpg">
  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"imhaozi","sameAs":[]},"dateCreated":"2025-01-01T10:00:00+08:00","dateModified":"2025-11-13T10:00:38+08:00","datePublished":"2025-01-01T10:00:00+08:00","description":"","headline":"fatfs文件系统移植","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"},"publisher":{"@type":"Organization","name":"imhaozi","sameAs":[]},"url":"http://example.com/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/","keywords":"Fatfs, SDCard","image":[]}</script>
  
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">Blog</div><div class="sub normal cap">装备锻造中</div><div class="sub hover cap" style="opacity:0"> Write By imhaozi</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="文档" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="关于" href="/about/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>



<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2024/10/08/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/lvgl%E7%A7%BB%E6%A4%8D/"><span class="title">lvgl移植</span></a><a class="item title" href="/2025/11/15/04.%20Linux%E5%BA%94%E7%94%A8/TspRosCar/"><span class="title">ros1小车diy记录</span></a><a class="item title" href="/2020/10/01/03.%20RTOS/rtthread_nano/"><span class="title">rtthread_nano移植</span></a><a class="item title" href="/2025/06/01/04.%20Linux%E5%BA%94%E7%94%A8/v3s%E5%BC%80%E5%8F%91%E6%9D%BF%E5%88%B6%E4%BD%9C/"><span class="title">v3s开发板制作</span></a><a class="item title" href="/2025/08/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"><span class="title">博客搭建指南</span></a><a class="item title" href="/2025/06/01/10.%20%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86/%E5%85%85%E7%94%B5%E6%A1%A9%E5%9B%BD%E6%A0%87/"><span class="title">充电桩国标协议解析</span></a><a class="item title" href="/2025/11/05/08.%20%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/candbc/"><span class="title">CanDBC文件制作</span></a><a class="item title" href="/2023/01/01/07.%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/ymodem/"><span class="title">Ymodem</span></a><a class="item title" href="/2023/01/01/07.%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/modbus/"><span class="title">Modbus</span></a><a class="item title" href="/2023/07/01/07.%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/canopen/"><span class="title">CanOpen</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/imhaozi" target="_blank" rel="external nofollow noopener noreferrer"><img no-lazy src="/images/github.svg" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="social" href="https://space.bilibili.com/330622220" target="_blank" rel="external nofollow noopener noreferrer"><img no-lazy src="/images/bilibili.svg" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder/social/942ebbf1a4b91.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E5%BC%80%E6%BA%90%E5%BA%93/">开源库</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-01-01T02:00:00.000Z">2025-01-01</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-11-13T02:00:38.592Z">2025-11-13</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>fatfs文件系统移植</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>使用的开发板：RTT&amp;正点原子的潘多拉loT Board开发板、普中Z-100开发板。主控：STM32L475VET6、STM32F103ZET6</p>
<p>软件：CubeMX 6.7.0、Keil 5.38、FatFs R0.15</p>
<p>学习路线：</p>
<ol>
<li>学会FATFS文件系统的移植；</li>
<li>学会API的使用；</li>
</ol>
<h1 id="第一部分：移植"><a href="#第一部分：移植" class="headerlink" title="第一部分：移植"></a>第一部分：移植</h1><p>FatFs 是一个通用的文件系统(FAT&#x2F;exFAT)模块，用于在小型嵌入式系统中实现FAT文件系统。 </p>
<p>FatFs 组件的编写遵循ANSI C(C89)，完全分离于磁盘 I&#x2F;O 层l，因此不依赖于硬件平台。它可以嵌入到资源有限的微控制器中，如 8051, PIC, AVR, ARM, Z80, RX等等，不需要做任何修改。</p>
<h1 id="1-准备源码"><a href="#1-准备源码" class="headerlink" title="1. 准备源码"></a>1. 准备源码</h1><p>FATFS网站：<a target="_blank" rel="noopener" href="http://elm-chan.org/fsw/ff/00index_e.html">http://elm-chan.org/fsw/ff/00index_e.html</a></p>
<p>从官网中即可下载源码。这里选择最新版本<code>R0.15</code>。</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/1.1.jpg" alt="1.1"></p>
<p>下载压缩包解压后目录如下：</p>
<ul>
<li>ff15<ul>
<li>documents（官网网页，没啥用可删除）</li>
<li>source（源码）<ul>
<li><code>diskio.c \ diskio.h</code></li>
<li>&#96;&#96;ff.c \ ff.h&#96;</li>
<li><code>ffconf.h</code></li>
<li>&#96;&#96;ffsystem.h&#96;</li>
<li><code>ffunicode.c</code></li>
<li>00history.txt</li>
<li>00readme.txt</li>
</ul>
</li>
<li>LICENSE.txt（开源协议）</li>
</ul>
</li>
</ul>
<p>其中：</p>
<ol>
<li>ff.c &#x2F; ff.h：文件系统协议层，几乎不用修改；</li>
<li>ffconf.h：FatFs模块的配置文件；</li>
<li>diskio.c \ diskio.h：将现有磁盘I&#x2F;O模块连接到FatFs的粘合功能，即适配低层硬件接口读写操作，是主要移植修改的重点；</li>
<li>ffunicode.c：字符编码层，可以选择utf8、ascii、GBK。根据需要选择。</li>
<li>ffsystem.c：可选O&#x2F;S相关功能的示例。</li>
</ol>
<p>这是 FatFs 官方所提供的程序之间的依赖网络。其中虚线框不是必须的，为用户自行编写定义。</p>
<p>在官方提供的文件中，<strong>ff.c、ff.h、diskio.h</strong> 是不需要操作的。</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/1.2.png" alt="1.2"></p>
<blockquote>
<p>需要修改的有：</p>
<ul>
<li>ffconf.h：通过修改其中的宏定义可裁剪 FatFs 的部分功能。</li>
<li>diskio.c：底层驱动函数。</li>
</ul>
<p>具体文件如何配置或修改看移植部分。</p>
</blockquote>
<h1 id="2-TF卡-SDIO-模式移植-尚有问题未解决"><a href="#2-TF卡-SDIO-模式移植-尚有问题未解决" class="headerlink" title="2. TF卡 SDIO 模式移植(尚有问题未解决)"></a>2. TF卡 SDIO 模式移植(尚有问题未解决)</h1><p>这里使用<strong>普中Z-100开发板</strong>，主控芯片为<strong>STM32F103ZET6</strong>。开发板上TF卡与主控的通信采用<strong>SDIO通信</strong>。</p>
<p>原理图如下：</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.1.png" alt="2.1"></p>
<h2 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1 创建工程"></a>2.1 创建工程</h2><p>使用CubeMX创建一个工程。需要配置的项目有：</p>
<ul>
<li>时钟</li>
<li>程序调试接口</li>
<li>串口（用于观察调试信息）</li>
<li>SDIO接口（带DMA）</li>
</ul>
<p>其中 SDIO 接口的配置如下：</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.2.jpg" alt="2.2"></p>
<ul>
<li><p><strong>Clock transition on which the bit capture is made：</strong><code>Rising transition</code>。主时钟 SDIOCLK 产生 CLK 引脚时钟有效沿选择，可选上升沿或下降沿，它设定 SDIO 时钟控制寄存器(SDIO_CLKCR)的 NEGEDGE 位的值，一般选择设置为<code>上升沿</code>。</p>
</li>
<li><p><strong>SDIO Clock divider bypass：</strong><code>Disable</code>。时钟分频旁路使用，可选使能或禁用，它设定 SDIO_CLKCR 寄存器的 BYPASS 位。如果使能旁路，SDIOCLK 直接驱动 CLK 线输出时钟；如果禁用，使用 SDIO_CLKCR 寄存器的 CLKDIV 位值分频 SDIOCLK，然后输出到 CLK 线。一般选择禁用时钟分频旁路。</p>
</li>
<li><p><strong>SDIO Clock output enable when the bus is idle：</strong> <code>Disable the power save for the clock</code>。节能模式选择，可选使能或禁用，它设定 SDIO_CLKCR 寄存器的 PWRSAV 位的值。如果使能节能模式，CLK 线只有在总线激活时才有时钟输出；如果禁用节能模式，始终使能 CLK 线输出时钟。</p>
</li>
<li><p><strong>SDIO hardware flow control：</strong> <code>The hardware control flow is disabled</code>。硬件流控制选择，可选使能或禁用，它设定 SDIO_CLKCR 寄存器的 HWFC_EN 位的值。硬件流控制功能可以避免 FIFO 发送上溢和下溢错误。</p>
</li>
<li><p><strong>SDIOCLK clock divide factor：</strong> <code>2</code>。时钟分频系数，它设定 SDIO_CLKCR 寄存器的 CLKDIV 位的值，设置 SDIOCLK 与 CLK 线输出时钟分频系数：CLK 线时钟频率&#x3D;SDIOCLK&#x2F;([CLKDIV+2])。</p>
</li>
</ul>
<blockquote>
<p>SDIO相关的时钟分为两部分：</p>
<ol>
<li><p><strong>SDIO适配器时钟(SDIOCLK)</strong>，用于驱动SDIO适配器，可用于产生SDIO_CK时钟。在STM32F1中，SDIOCLK来自HCLK(72MHz)。改时钟经过上述的分频后产生SDIO_CK时钟。</p>
</li>
<li><p><strong>AHB总线接口时钟(HCLK&#x2F;2)</strong>，该时钟用于驱动SDIO的AHB总线接口，其频率为HCLK&#x2F;2(36MHz)（）在cubemx时钟配置页面可以看得到。</p>
</li>
</ol>
<p>需要注意的是，不同的SD卡对时钟的最高频率范围不同。因此建议将**SDIOCLK clock divide factor：**从0开始慢慢增大试试，可以读写数据成功即可。</p>
<p>我这里用的卡，经过测试设置为0时，卡信息读写成功，数据读写失败。设置为2时，均可成功。</p>
</blockquote>
<p>DMA配置如下：（一般应用中都是用DMA传输）</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.3.jpg" alt="2.3"></p>
<p>此处，可以发现，DMA只能配置一个方向的，即两个方向共用了一个传输通道。在使用时，实际上可以通过重新初始化DMA来更改传输方向。这里先随便设置一个方向即可。</p>
<p>最后勾选上中断：</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.4.jpg" alt="2.4"></p>
<hr>
<p>生成工程后：</p>
<p>修改<code>sdio.c</code>文件中的<code>void MX_SDIO_SD_Init(void)</code>函数。正确的如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_SDIO_SD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  hsd.Instance = SDIO;</span><br><span class="line">  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;</span><br><span class="line">  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;</span><br><span class="line">  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;</span><br><span class="line">  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;	<span class="comment">// 注意要修改这里为 SDIO_BUS_WIDE_1B</span></span><br><span class="line">  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;</span><br><span class="line">  hsd.Init.ClockDiv = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (HAL_SD_Init(&amp;hsd) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (HAL_SD_ConfigWideBusOperation(&amp;hsd, SDIO_BUS_WIDE_4B) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果生成的代码中 本来就是 hsd.Init.BusWide &#x3D; SDIO_BUS_WIDE_1B; 那就不用管。</p>
<p>如果生成的默认是 4B，则要修改为 1B，否则此函数执行的时候不会通过。</p>
<p>（不同固件包生成的不一样，因此要确认一下）</p>
</blockquote>
<h2 id="2-2-SD卡读写验证"><a href="#2-2-SD卡读写验证" class="headerlink" title="2.2 SD卡读写验证"></a>2.2 SD卡读写验证</h2><h3 id="2-2-1-sdio-sdcard-h"><a href="#2-2-1-sdio-sdcard-h" class="headerlink" title="2.2.1 sdio_sdcard.h"></a>2.2.1 sdio_sdcard.h</h3><p>两个 test 函数，测试完成之后不需要的话可以删除。跟后续移植关系不是很大。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SDIO_SDCARD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SDIO_SDCARD_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_info_print</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_read_writer_test</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">SDIO_ReadBlocks_DMA</span><span class="params">(SD_HandleTypeDef *hsd, <span class="type">uint8_t</span> *pData, <span class="type">uint32_t</span> BlockAdd, <span class="type">uint32_t</span> NumberOfBlocks)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">SDIO_WriteBlocks_DMA</span><span class="params">(SD_HandleTypeDef *hsd, <span class="type">uint8_t</span> *pData, <span class="type">uint32_t</span> BlockAdd, <span class="type">uint32_t</span> NumberOfBlocks)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_read_writer_dma_test</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __SDIO_SDCARD_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-2-2-sdio-sdcard-c"><a href="#2-2-2-sdio-sdcard-c" class="headerlink" title="2.2.2 sdio_sdcard.c"></a>2.2.2 sdio_sdcard.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sdio_sdcard.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span>  <span class="comment">// 调试信息输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sdio.h&quot;</span>   <span class="comment">// cubemx生成的</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> SD_HandleTypeDef hsd;</span><br><span class="line"><span class="keyword">extern</span> DMA_HandleTypeDef hdma_sdio;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   打印SD卡信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   none</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_info_print</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_SD_CardInfoTypeDef  SDCardInfo;		<span class="comment">// SD卡信息结构体</span></span><br><span class="line">	HAL_SD_CardCIDTypeDef sdcard_cid;		<span class="comment">// </span></span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">    HAL_SD_GetCardInfo(&amp;hsd, &amp;SDCardInfo);	<span class="comment">// 得到卡的信息</span></span><br><span class="line">	<span class="comment">// 打印SD卡基本信息</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SD card information! \r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Card Type:%d \r\n&quot;</span>,			SDCardInfo.CardType);			<span class="comment">// 卡类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Card CardVersion:%d \r\n&quot;</span>,	SDCardInfo.CardVersion);		<span class="comment">// CardVersion</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Card Class:%d \r\n&quot;</span>,		SDCardInfo.Class);				<span class="comment">// 卡Class</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Card RCA:%d \r\n&quot;</span>,			SDCardInfo.RelCardAdd);			<span class="comment">// 卡相对地址</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Card BlockNumber: %d \r\n&quot;</span>, 	SDCardInfo.BlockNbr);		<span class="comment">// 有多少个块</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Card BlockSize(Byte): %d \r\n&quot;</span>,	SDCardInfo.BlockSize);		<span class="comment">// 块大小 默认512个字节</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Card Capacity(Byte): %llu \r\n&quot;</span>, ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)SDCardInfo.BlockSize * SDCardInfo.BlockNbr));	<span class="comment">// 容量</span></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Card Capacity:%d MB \r\n&quot;</span>, (<span class="type">uint32_t</span>)(SDCardInfo.LogBlockNbr) &gt;&gt; <span class="number">11</span>); <span class="comment">// 显示容量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Card BlockSize:%d \r\n&quot;</span>, 	SDCardInfo.LogBlockSize);       <span class="comment">// 显示块大小</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 读取并打印SD卡的CID信息</span></span><br><span class="line">	HAL_SD_GetCardCID(&amp;hsd, &amp;sdcard_cid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ManufacturerID: %d \r\n&quot;</span>, sdcard_cid.ManufacturerID);	<span class="comment">// 制造商</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   SD卡读写测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   none</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_read_writer_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* SD卡状态 */</span></span><br><span class="line">    <span class="type">int</span> sdcard_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> read_buf[<span class="number">512</span>];      <span class="comment">// 读数据缓存</span></span><br><span class="line">    <span class="type">uint8_t</span> write_buf[<span class="number">512</span>];     <span class="comment">// 写数据缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取未操作之前的数据 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------- Read SD card block data Test ------------------\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        读一个扇区的数据：</span></span><br><span class="line"><span class="comment">        0: 从第0个扇区开始。</span></span><br><span class="line"><span class="comment">        1：读一个扇区的数据。</span></span><br><span class="line"><span class="comment">        0xffff：等待时间。</span></span><br><span class="line"><span class="comment">        note：也就是只读了第0个扇区。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sdcard_status = HAL_SD_ReadBlocks(&amp;hsd, (<span class="type">uint8_t</span> *)read_buf, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">    <span class="keyword">if</span>(sdcard_status == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read block data ok! \r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0x%02x &quot;</span>, read_buf[i]);</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read block data fail! status = %d \r\n&quot;</span>, sdcard_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向SD卡块写入数据 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------- Write SD card block data Test ------------------\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 填充缓冲区数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write_buf[i] = i % <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始写入数据</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        写一个扇区的数据：</span></span><br><span class="line"><span class="comment">        0: 从第0个扇区开始。</span></span><br><span class="line"><span class="comment">        1：写一个扇区的数据。</span></span><br><span class="line"><span class="comment">        0xffff：等待时间。</span></span><br><span class="line"><span class="comment">        note：也就是只写了第0个扇区。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sdcard_status = HAL_SD_WriteBlocks(&amp;hsd, (<span class="type">uint8_t</span> *)write_buf, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">    <span class="keyword">if</span>(sdcard_status == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 传输完成不代表写入完成，因此要等待SD卡状态变为可传输状态。擦除操作也是一样。 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Writing block data. state = %d \r\n&quot;</span>, HAL_SD_GetCardState(&amp;hsd));</span><br><span class="line">        <span class="keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) == HAL_SD_CARD_PROGRAMMING);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Write block data ok，state = %d \r\n&quot;</span>, HAL_SD_GetCardState(&amp;hsd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Write block data fail! status = %d \r\n&quot;</span>, sdcard_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取写入之后的数据 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------- Read SD card block data after Write ------------------\r\n&quot;</span>);</span><br><span class="line">    sdcard_status = HAL_SD_ReadBlocks(&amp;hsd, (<span class="type">uint8_t</span> *)read_buf, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">    <span class="keyword">if</span>(sdcard_status == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read block data ok! \r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0x%02x &quot;</span>, read_buf[i]);</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read block data fail! status = %d \r\n&quot;</span>, sdcard_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 擦除SD卡块 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------- Block Erase -------------------------------\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        擦除512个扇区的数据：</span></span><br><span class="line"><span class="comment">        0: 从第0个扇区开始。</span></span><br><span class="line"><span class="comment">        1：一直擦除到512扇区。</span></span><br><span class="line"><span class="comment">        note：擦除第0到第512个扇区数据，也包括0和512，也就是一共512个。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sdcard_status = HAL_SD_Erase(&amp;hsd, <span class="number">0</span>, <span class="number">512</span>);</span><br><span class="line">    <span class="comment">// 等待擦除完毕</span></span><br><span class="line">    <span class="keyword">if</span>(sdcard_status == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Erasing block. state = %d \r\n&quot;</span>, HAL_SD_GetCardState(&amp;hsd));</span><br><span class="line">        <span class="keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) == HAL_SD_CARD_PROGRAMMING);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Erase block ok state = %d \r\n&quot;</span>, HAL_SD_GetCardState(&amp;hsd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Erase block fail! status = %d \r\n&quot;</span>, sdcard_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取擦除之后的数据 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------- Read SD card block data after Erase ------------------\r\n&quot;</span>);</span><br><span class="line">    sdcard_status = HAL_SD_ReadBlocks(&amp;hsd, (<span class="type">uint8_t</span> *)read_buf, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">    <span class="keyword">if</span>(sdcard_status == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read block data ok \r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0x%02x &quot;</span>, read_buf[i]);</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read block data fail! status = %d \r\n&quot;</span>, sdcard_status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   SD卡DMA读数据（开始前重新初始化DMA，更改传输方向）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   hsd</span></span><br><span class="line"><span class="comment"> * @param   pData</span></span><br><span class="line"><span class="comment"> * @param   BlockAdd</span></span><br><span class="line"><span class="comment"> * @param   NumberOfBlocks</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">SDIO_ReadBlocks_DMA</span><span class="params">(SD_HandleTypeDef *hsd, <span class="type">uint8_t</span> *pData, <span class="type">uint32_t</span> BlockAdd, <span class="type">uint32_t</span> NumberOfBlocks)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_StatusTypeDef Return_Status;</span><br><span class="line">    HAL_SD_CardStateTypeDef SD_Card_Status;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读之前，确保SD卡处于可传输状态</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        SD_Card_Status = HAL_SD_GetCardState(hsd);</span><br><span class="line">    &#125; <span class="keyword">while</span>(SD_Card_Status != HAL_SD_CARD_TRANSFER);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新初始化MDA传输方向</span></span><br><span class="line">    HAL_DMA_DeInit(&amp;hdma_sdio);</span><br><span class="line">    hdma_sdio.Instance = DMA2_Channel4;</span><br><span class="line">    hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">    hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">    hdma_sdio.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">    hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;</span><br><span class="line">    hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;</span><br><span class="line">    hdma_sdio.Init.Mode = DMA_NORMAL;</span><br><span class="line">    hdma_sdio.Init.Priority = DMA_PRIORITY_LOW;</span><br><span class="line">    <span class="keyword">if</span>(HAL_DMA_Init(&amp;hdma_sdio) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    __HAL_LINKDMA(hsd, hdmarx, hdma_sdio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始一次DMA传输</span></span><br><span class="line">    Return_Status = HAL_SD_ReadBlocks_DMA(hsd, pData, BlockAdd, NumberOfBlocks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Return_Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   SD卡DMA写数据（开始前重新初始化DMA，更改传输方向）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   hsd</span></span><br><span class="line"><span class="comment"> * @param   pData</span></span><br><span class="line"><span class="comment"> * @param   BlockAdd</span></span><br><span class="line"><span class="comment"> * @param   NumberOfBlocks</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">SDIO_WriteBlocks_DMA</span><span class="params">(SD_HandleTypeDef *hsd, <span class="type">uint8_t</span> *pData, <span class="type">uint32_t</span> BlockAdd, <span class="type">uint32_t</span> NumberOfBlocks)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_StatusTypeDef Return_Status;</span><br><span class="line">    HAL_SD_CardStateTypeDef SD_Card_Status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        SD_Card_Status = HAL_SD_GetCardState(hsd);</span><br><span class="line">    &#125; <span class="keyword">while</span>(SD_Card_Status != HAL_SD_CARD_TRANSFER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新初始化MDA传输方向</span></span><br><span class="line">    HAL_DMA_DeInit(&amp;hdma_sdio);</span><br><span class="line">    hdma_sdio.Instance = DMA2_Channel4;</span><br><span class="line">    hdma_sdio.Init.Direction = DMA_MEMORY_TO_PERIPH;</span><br><span class="line">    hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">    hdma_sdio.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">    hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;</span><br><span class="line">    hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;</span><br><span class="line">    hdma_sdio.Init.Mode = DMA_NORMAL;</span><br><span class="line">    hdma_sdio.Init.Priority = DMA_PRIORITY_LOW;</span><br><span class="line">    <span class="keyword">if</span>(HAL_DMA_Init(&amp;hdma_sdio) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    __HAL_LINKDMA(hsd, hdmatx, hdma_sdio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始一次DMA传输</span></span><br><span class="line">    Return_Status = HAL_SD_WriteBlocks_DMA(hsd, pData, BlockAdd, NumberOfBlocks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Return_Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   SD卡DMA读写测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   none</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_read_writer_dma_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* SD卡状态 */</span></span><br><span class="line">    <span class="type">int</span> sdcard_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> read_buf[<span class="number">512</span>];      <span class="comment">// 读数据缓存</span></span><br><span class="line">    <span class="type">uint8_t</span> write_buf[<span class="number">512</span>];     <span class="comment">// 写数据缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取未操作之前的数据 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------- Read SD card block data Test ------------------\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        读一个扇区的数据：</span></span><br><span class="line"><span class="comment">        0: 从第0个扇区开始。</span></span><br><span class="line"><span class="comment">        1：读一个扇区的数据。</span></span><br><span class="line"><span class="comment">        note：也就是只读了第0个扇区。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sdcard_status = SDIO_ReadBlocks_DMA(&amp;hsd, (<span class="type">uint8_t</span> *)read_buf, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sdcard_status == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read block data ok! \r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0x%02x &quot;</span>, read_buf[i]);</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read block data fail! status = %d \r\n&quot;</span>, sdcard_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向SD卡块写入数据 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------- Write SD card block data Test ------------------\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 填充缓冲区数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write_buf[i] = i % <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始写入数据</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        写一个扇区的数据：</span></span><br><span class="line"><span class="comment">        0: 从第0个扇区开始。</span></span><br><span class="line"><span class="comment">        1：写一个扇区的数据。</span></span><br><span class="line"><span class="comment">        note：也就是只写了第0个扇区。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sdcard_status = SDIO_WriteBlocks_DMA(&amp;hsd, (<span class="type">uint8_t</span> *)write_buf, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sdcard_status == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 传输完成不代表写入完成，因此要等待SD卡状态变为可传输状态。擦除操作也是一样。 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Writing block data. state = %d \r\n&quot;</span>, HAL_SD_GetCardState(&amp;hsd));</span><br><span class="line">        <span class="keyword">while</span>(HAL_SD_GetCardState(&amp;hsd) == HAL_SD_CARD_PROGRAMMING);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Write block data ok，state = %d \r\n&quot;</span>, HAL_SD_GetCardState(&amp;hsd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Write block data fail! status = %d \r\n&quot;</span>, sdcard_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取写入之后的数据 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------- Read SD card block data after Write ------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sdcard_status = SDIO_ReadBlocks_DMA(&amp;hsd, (<span class="type">uint8_t</span> *)read_buf, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sdcard_status == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read block data ok! \r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0x%02x &quot;</span>, read_buf[i]);</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read block data fail! status = %d \r\n&quot;</span>, sdcard_status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-2-3-main-c"><a href="#2-2-3-main-c" class="headerlink" title="2.2.3 main.c"></a>2.2.3 main.c</h3><p>添加printf支持，在usart.c中添加如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要调用stdio.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 取消ARM的半主机工作模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)<span class="comment">// 标准库需要的支持函数                 </span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="type">int</span> handle; </span><br><span class="line">&#125;; </span><br><span class="line">FILE __stdout;       </span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x) <span class="comment">// 定义_sys_exit()以避免使用半主机模式</span></span><br><span class="line">&#123; </span><br><span class="line">	x = x;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> _ttywrch(<span class="type">int</span> ch)	<span class="comment">// 这个函数一般情况下应该是不需要的，但是在这里需要</span></span><br><span class="line">&#123;</span><br><span class="line">	ch = ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;  </span><br><span class="line">	HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>main.c</code>中while之前运行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SD_info_print();</span><br><span class="line">SD_read_writer_test();    <span class="comment">// 阻塞式读写测试</span></span><br><span class="line">SD_read_writer_dma_test();	<span class="comment">// DMA读写测试</span></span><br></pre></td></tr></table></figure>

<p>如果均能正常执行，即表示配置无误。</p>
<p>如果第二个函数读写失败：参照修改2.1小节<strong>SDIOCLK clock divide factor</strong>参数。</p>
<p>如果生成的初始化函数运行卡死：参照修改2.1小节中的<code>void MX_SDIO_SD_Init(void)</code>函数。</p>
<blockquote>
<p>注意：如果按照上述流程配置下来，<code>SD_read_writer_test();</code>写出错，而<code>SD_read_writer_dma_test();</code>正常运行是没什么问题的。</p>
<p>因为上面的时钟频率设置的挺高的（<strong>SDIOCLK clock divide factor：</strong> <code>2</code>），在此情况下，只能使用DMA模式。</p>
<p>如果不放心，可以把这个参数调大一点之后，然后验证阻塞式读写。验证可以之后再调回来（实际应用中肯定希望速度快一点）。</p>
</blockquote>
<h2 id="2-3-移植-FATFS-系统"><a href="#2-3-移植-FATFS-系统" class="headerlink" title="2.3 移植 FATFS 系统"></a>2.3 移植 FATFS 系统</h2><h3 id="2-3-1-添加源码"><a href="#2-3-1-添加源码" class="headerlink" title="2.3.1 添加源码"></a>2.3.1 添加源码</h3><p>在确保SD卡读写无误之后，开始移植。</p>
<p>在工程目录创建文件夹并放入FATFS系统源码</p>
<ul>
<li>Middlewares\FATFS_R0.15<ul>
<li>ffunicode.c</li>
<li>ffsystem.c</li>
<li>ffconf.h</li>
<li>ff.h</li>
<li>ff.c</li>
<li>diskio.h</li>
<li>diskio.c</li>
<li>00readme.txt</li>
<li>00history.txt</li>
</ul>
</li>
</ul>
<p>并在 Keil 中添加文件和头文件路径。</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.5.jpg" alt="2.5"></p>
<hr>
<p>然后开始适配工作。</p>
<h3 id="2-3-2-修改配置-ffconf-h"><a href="#2-3-2-修改配置-ffconf-h" class="headerlink" title="2.3.2 修改配置 ffconf.h"></a>2.3.2 修改配置 ffconf.h</h3><p>一些声明的含义可以参考一下网址：<a target="_blank" rel="noopener" href="http://elm-chan.org/fsw/ff/doc/config.html%E3%80%82">http://elm-chan.org/fsw/ff/doc/config.html。</a></p>
<p>以下内容是把原有的英文注释换成了中文的。并且修改了自己需要的配置。</p>
<p>需要注意的点（需要进行适配）：</p>
<ul>
<li><code>#define FF_CODE_PAGE	936 // 支持中文</code>	</li>
<li><code>#define FF_USE_LFN		3 // 支持长文件名，且存在堆区</code></li>
<li><code>#define FF_VOLUMES		1 // 一共有一个卷</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以下是全部默认拥有的配置 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 版本ID */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FFCONF_DEF	80286	<span class="comment">/* Revision ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置是否只读。建议为0，否则很多API用不了（0：可读写。1：只读）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_READONLY	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	此选项定义了最小化级别，以删除一些基本API函数。 </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	0：基本功能已完全启用。建议为0</span></span><br><span class="line"><span class="comment">	1：f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_truncate() and f_rename() 被移除</span></span><br><span class="line"><span class="comment">	2：在 1 的基础上 f_opendir(), f_readdir() and f_closedir() 被移除</span></span><br><span class="line"><span class="comment">	3：在 2 的基础上 f_lseek() 被移除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_MINIMIZE	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	设置是否使用查找功能 f_findfirst() and f_findnext(). </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	0：不启用</span></span><br><span class="line"><span class="comment">	1：启用</span></span><br><span class="line"><span class="comment">	2：同时启用匹配altname[]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_FIND		0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	是否启用格式化功能 f_mkfs()，对于没有格式化为Fat32的U盘或者SD卡，设置为1，否则无法正常初始化。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	0：禁止使用 f_mkfs()</span></span><br><span class="line"><span class="comment">	1：允许使用 f_mkfs()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_MKFS		1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置是否使用快速查找功能（0：不使用。1：使用）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_FASTSEEK	1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置是否使用拓展功能（0：不使用。1：使用） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_EXPAND	1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切换属性操作函数 f_chmod（）和 f_utime（）（0：不使用。1：使用）仅在 FF_FS_READONLY 模式下可用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_CHMOD	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切换卷标函数 f_getlabel() and f_setlabel() （0：不使用。1：使用）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_LABEL	1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此选项切换 f_forward（）函数。（0:禁用或1:启用） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_FORWARD	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置对字符串的操作 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_STRFUNC	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_PRINT_LLI	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_PRINT_FLOAT	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_STRF_ENCODE	3</span></span><br><span class="line"><span class="comment">/* FF_USE_STRFUNC switches string functions, f_gets(), f_putc(), f_puts() and f_printf().</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/   0: Disable. FF_PRINT_LLI, FF_PRINT_FLOAT and FF_STRF_ENCODE have no effect.</span></span><br><span class="line"><span class="comment">/   1: Enable without LF-CRLF conversion.</span></span><br><span class="line"><span class="comment">/   2: Enable with LF-CRLF conversion.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/  FF_PRINT_LLI = 1 makes f_printf() support long long argument and FF_PRINT_FLOAT = 1/2</span></span><br><span class="line"><span class="comment">/  makes f_printf() support floating point argument. These features want C99 or later.</span></span><br><span class="line"><span class="comment">/  When FF_LFN_UNICODE &gt;= 1 with LFN enabled, string functions convert the character</span></span><br><span class="line"><span class="comment">/  encoding in it. FF_STRF_ENCODE selects assumption of character encoding ON THE FILE</span></span><br><span class="line"><span class="comment">/  to be read/written via those functions.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/   0: ANSI/OEM in current CP</span></span><br><span class="line"><span class="comment">/   1: Unicode in UTF-16LE</span></span><br><span class="line"><span class="comment">/   2: Unicode in UTF-16BE</span></span><br><span class="line"><span class="comment">/   3: Unicode in UTF-8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置语言支持（932：中文支持。437：英文支持）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_CODE_PAGE	932</span></span><br><span class="line"><span class="comment">/* This option specifies the OEM code page to be used on the target system.</span></span><br><span class="line"><span class="comment">/  Incorrect code page setting can cause a file open failure.</span></span><br><span class="line"><span class="comment">/   437 - U.S.</span></span><br><span class="line"><span class="comment">/   720 - Arabic</span></span><br><span class="line"><span class="comment">/   737 - Greek</span></span><br><span class="line"><span class="comment">/   771 - KBL</span></span><br><span class="line"><span class="comment">/   775 - Baltic</span></span><br><span class="line"><span class="comment">/   850 - Latin 1</span></span><br><span class="line"><span class="comment">/   852 - Latin 2</span></span><br><span class="line"><span class="comment">/   855 - Cyrillic</span></span><br><span class="line"><span class="comment">/   857 - Turkish</span></span><br><span class="line"><span class="comment">/   860 - Portuguese</span></span><br><span class="line"><span class="comment">/   861 - Icelandic</span></span><br><span class="line"><span class="comment">/   862 - Hebrew</span></span><br><span class="line"><span class="comment">/   863 - Canadian French</span></span><br><span class="line"><span class="comment">/   864 - Arabic</span></span><br><span class="line"><span class="comment">/   865 - Nordic</span></span><br><span class="line"><span class="comment">/   866 - Russian</span></span><br><span class="line"><span class="comment">/   869 - Greek 2</span></span><br><span class="line"><span class="comment">/   932 - Japanese (DBCS)</span></span><br><span class="line"><span class="comment">/   936 - Simplified Chinese (DBCS)</span></span><br><span class="line"><span class="comment">/   949 - Korean (DBCS)</span></span><br><span class="line"><span class="comment">/   950 - Traditional Chinese (DBCS)</span></span><br><span class="line"><span class="comment">/     0 - Include all code pages above and configured by f_setcp()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_LFN		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_MAX_LFN		255</span></span><br><span class="line"><span class="comment">/* The FF_USE_LFN switches the support for LFN (long file name).</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/   0: Disable LFN. FF_MAX_LFN has no effect.（默认最长12个字符）</span></span><br><span class="line"><span class="comment">/   1: Enable LFN with static  working buffer on the BSS. Always NOT thread-safe.</span></span><br><span class="line"><span class="comment">/   2: Enable LFN with dynamic working buffer on the STACK.</span></span><br><span class="line"><span class="comment">/   3: Enable LFN with dynamic working buffer on the HEAP.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/  To enable the LFN, ffunicode.c needs to be added to the project. The LFN function</span></span><br><span class="line"><span class="comment">/  requiers certain internal working buffer occupies (FF_MAX_LFN + 1) * 2 bytes and</span></span><br><span class="line"><span class="comment">/  additional (FF_MAX_LFN + 44) / 15 * 32 bytes when exFAT is enabled.</span></span><br><span class="line"><span class="comment">/  The FF_MAX_LFN defines size of the working buffer in UTF-16 code unit and it can</span></span><br><span class="line"><span class="comment">/  be in range of 12 to 255. It is recommended to be set it 255 to fully support LFN</span></span><br><span class="line"><span class="comment">/  specification.</span></span><br><span class="line"><span class="comment">/  When use stack for the working buffer, take care on stack overflow. When use heap</span></span><br><span class="line"><span class="comment">/  memory for the working buffer, memory management functions, ff_memalloc() and</span></span><br><span class="line"><span class="comment">/  ff_memfree() exemplified in ffsystem.c, need to be added to the project. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_LFN_UNICODE	0</span></span><br><span class="line"><span class="comment">/* This option switches the character encoding on the API when LFN is enabled.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/   0: ANSI/OEM in current CP (TCHAR = char)</span></span><br><span class="line"><span class="comment">/   1: Unicode in UTF-16 (TCHAR = WCHAR)</span></span><br><span class="line"><span class="comment">/   2: Unicode in UTF-8 (TCHAR = char)</span></span><br><span class="line"><span class="comment">/   3: Unicode in UTF-32 (TCHAR = DWORD)</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/  Also behavior of string I/O functions will be affected by this option.</span></span><br><span class="line"><span class="comment">/  When LFN is not enabled, this option has no effect. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_LFN_BUF		255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_SFN_BUF		12</span></span><br><span class="line"><span class="comment">/* This set of options defines size of file name members in the FILINFO structure</span></span><br><span class="line"><span class="comment">/  which is used to read out directory items. These values should be suffcient for</span></span><br><span class="line"><span class="comment">/  the file names to read. The maximum possible length of the read file name depends</span></span><br><span class="line"><span class="comment">/  on character encoding. When LFN is not enabled, these options have no effect. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_RPATH		0</span></span><br><span class="line"><span class="comment">/* This option confatfs文件系统移植 support for relative path.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/   0: Disable relative path and remove related functions.</span></span><br><span class="line"><span class="comment">/   1: Enable relative path. f_chdir() and f_chdrive() are available.</span></span><br><span class="line"><span class="comment">/   2: f_getcwd() function is available in addition to 1.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of volumes (logical drives) to be used. (1-10) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_VOLUMES		1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_STR_VOLUME_ID	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_VOLUME_STRS		<span class="string">&quot;RAM&quot;</span>,<span class="string">&quot;NAND&quot;</span>,<span class="string">&quot;CF&quot;</span>,<span class="string">&quot;SD&quot;</span>,<span class="string">&quot;SD2&quot;</span>,<span class="string">&quot;USB&quot;</span>,<span class="string">&quot;USB2&quot;</span>,<span class="string">&quot;USB3&quot;</span></span></span><br><span class="line"><span class="comment">/* FF_STR_VOLUME_ID switches support for volume ID in arbitrary strings.</span></span><br><span class="line"><span class="comment">/  When FF_STR_VOLUME_ID is set to 1 or 2, arbitrary strings can be used as drive</span></span><br><span class="line"><span class="comment">/  number in the path name. FF_VOLUME_STRS defines the volume ID strings for each</span></span><br><span class="line"><span class="comment">/  logical drives. Number of items must not be less than FF_VOLUMES. Valid</span></span><br><span class="line"><span class="comment">/  characters for the volume ID strings are A-Z, a-z and 0-9, however, they are</span></span><br><span class="line"><span class="comment">/  compared in case-insensitive. If FF_STR_VOLUME_ID &gt;= 1 and FF_VOLUME_STRS is</span></span><br><span class="line"><span class="comment">/  not defined, a user defined volume string table is needed as:</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/  const char* VolumeStr[FF_VOLUMES] = &#123;&quot;ram&quot;,&quot;flash&quot;,&quot;sd&quot;,&quot;usb&quot;,...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_MULTI_PARTITION	0</span></span><br><span class="line"><span class="comment">/* This option switches support for multiple volumes on the physical drive.</span></span><br><span class="line"><span class="comment">/  By default (0), each logical drive number is bound to the same physical drive</span></span><br><span class="line"><span class="comment">/  number and only an FAT volume found on the physical drive will be mounted.</span></span><br><span class="line"><span class="comment">/  When this function is enabled (1), each logical drive number can be bound to</span></span><br><span class="line"><span class="comment">/  arbitrary physical drive and partition listed in the VolToPart[]. Also f_fdisk()</span></span><br><span class="line"><span class="comment">/  function will be available. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_MIN_SS		512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_MAX_SS		512</span></span><br><span class="line"><span class="comment">/* This set of options confatfs文件系统移植 the range of sector size to be supported. (512,</span></span><br><span class="line"><span class="comment">/  1024, 2048 or 4096) Always set both 512 for most systems, generic memory card and</span></span><br><span class="line"><span class="comment">/  harddisk, but a larger value may be required for on-board flash memory and some</span></span><br><span class="line"><span class="comment">/  type of optical media. When FF_MAX_SS is larger than FF_MIN_SS, FatFs is configured</span></span><br><span class="line"><span class="comment">/  for variable sector size mode and disk_ioctl() function needs to implement</span></span><br><span class="line"><span class="comment">/  GET_SECTOR_SIZE command. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_LBA64		0</span></span><br><span class="line"><span class="comment">/* This option switches support for 64-bit LBA. (0:Disable or 1:Enable)</span></span><br><span class="line"><span class="comment">/  To enable the 64-bit LBA, also exFAT needs to be enabled. (FF_FS_EXFAT == 1) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_MIN_GPT		0x10000000</span></span><br><span class="line"><span class="comment">/* Minimum number of sectors to switch GPT as partitioning format in f_mkfs and</span></span><br><span class="line"><span class="comment">/  f_fdisk function. 0x100000000 max. This option has no effect when FF_LBA64 == 0. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_TRIM		0</span></span><br><span class="line"><span class="comment">/* This option switches support for ATA-TRIM. (0:Disable or 1:Enable)</span></span><br><span class="line"><span class="comment">/  To enable Trim function, also CTRL_TRIM command should be implemented to the</span></span><br><span class="line"><span class="comment">/  disk_ioctl() function. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_TINY		0</span></span><br><span class="line"><span class="comment">/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)</span></span><br><span class="line"><span class="comment">/  At the tiny configuration, size of file object (FIL) is shrinked FF_MAX_SS bytes.</span></span><br><span class="line"><span class="comment">/  Instead of private sector buffer eliminated from the file object, common sector</span></span><br><span class="line"><span class="comment">/  buffer in the filesystem object (FATFS) is used for the file data transfer. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_EXFAT		0</span></span><br><span class="line"><span class="comment">/* This option switches support for exFAT filesystem. (0:Disable or 1:Enable)</span></span><br><span class="line"><span class="comment">/  To enable exFAT, also LFN needs to be enabled. (FF_USE_LFN &gt;= 1)</span></span><br><span class="line"><span class="comment">/  Note that enabling exFAT discards ANSI C (C89) compatibility. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_NORTC		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_NORTC_MON	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_NORTC_MDAY	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_NORTC_YEAR	2022</span></span><br><span class="line"><span class="comment">/* The option FF_FS_NORTC switches timestamp feature. If the system does not have</span></span><br><span class="line"><span class="comment">/  an RTC or valid timestamp is not needed, set FF_FS_NORTC = 1 to disable the</span></span><br><span class="line"><span class="comment">/  timestamp feature. Every object modified by FatFs will have a fixed timestamp</span></span><br><span class="line"><span class="comment">/  defined by FF_NORTC_MON, FF_NORTC_MDAY and FF_NORTC_YEAR in local time.</span></span><br><span class="line"><span class="comment">/  To enable timestamp function (FF_FS_NORTC = 0), get_fattime() function need to be</span></span><br><span class="line"><span class="comment">/  added to the project to read current time form real-time clock. FF_NORTC_MON,</span></span><br><span class="line"><span class="comment">/  FF_NORTC_MDAY and FF_NORTC_YEAR have no effect.</span></span><br><span class="line"><span class="comment">/  These options have no effect in read-only configuration (FF_FS_READONLY = 1). */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_NOFSINFO	0</span></span><br><span class="line"><span class="comment">/* If you need to know correct free space on the FAT32 volume, set bit 0 of this</span></span><br><span class="line"><span class="comment">/  option, and f_getfree() function at the first time after volume mount will force</span></span><br><span class="line"><span class="comment">/  a full FAT scan. Bit 1 controls the use of last allocated cluster number.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/  bit0=0: Use free cluster count in the FSINFO if available.</span></span><br><span class="line"><span class="comment">/  bit0=1: Do not trust free cluster count in the FSINFO.</span></span><br><span class="line"><span class="comment">/  bit1=0: Use last allocated cluster number in the FSINFO if available.</span></span><br><span class="line"><span class="comment">/  bit1=1: Do not trust last allocated cluster number in the FSINFO.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_LOCK		0</span></span><br><span class="line"><span class="comment">/* The option FF_FS_LOCK switches file lock function to control duplicated file open</span></span><br><span class="line"><span class="comment">/  and illegal operation to open objects. This option must be 0 when FF_FS_READONLY</span></span><br><span class="line"><span class="comment">/  is 1.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/  0:  Disable file lock function. To avoid volume corruption, application program</span></span><br><span class="line"><span class="comment">/      should avoid illegal open, remove and rename to the open objects.</span></span><br><span class="line"><span class="comment">/  &gt;0: Enable file lock function. The value defines how many files/sub-directories</span></span><br><span class="line"><span class="comment">/      can be opened simultaneously under file lock control. Note that the file</span></span><br><span class="line"><span class="comment">/      lock control is independent of re-entrancy. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_REENTRANT	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_TIMEOUT	1000</span></span><br><span class="line"><span class="comment">/* The option FF_FS_REENTRANT switches the re-entrancy (thread safe) of the FatFs</span></span><br><span class="line"><span class="comment">/  module itself. Note that regardless of this option, file access to different</span></span><br><span class="line"><span class="comment">/  volume is always re-entrant and volume control functions, f_mount(), f_mkfs()</span></span><br><span class="line"><span class="comment">/  and f_fdisk() function, are always not re-entrant. Only file/directory access</span></span><br><span class="line"><span class="comment">/  to the same volume is under control of this featuer.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/   0: Disable re-entrancy. FF_FS_TIMEOUT have no effect.</span></span><br><span class="line"><span class="comment">/   1: Enable re-entrancy. Also user provided synchronization handlers,</span></span><br><span class="line"><span class="comment">/      ff_mutex_create(), ff_mutex_delete(), ff_mutex_take() and ff_mutex_give()</span></span><br><span class="line"><span class="comment">/      function, must be added to the project. Samples are available in ffsystem.c.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/  The FF_FS_TIMEOUT defines timeout period in unit of O/S time tick.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里设置了支持长文件名，并且相关内容要申请堆中的内存，因此这里需要增大堆内存的空间。</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.6.jpg" alt="2.6"></p>
<p>也可以直接从启动文件处修改</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.7.jpg" alt="2.7"></p>
<h3 id="2-3-3-底层适配-diskio-c"><a href="#2-3-3-底层适配-diskio-c" class="headerlink" title="2.3.3 底层适配 diskio.c"></a>2.3.3 底层适配 diskio.c</h3><p>需要适配的函数如下</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.8.jpg" alt="2.8"></p>
<p><strong>第一步：设备编号定义</strong></p>
<p>这里只有一个设备（SD卡），把<code>DEV_MMC</code>编号改为<strong>0</strong>。（要求从0开始按顺序增加）</p>
<p>其他的可以按顺序编号，当然也可以直接删掉。但是为了以后增加，建议保留。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Definitions of physical drive number for each drive */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_RAM		1	<span class="comment">/* Example: Map Ramdisk to physical drive 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_MMC		0	<span class="comment">/* Example: Map MMC/SD card to physical drive 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_USB		2	<span class="comment">/* Example: Map USB MSD to physical drive 2 */</span></span></span><br></pre></td></tr></table></figure>

<p>这里名字其实是可以改的，比如改为（正点原子就是这样的）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SD_CARD	 	0  			<span class="comment">// SD卡,卷标为0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EX_FLASH 	1			<span class="comment">// 外部spi flash,卷标为1</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果改了，下面的适配函数也都一样改就可以了。</p>
</blockquote>
<p><strong>第二步：添加头文件</strong></p>
<p>因为需要用到我们前面写好的驱动以及printf调试输出，把头文件添加进来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi_sdcard.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br></pre></td></tr></table></figure>



<p><strong>第三步：函数适配</strong></p>
<p>这里直接默认返回OK，没什么问题，其他类型的设备注释掉即可。需要用的话再修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DSTATUS <span class="title function_">disk_status</span> <span class="params">(</span></span><br><span class="line"><span class="params">	BYTE pdrv		<span class="comment">/* Physical drive nmuber to identify the drive */</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DSTATUS stat;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> DEV_RAM :	<span class="comment">// 还没用到，先注释掉</span></span><br><span class="line">		<span class="comment">// result = RAM_disk_status();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> stat;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_MMC :</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 默认没什么问题</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_USB :	<span class="comment">// 还没用到，先注释掉</span></span><br><span class="line">		<span class="comment">// result = USB_disk_status();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> stat;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> STA_NOINIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化调用我们前面写好的驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">DSTATUS <span class="title function_">disk_initialize</span> <span class="params">(</span></span><br><span class="line"><span class="params">	BYTE pdrv				<span class="comment">/* Physical drive nmuber to identify the drive */</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DSTATUS stat;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> DEV_RAM :	<span class="comment">// 还没用到，先注释掉</span></span><br><span class="line">		<span class="comment">// result = RAM_disk_initialize();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> stat;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_MMC :</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(SD_Init() == <span class="number">0</span>)    <span class="comment">// SD_Init()是SD初始化函数，无错误返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> STA_NOINIT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_USB :	<span class="comment">// 还没用到，先注释掉</span></span><br><span class="line">		<span class="comment">// result = USB_disk_initialize();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> stat;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> STA_NOINIT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读扇区函数，一样的调用前面的驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">DRESULT <span class="title function_">disk_read</span> <span class="params">(</span></span><br><span class="line"><span class="params">	BYTE pdrv,		<span class="comment">/* Physical drive nmuber to identify the drive */</span></span></span><br><span class="line"><span class="params">	BYTE *buff,		<span class="comment">/* Data buffer to store read data */</span></span></span><br><span class="line"><span class="params">	LBA_t sector,	<span class="comment">/* Start sector in LBA */</span></span></span><br><span class="line"><span class="params">	UINT count		<span class="comment">/* Number of sectors to read */</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DRESULT res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> DEV_RAM :</span><br><span class="line">		<span class="comment">// translate the arguments here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// result = RAM_disk_read(buff, sector, count);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_MMC :</span><br><span class="line">		</span><br><span class="line">		res = (DRESULT) SD_ReadDisk(buff, sector, count);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(res)	<span class="comment">// 读出错</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;sd read error:%d\r\n&quot;</span>, res);</span><br><span class="line">			SD_Init();	<span class="comment">// 重新初始化SD卡</span></span><br><span class="line">			res =  (DRESULT) SD_ReadDisk(buff,sector,count);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_USB :</span><br><span class="line">		<span class="comment">// translate the arguments here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// result = USB_disk_read(buff, sector, count);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RES_PARERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写扇区函数，还是调用写好的驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">DRESULT <span class="title function_">disk_write</span> <span class="params">(</span></span><br><span class="line"><span class="params">	BYTE pdrv,			<span class="comment">/* Physical drive nmuber to identify the drive */</span></span></span><br><span class="line"><span class="params">	<span class="type">const</span> BYTE *buff,	<span class="comment">/* Data to be written */</span></span></span><br><span class="line"><span class="params">	LBA_t sector,		<span class="comment">/* Start sector in LBA */</span></span></span><br><span class="line"><span class="params">	UINT count			<span class="comment">/* Number of sectors to write */</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DRESULT res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> DEV_RAM :</span><br><span class="line">		<span class="comment">// translate the arguments here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// result = RAM_disk_write(buff, sector, count);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_MMC :</span><br><span class="line">		</span><br><span class="line">		res = (DRESULT) SD_WriteDisk((<span class="type">uint8_t</span> *)buff, sector, count);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(res)	<span class="comment">// 写出错</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;sd write error:%d\r\n&quot;</span>, res);</span><br><span class="line">			SD_Init();	<span class="comment">// 重新初始化SD卡</span></span><br><span class="line">			res = (DRESULT) SD_WriteDisk((<span class="type">uint8_t</span> *)buff, sector, count);			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_USB :</span><br><span class="line">		<span class="comment">// translate the arguments here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// result = USB_disk_write(buff, sector, count);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RES_PARERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">DRESULT <span class="title function_">disk_ioctl</span> <span class="params">(</span></span><br><span class="line"><span class="params">	BYTE pdrv,		<span class="comment">/* Physical drive nmuber (0..) */</span></span></span><br><span class="line"><span class="params">	BYTE cmd,		<span class="comment">/* Control code */</span></span></span><br><span class="line"><span class="params">	<span class="type">void</span> *buff		<span class="comment">/* Buffer to send/receive control data */</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DRESULT res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> DEV_RAM :</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process of the command for the RAM drive</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_MMC :</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(cmd)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_FS_READONLY == 0</span></span><br><span class="line">		    <span class="keyword">case</span> CTRL_SYNC:</span><br><span class="line">				res = RES_OK; </span><br><span class="line">		        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_USE_MKFS == 1</span></span><br><span class="line">		    <span class="keyword">case</span> GET_SECTOR_COUNT:</span><br><span class="line">		        *(DWORD*)buff = SD_GetSectorCount();</span><br><span class="line">		        res = RES_OK;</span><br><span class="line">		        <span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> GET_BLOCK_SIZE:</span><br><span class="line">				*(WORD*)buff = <span class="number">8</span>;</span><br><span class="line">		        res = RES_OK;</span><br><span class="line">		        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_MAX_SS != FF_MIN_SS</span></span><br><span class="line">		    <span class="keyword">case</span> GET_SECTOR_SIZE:</span><br><span class="line">				*(DWORD*)buff = <span class="number">512</span>; </span><br><span class="line">		        res = RES_OK;</span><br><span class="line">		        <span class="keyword">break</span>;	 </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		    <span class="keyword">default</span>:</span><br><span class="line">		        res = RES_PARERR;</span><br><span class="line">		        <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_USB :</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process of the command the USB drive</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RES_PARERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此文件的最后添加一个获取时间的函数，默认返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">get_fattime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;				 </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-4-验证-main-c"><a href="#2-3-4-验证-main-c" class="headerlink" title="2.3.4 验证 main.c"></a>2.3.4 验证 main.c</h3><p>把以下代码放在main函数中执行，如果成功执行，说明没问题。</p>
<blockquote>
<p>这里执行 f_res &#x3D; f_mount(&amp;fs, “0:”, 1)，标号0就是diskio.c开头定义的标号。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">FATFS fs;				<span class="comment">/* FatFs 文件系统对象 */</span></span><br><span class="line">FRESULT f_res;			<span class="comment">/* 文件操作结果 */</span></span><br><span class="line">BYTE work[FF_MAX_SS];</span><br><span class="line"></span><br><span class="line">FIL file;                       <span class="comment">/* 文件对象 */</span></span><br><span class="line">UINT fnum;                      <span class="comment">/* 文件成功读写数量 */</span></span><br><span class="line">BYTE ReadBuffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">/* 读缓冲区 */</span></span><br><span class="line">BYTE WriteBuffer[] = <span class="string">&quot;This is STM32 working with FatFs \r\n&quot;</span>;	<span class="comment">/* 写缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在外部 SD 卡挂载文件系统，文件系统挂载时会对 SD 卡初始化</span></span><br><span class="line"><span class="comment">// note:必须先要保证SD卡正常拥有FAT文件系统，如果没有会失败。</span></span><br><span class="line">   f_res = f_mount(&amp;fs, <span class="string">&quot;0:&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果没有文件系统就格式化创建创建文件系统 */</span></span><br><span class="line">   <span class="keyword">if</span>(f_res == FR_NO_FILESYSTEM)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;The SD card does not yet have a file system and is about to be formatted... \r\n&quot;</span>);</span><br><span class="line">       <span class="comment">/* 格式化 */</span></span><br><span class="line">	f_res = f_mkfs(<span class="string">&quot;0:&quot;</span>, <span class="literal">NULL</span>, work, <span class="keyword">sizeof</span>(work));	<span class="comment">/* Create a FAT volume */</span></span><br><span class="line">	</span><br><span class="line">       <span class="keyword">if</span>(f_res == FR_OK)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;The SD card successfully formatted the file system\r\n&quot;</span>);</span><br><span class="line">           <span class="comment">/* 格式化后，先取消挂载 */</span></span><br><span class="line">           f_res = f_mount(<span class="literal">NULL</span>, <span class="string">&quot;0:&quot;</span>, <span class="number">1</span>);</span><br><span class="line">           <span class="comment">/* 重新挂载 */</span></span><br><span class="line">           f_res = f_mount(&amp;fs, <span class="string">&quot;0:&quot;</span>, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;The format failed\r\n&quot;</span>);</span><br><span class="line">           <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(f_res != FR_OK)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;mount error : %d \r\n&quot;</span>, f_res);</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;mount sucess!!! \r\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------- 文件系统测试：写测试 -----------------------------*/</span></span><br><span class="line">   <span class="comment">/* 打开文件，如果文件不存在则创建它 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\r\n ****** Create and Open new text file objects with write access ****** \r\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">f_res = f_open(&amp;file, <span class="string">&quot;0:FatFs STM32cube.txt&quot;</span>, FA_CREATE_ALWAYS | FA_WRITE);</span><br><span class="line">   <span class="keyword">if</span>(f_res == FR_OK)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;open file sucess!!! \r\n&quot;</span>);</span><br><span class="line">       <span class="comment">/* 将指定存储区内容写入到文件内 */</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\r\n****** Write data to the text files ******\r\n&quot;</span>);</span><br><span class="line">       f_res = f_write(&amp;file, WriteBuffer, <span class="keyword">sizeof</span>(WriteBuffer), &amp;fnum);</span><br><span class="line">       <span class="keyword">if</span>(f_res == FR_OK)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;write file sucess!!! (%d)\r\n&quot;</span>, fnum);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;write Data : %s\r\n&quot;</span>, WriteBuffer);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;write file error : %d\r\n&quot;</span>, f_res);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* 不再读写，关闭文件 */</span></span><br><span class="line">       f_close(&amp;file);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;open file error : %d\r\n&quot;</span>, f_res);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*------------------- 文件系统测试：读测试 ------------------------------------*/</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\r\n****** Read data from the text files ******\r\n&quot;</span>);</span><br><span class="line">   f_res = f_open(&amp;file, <span class="string">&quot;0:FatFs STM32cube.txt&quot;</span>, FA_OPEN_EXISTING | FA_READ);</span><br><span class="line">   <span class="keyword">if</span>(f_res == FR_OK)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;open file sucess!!! \r\n&quot;</span>);</span><br><span class="line">       f_res = f_read(&amp;file, ReadBuffer, <span class="keyword">sizeof</span>(ReadBuffer), &amp;fnum);</span><br><span class="line">       <span class="keyword">if</span>(f_res == FR_OK)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;read sucess!!! (%d)\r\n&quot;</span>, fnum);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;read Data : %s\r\n&quot;</span>, ReadBuffer);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot; read error!!! %d\r\n&quot;</span>, f_res);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;open file error : %d\r\n&quot;</span>, f_res);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 不再读写，关闭文件 */</span></span><br><span class="line">   f_close(&amp;file);</span><br><span class="line">   <span class="comment">/* 不再使用文件系统，取消挂载文件系统 */</span></span><br><span class="line">   f_mount(<span class="literal">NULL</span>, <span class="string">&quot;0:&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="comment">/* 操作完成，停机 */</span></span><br></pre></td></tr></table></figure>



<p>其他 API 的使用参考 FATFS 官网：<a target="_blank" rel="noopener" href="http://elm-chan.org/fsw/ff/00index_e.html">http://elm-chan.org/fsw/ff/00index_e.html</a></p>
<h1 id="3-TF卡-SPI-模式移植"><a href="#3-TF卡-SPI-模式移植" class="headerlink" title="3. TF卡 SPI 模式移植"></a>3. TF卡 SPI 模式移植</h1><p>这里使用<strong>RTT&amp;正点原子的潘多拉loT Board开发板</strong>，主控芯片为<strong>STM32L475VET6</strong>。开发板上TF卡与主控的通信采用<strong>SPI通信</strong>。</p>
<p>原理图如下：</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/3.1.jpg" alt="3.1"></p>
<ul>
<li>SPI1_SCK：PA5</li>
<li>SPI1_MISO：PA6</li>
<li>SPI1_MOSI：PA7</li>
<li>SD_CS：PC3</li>
</ul>
<h2 id="3-1-创建工程"><a href="#3-1-创建工程" class="headerlink" title="3.1 创建工程"></a>3.1 创建工程</h2><p>使用CubeMX创建一个工程。需要配置的项目有：</p>
<ul>
<li>时钟</li>
<li>程序调试接口</li>
<li>串口（用于观察调试信息）</li>
<li>SPI 接口</li>
<li>片选引脚CS（推挽输出，默认高电平，速度最快，上拉）</li>
</ul>
<p>其中 SPI 接口的配置如下： </p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/3.2.jpg" alt="3.2"></p>
<blockquote>
<p>SPI 与 SD卡 通信，在卡识别阶段，时钟频率不能超过400K。在传输数据阶段可以更高，最多不超过25M。不同的卡上限不太一样。</p>
<p>这里初始化时先设置一个较低的速度，识别完成之后更改 SPI 波特率即可。</p>
</blockquote>
<h2 id="3-2-SD卡读写验证"><a href="#3-2-SD卡读写验证" class="headerlink" title="3.2 SD卡读写验证"></a>3.2 SD卡读写验证</h2><h3 id="3-2-1-spi-sdcard-h"><a href="#3-2-1-spi-sdcard-h" class="headerlink" title="3.2.1 spi_sdcard.h"></a>3.2.1 spi_sdcard.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SPI_SDCARD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SPI_SDCARD_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	SD_CS:		PC3		// 片选</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SD_CS_SET(n)	(n?HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_SET):HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SD卡类型定义  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SD_TYPE_ERR     0X00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SD_TYPE_MMC     0X01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SD_TYPE_V1      0X02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SD_TYPE_V2      0X04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SD_TYPE_V2HC    0X06</span></span><br><span class="line"><span class="comment">// SD卡指令表  	   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD0    0       <span class="comment">// 卡复位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD1    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD8    8       <span class="comment">// 命令8 ，SEND_IF_COND</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD9    9       <span class="comment">// 命令9 ，读CSD数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD10   10      <span class="comment">// 命令10，读CID数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD12   12      <span class="comment">// 命令12，停止数据传输</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD16   16      <span class="comment">// 命令16，设置SectorSize 应返回0x00</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD17   17      <span class="comment">// 命令17，读sector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD18   18      <span class="comment">// 命令18，读Multi sector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD23   23      <span class="comment">// 命令23，设置多sector写入前预先擦除N个block</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD24   24      <span class="comment">// 命令24，写sector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD25   25      <span class="comment">// 命令25，写Multi sector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD41   41      <span class="comment">// 命令41，应返回0x00</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD55   55      <span class="comment">// 命令55，应返回0x01</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD58   58      <span class="comment">// 命令58，读OCR信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD59   59      <span class="comment">// 命令59，使能/禁止CRC，应返回0x00</span></span></span><br><span class="line"><span class="comment">// 数据写入回应字意义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_DATA_OK                0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_DATA_CRC_ERROR         0x0B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_DATA_WRITE_ERROR       0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_DATA_OTHER_ERROR       0xFF</span></span><br><span class="line"><span class="comment">// SD卡回应标记字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_RESPONSE_NO_ERROR      0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_IN_IDLE_STATE          0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_ERASE_RESET            0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_ILLEGAL_COMMAND        0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_COM_CRC_ERROR          0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_ERASE_SEQUENCE_ERROR   0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_ADDRESS_ERROR          0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_PARAMETER_ERROR        0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSD_RESPONSE_FAILURE       0xFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========================== 以下通信部分修改区 ============================*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_SPI_SetSpeed</span><span class="params">(<span class="type">uint8_t</span> SPI_BaudRatePrescaler)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_SPI_ReadWriteByte</span><span class="params">(<span class="type">uint8_t</span> TxData)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_SPI_WriteByte</span><span class="params">(<span class="type">uint8_t</span> TxData)</span>;</span><br><span class="line"><span class="comment">/* ========================== 以上通信部分修改区 ============================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========================== 以下SD卡通信修改区 ============================*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span>  SD_Type;			<span class="comment">//SD卡的类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_ReadWriteByte</span><span class="params">(<span class="type">uint8_t</span> data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_SpeedLow</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_SpeedHigh</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* ========================== 以上SD卡通信修改区 ============================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========================== 以下SD卡通信实现区（无需修改） ============================*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_WaitReady</span><span class="params">(<span class="type">void</span>)</span>;										<span class="comment">// 等待SD卡准备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_DisSelect</span><span class="params">(<span class="type">void</span>)</span>;										<span class="comment">// 取消片选</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_Select</span><span class="params">(<span class="type">void</span>)</span>;										<span class="comment">// 片选选中</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_GetResponse</span><span class="params">(<span class="type">uint8_t</span> Response)</span>;						<span class="comment">// 获得响应</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_RecvData</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">uint16_t</span> len)</span>;				<span class="comment">// 读sd卡512字节（一个扇区）</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_SendBlock</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">uint8_t</span> cmd)</span>;				<span class="comment">// 向sd卡写512字节（一个扇区）</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_SendCmd</span><span class="params">(<span class="type">uint8_t</span> cmd, <span class="type">uint32_t</span> arg, <span class="type">uint8_t</span> crc)</span>;		<span class="comment">// 发送命令</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_GetCID</span><span class="params">(<span class="type">uint8_t</span> *cid_data)</span>;							<span class="comment">// 读SD卡CID</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_GetCSD</span><span class="params">(<span class="type">uint8_t</span> *csd_data)</span>;							<span class="comment">// 读SD卡CSD</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">SD_GetSectorCount</span><span class="params">(<span class="type">void</span>)</span>;								<span class="comment">// 读扇区数</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_Init</span><span class="params">(<span class="type">void</span>)</span>;											<span class="comment">// 初始化</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_ReadDisk</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">uint32_t</span> sector, <span class="type">uint8_t</span> cnt)</span>;	<span class="comment">// 写块，连续读扇区</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_WriteDisk</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">uint32_t</span> sector, <span class="type">uint8_t</span> cnt)</span>;	<span class="comment">// 读块，连续写扇区</span></span><br><span class="line"><span class="comment">/* ========================== 以上SD卡通信实现区（无需修改） ============================*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __SPI_SDCARD_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-2-2-spi-sdcard-c"><a href="#3-2-2-spi-sdcard-c" class="headerlink" title="3.2.2 spi_sdcard.c"></a>3.2.2 spi_sdcard.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi_sdcard.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span>	<span class="comment">// 调试信息输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi.h&quot;</span>    <span class="comment">// cubemx生成的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span>  <span class="comment">// cubemx生成的</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========================== 以下通信部分修改区 ============================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> SPI_HandleTypeDef hspi1;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SD_SPI hspi1            <span class="comment">// 减少移植时需要修改的地方</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   SD_SPI 速度设置函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   SPI_BaudRate_Prescaler  SPI_BAUDRATEPRESCALER_2~SPI_BAUDRATEPRESCALER_256（2的倍数）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @remark  SD卡初始化时，波特率不能超过400k，传输数据时可以很高（不同SD卡的最高范围不同）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_SPI_SetSpeed</span><span class="params">(<span class="type">uint8_t</span> SPI_BaudRatePrescaler)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler)); <span class="comment">// 判断有效性</span></span><br><span class="line"></span><br><span class="line">    __HAL_SPI_DISABLE(&amp;SD_SPI);            <span class="comment">// 先关闭SPI</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;    // 设置波特率</span></span><br><span class="line"></span><br><span class="line">    SD_SPI.Instance-&gt;CR1 &amp;= <span class="number">0XFFC7</span>;                 <span class="comment">// 位3-5清零，用来设置波特率</span></span><br><span class="line">    SD_SPI.Instance-&gt;CR1 |= SPI_BaudRatePrescaler;  <span class="comment">// 设置SPI速度</span></span><br><span class="line"></span><br><span class="line">    __HAL_SPI_ENABLE(&amp;SD_SPI);             <span class="comment">// 重新使能SPI</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   SD_SPI 读写一个字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   TxData      要写入的字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t     读取到的字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_SPI_ReadWriteByte</span><span class="params">(<span class="type">uint8_t</span> TxData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Rxdata;</span><br><span class="line">    HAL_SPI_TransmitReceive(&amp;SD_SPI, &amp;TxData, &amp;Rxdata, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> Rxdata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   SD_SPI 写入一个字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   TxData      要写入的字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t     0:写入成功,其他:写入失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_SPI_WriteByte</span><span class="params">(<span class="type">uint8_t</span> TxData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> HAL_SPI_Transmit(&amp;SD_SPI, &amp;TxData, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========================== 以上通信部分修改区 ============================*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========================== 以下SD卡通信修改区 ============================*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>  SD_Type = <span class="number">0</span>;   <span class="comment">// SD卡的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   SD卡底层读写一个字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   data        要写入的字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t     读取到的字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @remark  调用SPI读写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_ReadWriteByte</span><span class="params">(<span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> SD_SPI_ReadWriteByte(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   SD卡初始化的时候,需要低速（400K以下）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @remark  根据自己的芯片选择合适的分频系数 STM32L475VET6在这个分频系数下对应的是312.5K</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_SpeedLow</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化时设置到低速模式</span></span><br><span class="line">    SD_SPI_SetSpeed(SPI_BAUDRATEPRESCALER_256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   SD卡正常工作的时候,可以高速</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @remark  根据自己的芯片选择合适的分频系数 STM32L475VET6在这个分频系数下对应的是40M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_SpeedHigh</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传输数据时设置到高速模式</span></span><br><span class="line">    SD_SPI_SetSpeed(SPI_BAUDRATEPRESCALER_2);   <span class="comment">// STM32L475VET6对应的是40M</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========================== 以上SD卡通信修改区 ============================*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========================== 以下SD卡通信实现区（无需修改） ============================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   等待卡准备好</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t 0,准备好了;其他,错误代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_WaitReady</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SD_SPI_ReadWriteByte(<span class="number">0XFF</span>) == <span class="number">0XFF</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">// OK</span></span><br><span class="line">        t++;</span><br><span class="line">    &#125; <span class="keyword">while</span>(t &lt; <span class="number">0XFFFFFF</span>);	<span class="comment">// 等待</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   取消选择,释放SPI总线</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SD_DisSelect</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SD_CS_SET(<span class="number">1</span>);</span><br><span class="line">    SD_ReadWriteByte(<span class="number">0xff</span>); <span class="comment">// 提供额外的8个时钟</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   选择SD卡,并且等待卡准备OK</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  0,成功;1,失败;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_Select</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SD_CS_SET(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(SD_WaitReady() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 等待成功</span></span><br><span class="line">	</span><br><span class="line">    SD_DisSelect();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">// 等待失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   等待SD卡回应</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   Response	要得到的回应值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t		0,成功得到了该回应值。其他,得到回应值失败。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_GetResponse</span><span class="params">(<span class="type">uint8_t</span> Response)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> Count = <span class="number">0xFFFF</span>; <span class="comment">// 等待次数</span></span><br><span class="line">    <span class="keyword">while</span>((SD_SPI_ReadWriteByte(<span class="number">0XFF</span>) != Response) &amp;&amp; Count)</span><br><span class="line">		Count--; 	<span class="comment">// 等待得到准确的回应</span></span><br><span class="line">    <span class="keyword">if</span>(Count == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> MSD_RESPONSE_FAILURE;	<span class="comment">// 得到回应失败</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> MSD_RESPONSE_NO_ERROR;	<span class="comment">// 正确回应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   从sd卡读取一个数据包的内容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   buf     	数据缓存区</span></span><br><span class="line"><span class="comment"> * @param   len     	要读取的数据长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t     0,成功;其他,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_RecvData</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">uint16_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(SD_GetResponse(<span class="number">0xFE</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">// 等待SD卡发回数据起始令牌0xFE</span></span><br><span class="line">    <span class="keyword">while</span>(len--)	<span class="comment">// 开始接收数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        *buf = SD_ReadWriteByte(<span class="number">0xFF</span>);</span><br><span class="line">        buf++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是2个伪CRC（dummy CRC）</span></span><br><span class="line">    SD_SPI_ReadWriteByte(<span class="number">0xFF</span>);</span><br><span class="line">    SD_SPI_ReadWriteByte(<span class="number">0xFF</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 读取成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   向sd卡写入一个数据包的内容 512字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   buf     	数据缓存区</span></span><br><span class="line"><span class="comment"> * @param   cmd     	指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t     0,成功;其他,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_SendBlock</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">uint8_t</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> t;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(SD_WaitReady())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">// 等待准备失效</span></span><br><span class="line">	</span><br><span class="line">    SD_ReadWriteByte(cmd);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(cmd != <span class="number">0XFD</span>)	<span class="comment">// 不是结束指令</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">512</span>; t++)</span><br><span class="line">			SD_ReadWriteByte(buf[t]);		<span class="comment">// 提高速度,减少函数传参时间</span></span><br><span class="line">		</span><br><span class="line">        SD_ReadWriteByte(<span class="number">0xFF</span>);	<span class="comment">// 忽略crc</span></span><br><span class="line">        SD_ReadWriteByte(<span class="number">0xFF</span>);</span><br><span class="line">        </span><br><span class="line">		t = SD_SPI_ReadWriteByte(<span class="number">0xFF</span>);	<span class="comment">// 接收响应</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span>((t &amp; <span class="number">0x1F</span>) != <span class="number">0x05</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;	<span class="comment">// 响应错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 写入成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   向SD卡发送一个命令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   cmd     	命令</span></span><br><span class="line"><span class="comment"> * @param   arg     	命令参数</span></span><br><span class="line"><span class="comment"> * @param   crc     	crc校验值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t     SD卡返回的响应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_SendCmd</span><span class="params">(<span class="type">uint8_t</span> cmd, <span class="type">uint32_t</span> arg, <span class="type">uint8_t</span> crc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> r1;</span><br><span class="line">    <span class="type">uint8_t</span> Retry = <span class="number">0</span>;</span><br><span class="line">    SD_DisSelect();		<span class="comment">// 取消上次片选</span></span><br><span class="line">    <span class="keyword">if</span>(SD_Select())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0XFF</span>;	<span class="comment">// 片选失效</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 发送</span></span><br><span class="line">    SD_ReadWriteByte(cmd | <span class="number">0x40</span>);	<span class="comment">// 分别写入命令</span></span><br><span class="line">    SD_ReadWriteByte(arg &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    SD_ReadWriteByte(arg &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    SD_ReadWriteByte(arg &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    SD_ReadWriteByte(arg);</span><br><span class="line">    SD_ReadWriteByte(crc);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(cmd == CMD12)</span><br><span class="line">		SD_ReadWriteByte(<span class="number">0xff</span>); <span class="comment">// Skip a stuff byte when stop reading</span></span><br><span class="line">    <span class="comment">// 等待响应，或超时退出</span></span><br><span class="line">    Retry = <span class="number">0X1F</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        r1 = SD_ReadWriteByte(<span class="number">0xFF</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span>((r1 &amp; <span class="number">0X80</span>) &amp;&amp; Retry--);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r1;	<span class="comment">// 返回状态值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   获取SD卡的CID信息，包括制造商信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   cid_data    存放CID的内存，至少16Byte</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t		0：NO_ERR。1：错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_GetCID</span><span class="params">(<span class="type">uint8_t</span> *cid_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> r1;</span><br><span class="line">    <span class="comment">// 发CMD10命令，读CID</span></span><br><span class="line">    r1 = SD_SendCmd(CMD10, <span class="number">0</span>, <span class="number">0x01</span>);</span><br><span class="line">    <span class="keyword">if</span>(r1 == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r1 = SD_RecvData(cid_data, <span class="number">16</span>); <span class="comment">// 接收16个字节的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    SD_DisSelect();	<span class="comment">// 取消片选</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(r1)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   获取SD卡的CSD信息，包括容量和速度信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   cid_data    存放CSD的内存，至少16Byte</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t		0：NO_ERR。1：错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_GetCSD</span><span class="params">(<span class="type">uint8_t</span> *csd_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> r1;</span><br><span class="line">    r1 = SD_SendCmd(CMD9, <span class="number">0</span>, <span class="number">0x01</span>);		<span class="comment">// 发CMD9命令，读CSD</span></span><br><span class="line">    <span class="keyword">if</span>(r1 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r1 = SD_RecvData(csd_data, <span class="number">16</span>); <span class="comment">// 接收16个字节的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    SD_DisSelect();<span class="comment">//取消片选</span></span><br><span class="line">    <span class="keyword">if</span>(r1)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   获取SD卡的总扇区数（扇区数）每扇区的字节数必为512，因为如果不是512，则初始化不能通过.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint32_t	0： 取容量出错。其他:SD卡的容量(扇区数/512字节)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">SD_GetSectorCount</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> csd[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint32_t</span> Capacity;</span><br><span class="line">    <span class="type">uint8_t</span> n;</span><br><span class="line">    <span class="type">uint16_t</span> csize;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 取CSD信息，如果期间出错，返回0</span></span><br><span class="line">    <span class="keyword">if</span>(SD_GetCSD(csd) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SD_GetCSD(csd):[%d]\r\n&quot;</span>, csd[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果为SDHC卡，按照下面方式计算</span></span><br><span class="line">    <span class="keyword">if</span>((csd[<span class="number">0</span>] &amp; <span class="number">0xC0</span>) == <span class="number">0x40</span>)	<span class="comment">// V2.00的卡</span></span><br><span class="line">    &#123;</span><br><span class="line">        csize = csd[<span class="number">9</span>] + ((<span class="type">uint16_t</span>)csd[<span class="number">8</span>] &lt;&lt; <span class="number">8</span>) + <span class="number">1</span>;</span><br><span class="line">        Capacity = (<span class="type">uint32_t</span>)csize &lt;&lt; <span class="number">10</span>;	<span class="comment">// 得到扇区数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// V1.XX的卡</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = (csd[<span class="number">5</span>] &amp; <span class="number">15</span>) + ((csd[<span class="number">10</span>] &amp; <span class="number">128</span>) &gt;&gt; <span class="number">7</span>) + ((csd[<span class="number">9</span>] &amp; <span class="number">3</span>) &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        csize = (csd[<span class="number">8</span>] &gt;&gt; <span class="number">6</span>) + ((<span class="type">uint16_t</span>)csd[<span class="number">7</span>] &lt;&lt; <span class="number">2</span>) + ((<span class="type">uint16_t</span>)(csd[<span class="number">6</span>] &amp; <span class="number">3</span>) &lt;&lt; <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">        Capacity = (<span class="type">uint32_t</span>)csize &lt;&lt; (n - <span class="number">9</span>); <span class="comment">// 得到扇区数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   初始化SD卡</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   void</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t     0:初始化成功,其他：初始化错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> r1;			<span class="comment">// 存放SD卡的返回值</span></span><br><span class="line">    <span class="type">uint16_t</span> retry;		<span class="comment">// 用来进行超时计数</span></span><br><span class="line">    <span class="type">uint8_t</span> buf[<span class="number">4</span>];</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line"></span><br><span class="line">    SD_SpeedLow();		<span class="comment">// 设置到低速模式</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		SD_ReadWriteByte(<span class="number">0XFF</span>);	<span class="comment">// 发送最少74个脉冲</span></span><br><span class="line">	</span><br><span class="line">    retry = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        r1 = SD_SendCmd(CMD0, <span class="number">0</span>, <span class="number">0x95</span>); <span class="comment">// 进入IDLE状态</span></span><br><span class="line">    &#125; <span class="keyword">while</span>((r1 != <span class="number">0X01</span>) &amp;&amp; retry--);</span><br><span class="line">	</span><br><span class="line">    SD_Type = <span class="number">0</span>;	<span class="comment">// 默认无卡</span></span><br><span class="line">    <span class="keyword">if</span>(r1 == <span class="number">0X01</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SD_SendCmd(CMD8, <span class="number">0x1AA</span>, <span class="number">0x87</span>) == <span class="number">1</span>)	<span class="comment">// SD V2.0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">				buf[i] = SD_ReadWriteByte(<span class="number">0XFF</span>);	<span class="comment">// Get trailing return value of R7 resp</span></span><br><span class="line">            <span class="keyword">if</span>(buf[<span class="number">2</span>] == <span class="number">0X01</span> &amp;&amp; buf[<span class="number">3</span>] == <span class="number">0XAA</span>)		<span class="comment">// 卡是否支持2.7~3.6V</span></span><br><span class="line">            &#123;</span><br><span class="line">                retry = <span class="number">0XFFFE</span>;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    SD_SendCmd(CMD55, <span class="number">0</span>, <span class="number">0X01</span>);		<span class="comment">// 发送CMD55</span></span><br><span class="line">                    r1 = SD_SendCmd(CMD41, <span class="number">0x40000000</span>, <span class="number">0X01</span>);	<span class="comment">// 发送CMD41</span></span><br><span class="line">                &#125; <span class="keyword">while</span>(r1 &amp;&amp; retry--);</span><br><span class="line">                <span class="keyword">if</span>(retry &amp;&amp; SD_SendCmd(CMD58, <span class="number">0</span>, <span class="number">0X01</span>) == <span class="number">0</span>)	<span class="comment">// 鉴别SD2.0卡版本开始</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">						buf[i] = SD_ReadWriteByte(<span class="number">0XFF</span>);	<span class="comment">// 得到OCR值</span></span><br><span class="line">                    <span class="keyword">if</span>(buf[<span class="number">0</span>] &amp; <span class="number">0x40</span>)</span><br><span class="line">						SD_Type = SD_TYPE_V2HC;					<span class="comment">// 检查CCS</span></span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">						SD_Type = SD_TYPE_V2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// SD V1.x/ MMC V3</span></span><br><span class="line">        &#123;</span><br><span class="line">            SD_SendCmd(CMD55, <span class="number">0</span>, <span class="number">0X01</span>);			<span class="comment">// 发送CMD55</span></span><br><span class="line">            r1 = SD_SendCmd(CMD41, <span class="number">0</span>, <span class="number">0X01</span>);	<span class="comment">// 发送CMD41</span></span><br><span class="line">            <span class="keyword">if</span>(r1 &lt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                SD_Type = SD_TYPE_V1;</span><br><span class="line">                retry = <span class="number">0XFFFE</span>;</span><br><span class="line">                <span class="keyword">do</span> <span class="comment">// 等待退出IDLE模式</span></span><br><span class="line">                &#123;</span><br><span class="line">                    SD_SendCmd(CMD55, <span class="number">0</span>, <span class="number">0X01</span>);			<span class="comment">// 发送CMD55</span></span><br><span class="line">                    r1 = SD_SendCmd(CMD41, <span class="number">0</span>, <span class="number">0X01</span>);	<span class="comment">// 发送CMD41</span></span><br><span class="line">                &#125; <span class="keyword">while</span>(r1 &amp;&amp; retry--);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// MMC卡不支持CMD55+CMD41识别</span></span><br><span class="line">            &#123;</span><br><span class="line">                SD_Type = SD_TYPE_MMC; <span class="comment">// MMC V3</span></span><br><span class="line">                retry = <span class="number">0XFFFE</span>;</span><br><span class="line">                <span class="keyword">do</span> <span class="comment">// 等待退出IDLE模式</span></span><br><span class="line">                &#123;</span><br><span class="line">                    r1 = SD_SendCmd(CMD1, <span class="number">0</span>, <span class="number">0X01</span>); <span class="comment">// 发送CMD1</span></span><br><span class="line">                &#125; <span class="keyword">while</span>(r1 &amp;&amp; retry--);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(retry == <span class="number">0</span> || SD_SendCmd(CMD16, <span class="number">512</span>, <span class="number">0X01</span>) != <span class="number">0</span>)SD_Type = SD_TYPE_ERR; <span class="comment">// 错误的卡</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SD_DisSelect();		<span class="comment">// 取消片选</span></span><br><span class="line">    SD_SpeedHigh();		<span class="comment">// 高速</span></span><br><span class="line">    <span class="keyword">if</span>(SD_Type)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r1)</span><br><span class="line">		<span class="keyword">return</span> r1;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xaa</span>;	<span class="comment">// 其他错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   读SD卡，连续读扇区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   buf     	数据缓存区</span></span><br><span class="line"><span class="comment"> * @param   sector  	扇区</span></span><br><span class="line"><span class="comment"> * @param   cnt     	扇区数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t     0,OK;其他,失败.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_ReadDisk</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">uint32_t</span> sector, <span class="type">uint8_t</span> cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> r1;</span><br><span class="line">    <span class="keyword">if</span>(SD_Type != SD_TYPE_V2HC)</span><br><span class="line">		sector &lt;&lt;= <span class="number">9</span>;	<span class="comment">// 转换为字节地址</span></span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r1 = SD_SendCmd(CMD17, sector, <span class="number">0X01</span>); <span class="comment">// 读命令</span></span><br><span class="line">        <span class="keyword">if</span>(r1 == <span class="number">0</span>) <span class="comment">// 指令发送成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            r1 = SD_RecvData(buf, <span class="number">512</span>); <span class="comment">// 接收512个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        r1 = SD_SendCmd(CMD18, sector, <span class="number">0X01</span>);	<span class="comment">// 连续读命令</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            r1 = SD_RecvData(buf, <span class="number">512</span>);			<span class="comment">// 接收512个字节</span></span><br><span class="line">            buf += <span class="number">512</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(--cnt &amp;&amp; r1 == <span class="number">0</span>);</span><br><span class="line">        SD_SendCmd(CMD12, <span class="number">0</span>, <span class="number">0X01</span>);				<span class="comment">// 发送停止命令</span></span><br><span class="line">    &#125;</span><br><span class="line">    SD_DisSelect();	<span class="comment">// 取消片选</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> r1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   写SD卡，连续写扇区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param   buf     数据缓存区</span></span><br><span class="line"><span class="comment"> * @param   sector  起始扇区</span></span><br><span class="line"><span class="comment"> * @param   cnt     扇区数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return  uint8_t     0,OK;其他,失败.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">SD_WriteDisk</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">uint32_t</span> sector, <span class="type">uint8_t</span> cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> r1;</span><br><span class="line">    <span class="keyword">if</span>(SD_Type != SD_TYPE_V2HC)</span><br><span class="line">		sector *= <span class="number">512</span>;	<span class="comment">// 转换为字节地址</span></span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r1 = SD_SendCmd(CMD24, sector, <span class="number">0X01</span>); <span class="comment">// 读命令</span></span><br><span class="line">        <span class="keyword">if</span>(r1 == <span class="number">0</span>) <span class="comment">// 指令发送成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            r1 = SD_SendBlock(buf, <span class="number">0xFE</span>);	<span class="comment">// 写512个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SD_Type != SD_TYPE_MMC)</span><br><span class="line">        &#123;</span><br><span class="line">            SD_SendCmd(CMD55, <span class="number">0</span>, <span class="number">0X01</span>);</span><br><span class="line">            SD_SendCmd(CMD23, cnt, <span class="number">0X01</span>);		<span class="comment">// 发送指令</span></span><br><span class="line">        &#125;</span><br><span class="line">        r1 = SD_SendCmd(CMD25, sector, <span class="number">0X01</span>);	<span class="comment">// 连续读命令</span></span><br><span class="line">        <span class="keyword">if</span>(r1 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                r1 = SD_SendBlock(buf, <span class="number">0xFC</span>);	<span class="comment">// 接收512个字节</span></span><br><span class="line">                buf += <span class="number">512</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span>(--cnt &amp;&amp; r1 == <span class="number">0</span>);</span><br><span class="line">            r1 = SD_SendBlock(<span class="number">0</span>, <span class="number">0xFD</span>);			<span class="comment">// 接收512个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SD_DisSelect();	<span class="comment">// 取消片选</span></span><br><span class="line">    <span class="keyword">return</span> r1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ========================== 以上SD卡通信实现区（无需修改） ============================*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-2-3-main-c"><a href="#3-2-3-main-c" class="headerlink" title="3.2.3 main.c"></a>3.2.3 main.c</h3><p>添加printf支持，在usart.c中添加如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要调用stdio.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 取消ARM的半主机工作模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)<span class="comment">// 标准库需要的支持函数                 </span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="type">int</span> handle; </span><br><span class="line">&#125;; </span><br><span class="line">FILE __stdout;       </span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x) <span class="comment">// 定义_sys_exit()以避免使用半主机模式</span></span><br><span class="line">&#123; </span><br><span class="line">	x = x;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> _ttywrch(<span class="type">int</span> ch)	<span class="comment">// 这个函数一般情况下应该是不需要的，但是在这里需要</span></span><br><span class="line">&#123;</span><br><span class="line">	ch = ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;  </span><br><span class="line">	HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把以下代码放在main函数中执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">uint8_t</span> sta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(SD_Init())	<span class="comment">// 检测不到SD卡</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;initing...!\r\n&quot;</span>);</span><br><span class="line">    HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SD Card Size = %d MB \r\n&quot;</span>, SD_GetSectorCount() &gt;&gt; <span class="number">11</span>);	<span class="comment">// 每个扇区512字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SD Card Capacity = %d\r\n&quot;</span>, SD_GetSectorCount());		<span class="comment">// 每个扇区512字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从0扇区开始，读取一个扇区的数据</span></span><br><span class="line"><span class="keyword">if</span>(SD_ReadDisk(buf, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;USART1 Sending Data...\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SECTOR 0 DATA:\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint32_t</span> sd_size = <span class="number">0</span>; sd_size &lt; <span class="number">512</span>; sd_size++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, buf[sd_size]); <span class="comment">// 打印0扇区数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n USART1 Send Data Over! \r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数组中的数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">    buf[i] = i * <span class="number">3</span>;		<span class="comment">// 初始化写入的数据,是3的倍数.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第0个扇区开始读取一个扇区的数据</span></span><br><span class="line">sta = SD_WriteDisk(buf, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(sta == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Write over!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;err:%d\r\n&quot;</span>, sta);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从0扇区开始，读取一个扇区的数据（验证是否是写入的数据）</span></span><br><span class="line"><span class="keyword">if</span>(SD_ReadDisk(buf, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;USART1 Sending Data...\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SECTOR 0 DATA:\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint32_t</span> sd_size = <span class="number">0</span>; sd_size &lt; <span class="number">512</span>; sd_size++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, buf[sd_size]); <span class="comment">// 打印0扇区数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n USART1 Send Data Over! \r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果程序正常执行，说明SD卡读写没问题。可以进行下一步。</p>
<h2 id="3-3-移植-FATFS-系统"><a href="#3-3-移植-FATFS-系统" class="headerlink" title="3.3 移植 FATFS 系统"></a>3.3 移植 FATFS 系统</h2><h3 id="3-3-1-添加源码"><a href="#3-3-1-添加源码" class="headerlink" title="3.3.1 添加源码"></a>3.3.1 添加源码</h3><p>在工程目录创建文件夹并放入FATFS系统源码</p>
<ul>
<li>Middlewares\FATFS_R0.15<ul>
<li>ffunicode.c</li>
<li>ffsystem.c</li>
<li>ffconf.h</li>
<li>ff.h</li>
<li>ff.c</li>
<li>diskio.h</li>
<li>diskio.c</li>
<li>00readme.txt</li>
<li>00history.txt</li>
</ul>
</li>
</ul>
<p>并在 Keil 中添加文件和头文件路径。</p>
<h3 id="3-3-2-修改配置-ffconf-h"><a href="#3-3-2-修改配置-ffconf-h" class="headerlink" title="3.3.2 修改配置 ffconf.h"></a>3.3.2 修改配置 ffconf.h</h3><p>一些声明的含义可以参考一下网址：<a target="_blank" rel="noopener" href="http://elm-chan.org/fsw/ff/doc/config.html%E3%80%82">http://elm-chan.org/fsw/ff/doc/config.html。</a></p>
<p>以下内容是把原有的英文注释换成了中文的。并且修改了自己需要的配置。</p>
<p>需要注意的点（需要进行适配）：</p>
<ul>
<li><code>#define FF_CODE_PAGE	936 // 支持中文</code>	</li>
<li><code>#define FF_USE_LFN		3 // 支持长文件名，且存在堆区</code></li>
<li><code>#define FF_VOLUMES		1 // 一共有一个卷</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 版本ID */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FFCONF_DEF	80286	<span class="comment">/* Revision ID */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------/</span></span><br><span class="line"><span class="comment">/ Function Configurations</span></span><br><span class="line"><span class="comment">/---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置是否只读。建议为0，否则很多API用不了（0：可读写。1：只读）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_READONLY	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	此选项定义了最小化级别，以删除一些基本API函数。 </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	0：基本功能已完全启用。建议为0</span></span><br><span class="line"><span class="comment">	1：f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_truncate() and f_rename() 被移除</span></span><br><span class="line"><span class="comment">	2：在 1 的基础上 f_opendir(), f_readdir() and f_closedir() 被移除</span></span><br><span class="line"><span class="comment">	3：在 2 的基础上 f_lseek() 被移除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_MINIMIZE	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	设置是否使用查找功能 f_findfirst() and f_findnext(). </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	0：不启用</span></span><br><span class="line"><span class="comment">	1：启用</span></span><br><span class="line"><span class="comment">	2：同时启用匹配altname[]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_FIND		0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	是否启用格式化功能 f_mkfs()，对于没有格式化为Fat32的U盘或者SD卡，设置为1，否则无法正常初始化。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	0：禁止使用 f_mkfs()</span></span><br><span class="line"><span class="comment">	1：允许使用 f_mkfs()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_MKFS		1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置是否使用快速查找功能（0：不使用。1：使用）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_FASTSEEK	1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置是否使用拓展功能（0：不使用。1：使用） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_EXPAND	1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切换属性操作函数 f_chmod（）和 f_utime（）（0：不使用。1：使用）仅在 FF_FS_READONLY 模式下可用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_CHMOD	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切换卷标函数 f_getlabel() and f_setlabel() （0：不使用。1：使用）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_LABEL	1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此选项切换 f_forward（）函数。（0:禁用或1:启用） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_FORWARD	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置对字符串的操作 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_STRFUNC	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_PRINT_LLI	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_PRINT_FLOAT	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_STRF_ENCODE	3</span></span><br><span class="line"><span class="comment">/* FF_USE_STRFUNC switches string functions, f_gets(), f_putc(), f_puts() and f_printf().</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/   0: Disable. FF_PRINT_LLI, FF_PRINT_FLOAT and FF_STRF_ENCODE have no effect.</span></span><br><span class="line"><span class="comment">/   1: Enable without LF-CRLF conversion.</span></span><br><span class="line"><span class="comment">/   2: Enable with LF-CRLF conversion.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/  FF_PRINT_LLI = 1 makes f_printf() support long long argument and FF_PRINT_FLOAT = 1/2</span></span><br><span class="line"><span class="comment">/  makes f_printf() support floating point argument. These features want C99 or later.</span></span><br><span class="line"><span class="comment">/  When FF_LFN_UNICODE &gt;= 1 with LFN enabled, string functions convert the character</span></span><br><span class="line"><span class="comment">/  encoding in it. FF_STRF_ENCODE selects assumption of character encoding ON THE FILE</span></span><br><span class="line"><span class="comment">/  to be read/written via those functions.</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/   0: ANSI/OEM in current CP</span></span><br><span class="line"><span class="comment">/   1: Unicode in UTF-16LE</span></span><br><span class="line"><span class="comment">/   2: Unicode in UTF-16BE</span></span><br><span class="line"><span class="comment">/   3: Unicode in UTF-8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------/</span></span><br><span class="line"><span class="comment">/ Locale and Namespace Configurations</span></span><br><span class="line"><span class="comment">/---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置语言支持（936：中文支持。437：英文支持）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_CODE_PAGE	936</span></span><br><span class="line"><span class="comment">/* This option specifies the OEM code page to be used on the target system.</span></span><br><span class="line"><span class="comment">/  Incorrect code page setting can cause a file open failure.</span></span><br><span class="line"><span class="comment">/   437 - U.S.</span></span><br><span class="line"><span class="comment">/   720 - Arabic</span></span><br><span class="line"><span class="comment">/   737 - Greek</span></span><br><span class="line"><span class="comment">/   771 - KBL</span></span><br><span class="line"><span class="comment">/   775 - Baltic</span></span><br><span class="line"><span class="comment">/   850 - Latin 1</span></span><br><span class="line"><span class="comment">/   852 - Latin 2</span></span><br><span class="line"><span class="comment">/   855 - Cyrillic</span></span><br><span class="line"><span class="comment">/   857 - Turkish</span></span><br><span class="line"><span class="comment">/   860 - Portuguese</span></span><br><span class="line"><span class="comment">/   861 - Icelandic</span></span><br><span class="line"><span class="comment">/   862 - Hebrew</span></span><br><span class="line"><span class="comment">/   863 - Canadian French</span></span><br><span class="line"><span class="comment">/   864 - Arabic</span></span><br><span class="line"><span class="comment">/   865 - Nordic</span></span><br><span class="line"><span class="comment">/   866 - Russian</span></span><br><span class="line"><span class="comment">/   869 - Greek 2</span></span><br><span class="line"><span class="comment">/   932 - Japanese (DBCS)</span></span><br><span class="line"><span class="comment">/   936 - Simplified Chinese (DBCS)</span></span><br><span class="line"><span class="comment">/   949 - Korean (DBCS)</span></span><br><span class="line"><span class="comment">/   950 - Traditional Chinese (DBCS)</span></span><br><span class="line"><span class="comment">/     0 - Include all code pages above and configured by f_setcp()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	设置是否支持长文件名（如果设置了支持中文，建议一定要使用，中文一个字符两个字节）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	0：不启用（最长12个字符，FF_MAX_LFN参数不生效）</span></span><br><span class="line"><span class="comment">	1：启用(工作空间在BSS段，线程不安全。可以使用)</span></span><br><span class="line"><span class="comment">	2：启用（使用动态缓存在栈区。不推荐）</span></span><br><span class="line"><span class="comment">	3：启用（使用动态缓存在堆区。推荐使用）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_LFN		3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_MAX_LFN		255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	当FF_USE_LFN启用时，此处设置字符编码。（IO函数也会被影响）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	0: ANSI/OEM in current CP (TCHAR = char)</span></span><br><span class="line"><span class="comment">	1: Unicode in UTF-16 (TCHAR = WCHAR)</span></span><br><span class="line"><span class="comment">	2: Unicode in UTF-8 (TCHAR = char)</span></span><br><span class="line"><span class="comment">	3: Unicode in UTF-32 (TCHAR = DWORD)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_LFN_UNICODE	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	这组选项定义FILINFO结构中用于读取目录项的文件名成员的大小。</span></span><br><span class="line"><span class="comment">	这些值应该足以读取文件名。读取文件名的最大可能长度取决于字符编码。</span></span><br><span class="line"><span class="comment">	当LFN未启用时，这些选项无效。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_LFN_BUF		255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_SFN_BUF		12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	设置是否支持相对路径</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	0: 不支持相对路径，并删除相关函数</span></span><br><span class="line"><span class="comment">	1: 支持相对路径，f_chdir（）和f_chdrive（）可用。</span></span><br><span class="line"><span class="comment">	2: 在1的基础上，f_getcwd() 可用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_RPATH		0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------/</span></span><br><span class="line"><span class="comment">/ Drive/Volume Configurations</span></span><br><span class="line"><span class="comment">/---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	一共有几个卷。（1-10）</span></span><br><span class="line"><span class="comment">	有几个存储设备就设置为几，比如只有SD卡就是1；如果有SD卡和W25Q128就是2。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_VOLUMES		1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	FF_STR_VOLUME_ID：卷标从几开始。</span></span><br><span class="line"><span class="comment">	当 FF_STR_VOLUME_ID 设置为1或2时，路径名称中的驱动器号可以使用任意字符串。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	FF_VOLUME_STRS 定义每个逻辑驱动器的卷ID字符串。项目数量不得小于FF_VOLUMES。</span></span><br><span class="line"><span class="comment">	卷ID字符串的有效字符为A-Z、A-Z和0-9，但是，会对它们进行不区分大小写的比较。</span></span><br><span class="line"><span class="comment">	如果 FF_STR_VOLUME_ID&gt;=1 且未定义 FF_VOLUME_STRS，则需要用户定义的卷字符串表，如下所示：</span></span><br><span class="line"><span class="comment">	const char* VolumeStr[FF_VOLUMES] = &#123;&quot;ram&quot;,&quot;flash&quot;,&quot;sd&quot;,&quot;usb&quot;,...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_STR_VOLUME_ID	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_VOLUME_STRS		<span class="string">&quot;RAM&quot;</span>,<span class="string">&quot;NAND&quot;</span>,<span class="string">&quot;CF&quot;</span>,<span class="string">&quot;SD&quot;</span>,<span class="string">&quot;SD2&quot;</span>,<span class="string">&quot;USB&quot;</span>,<span class="string">&quot;USB2&quot;</span>,<span class="string">&quot;USB3&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	多分区支持。（将一个物理设备分为多个磁盘）</span></span><br><span class="line"><span class="comment">	0：不支持。默认每个设备就是一个磁盘分区。</span></span><br><span class="line"><span class="comment">	1：支持。每个逻辑驱动器号都可以绑定到VolToPart[]中列出的任意物理驱动器和分区。</span></span><br><span class="line"><span class="comment">		并且支持 f_fdisk() 函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_MULTI_PARTITION	0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置设备扇区的大小范围。（对于SD卡，固定就是512）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	如果 FF_MAX_SS &gt; FF_MIN_SS。	FatFs被配置为可变扇区大小模式。</span></span><br><span class="line"><span class="comment">	disk_ioctl() 函数需要实现 GET_SECTOR_SIZE 命令</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_MIN_SS		512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_MAX_SS		512</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	此选项切换对64位LBA的支持。</span></span><br><span class="line"><span class="comment">	0:禁用</span></span><br><span class="line"><span class="comment">	1:启用</span></span><br><span class="line"><span class="comment">	要启用64位LBA，还需要启用exFAT（FF_FS_EXFAT==1）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_LBA64		0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在f_mkfs和f_fdisk函数中将GPT切换为分区格式的最小扇区数。</span></span><br><span class="line"><span class="comment">	0x100000000最大值。当FF_LBA64==0时，此选项无效。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_MIN_GPT		0x10000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	此选项切换对ATA-TRIM的支持。</span></span><br><span class="line"><span class="comment">	0：禁用</span></span><br><span class="line"><span class="comment">	1：启用</span></span><br><span class="line"><span class="comment">	要启用Trim函数，还应将CTRL_TRIM命令实现到disk_ioctl（）函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_USE_TRIM		0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------/</span></span><br><span class="line"><span class="comment">/ System Configurations</span></span><br><span class="line"><span class="comment">/---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	此选项切换小缓冲区配置。</span></span><br><span class="line"><span class="comment">	0:正常</span></span><br><span class="line"><span class="comment">	1:微小。	在微小配置下，文件对象（FIL）的大小收缩为FF_MAX_SS字节。</span></span><br><span class="line"><span class="comment">		文件系统对象（FATFS）中的公共扇区缓冲区用于文件数据传输，而不是从文件对象中删除私有扇区缓冲区</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_TINY		0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	此选项切换对exFAT文件系统的支持。</span></span><br><span class="line"><span class="comment">	0：禁用</span></span><br><span class="line"><span class="comment">	1：启用</span></span><br><span class="line"><span class="comment">	要启用exFAT，还需要启用LFN。（FF_USE_LFN&gt;=1）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_EXFAT		0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	FF_FS_NORTC：系统是否有RTC时钟，以支持时间戳功能。（FF_FS_READONLY = 1时，该选项不受影响）</span></span><br><span class="line"><span class="comment">	0：有RTC，支持时间戳。需要添加 get_fattime() 函数。</span></span><br><span class="line"><span class="comment">		FF_NORTC_YEAR、FF_NORTC_MDAY、FF_NORTC_MON 不受影响</span></span><br><span class="line"><span class="comment">	1：没有RTC，不支持时间戳。</span></span><br><span class="line"><span class="comment">		使用默认的FF_NORTC_YEAR、FF_NORTC_MDAY、FF_NORTC_MON</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_NORTC		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_NORTC_MON	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_NORTC_MDAY	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_NORTC_YEAR	2022</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果您需要知道FAT32卷上的正确可用空间，请设置此选项的位0，</span></span><br><span class="line"><span class="comment">	并且在卷装载后的第一时间执行f_getfree（）函数将强制进行完整的FAT扫描。</span></span><br><span class="line"><span class="comment">	位1控制最后分配的簇号的使用。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	bit0=0: Use free cluster count in the FSINFO if available.</span></span><br><span class="line"><span class="comment">	bit0=1: Do not trust free cluster count in the FSINFO.</span></span><br><span class="line"><span class="comment">	bit1=0: Use last allocated cluster number in the FSINFO if available.</span></span><br><span class="line"><span class="comment">	bit1=1: Do not trust last allocated cluster number in the FSINFO.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_NOFSINFO	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	选项 FF_FS_LOCK 切换文件锁定功能以控制重复文件打开和非法操作以打开对象。</span></span><br><span class="line"><span class="comment">	当 FF_FS_READONLY 为1时，此选项必须为0。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	0:禁用文件锁定功能。为了避免卷损坏，应用程序应避免非法打开、删除和重命名打开的对象。</span></span><br><span class="line"><span class="comment">	!0:启用文件锁定功能。该值定义在文件锁定控制下可以同时打开的文件/子目录的数量。</span></span><br><span class="line"><span class="comment">		请注意，文件锁定控制与重新进入无关。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_LOCK		0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	选项FF_FS_REENTRANT切换FatFs模块本身的再入（线程安全）。</span></span><br><span class="line"><span class="comment">	请注意，无论此选项如何，对不同卷的文件访问始终是可重入的，</span></span><br><span class="line"><span class="comment">	卷控制函数f_mount（）、f_mkfs（）和f_fdisk（）始终不是可重入函数。</span></span><br><span class="line"><span class="comment">	只有对同一卷的文件/目录访问受此功能控制。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	0:禁用重入。FF_FS_TIMEOUT无效。</span></span><br><span class="line"><span class="comment">	1：启用重新进入。</span></span><br><span class="line"><span class="comment">		此外，必须将用户提供的同步处理程序ff_mutex_create（）、ff_mutexdelete（）</span></span><br><span class="line"><span class="comment">		ff_mutex_take（）和ff_mutex_give（）函数添加到项目中。</span></span><br><span class="line"><span class="comment">		样品可在ffsystem.c中获得。</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	FF_FS_TIMEOUT 以 O/S 时间刻度为单位定义超时时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_REENTRANT	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FF_FS_TIMEOUT	1000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里设置了支持长文件名，并且相关内容要申请堆中的内存，因此这里需要增大堆内存的空间。</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/3.3.jpg" alt="3.3"></p>
<p>也可以直接从启动文件处修改</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/3.4.jpg" alt="3.4"></p>
<h3 id="3-3-3-底层适配-diskio-c"><a href="#3-3-3-底层适配-diskio-c" class="headerlink" title="3.3.3 底层适配 diskio.c"></a>3.3.3 底层适配 diskio.c</h3><p>需要适配的函数如下</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/2.8.jpg" alt="2.8"></p>
<p><strong>第一步：设备编号定义</strong></p>
<p>这里只有一个设备（SD卡），把<code>DEV_MMC</code>编号改为<strong>0</strong>。（要求从0开始按顺序增加）</p>
<p>其他的可以按顺序编号，当然也可以直接删掉。但是为了以后增加，建议保留。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Definitions of physical drive number for each drive */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_RAM		1	<span class="comment">/* Example: Map Ramdisk to physical drive 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_MMC		0	<span class="comment">/* Example: Map MMC/SD card to physical drive 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_USB		2	<span class="comment">/* Example: Map USB MSD to physical drive 2 */</span></span></span><br></pre></td></tr></table></figure>

<p>这里名字其实是可以改的，比如改为（正点原子就是这样的）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SD_CARD	 	0  			<span class="comment">// SD卡,卷标为0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EX_FLASH 	1			<span class="comment">// 外部spi flash,卷标为1</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果改了，下面的适配函数也都一样改就可以了。</p>
</blockquote>
<p><strong>第二步：添加头文件</strong></p>
<p>因为需要用到我们前面写好的驱动以及printf调试输出，把头文件添加进来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spi_sdcard.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br></pre></td></tr></table></figure>



<p><strong>第三步：函数适配</strong></p>
<p>这里直接默认返回OK，没什么问题，其他类型的设备注释掉即可。需要用的话再修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DSTATUS <span class="title function_">disk_status</span> <span class="params">(</span></span><br><span class="line"><span class="params">	BYTE pdrv		<span class="comment">/* Physical drive nmuber to identify the drive */</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DSTATUS stat;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> DEV_RAM :	<span class="comment">// 还没用到，先注释掉</span></span><br><span class="line">		<span class="comment">// result = RAM_disk_status();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> stat;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_MMC :</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 默认没什么问题</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_USB :	<span class="comment">// 还没用到，先注释掉</span></span><br><span class="line">		<span class="comment">// result = USB_disk_status();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> stat;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> STA_NOINIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化调用我们前面写好的驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">DSTATUS <span class="title function_">disk_initialize</span> <span class="params">(</span></span><br><span class="line"><span class="params">	BYTE pdrv				<span class="comment">/* Physical drive nmuber to identify the drive */</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DSTATUS stat;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> DEV_RAM :	<span class="comment">// 还没用到，先注释掉</span></span><br><span class="line">		<span class="comment">// result = RAM_disk_initialize();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> stat;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_MMC :</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(SD_Init() == <span class="number">0</span>)    <span class="comment">// SD_Init()是SD初始化函数，无错误返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> STA_NOINIT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_USB :	<span class="comment">// 还没用到，先注释掉</span></span><br><span class="line">		<span class="comment">// result = USB_disk_initialize();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> stat;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> STA_NOINIT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读扇区函数，一样的调用前面的驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">DRESULT <span class="title function_">disk_read</span> <span class="params">(</span></span><br><span class="line"><span class="params">	BYTE pdrv,		<span class="comment">/* Physical drive nmuber to identify the drive */</span></span></span><br><span class="line"><span class="params">	BYTE *buff,		<span class="comment">/* Data buffer to store read data */</span></span></span><br><span class="line"><span class="params">	LBA_t sector,	<span class="comment">/* Start sector in LBA */</span></span></span><br><span class="line"><span class="params">	UINT count		<span class="comment">/* Number of sectors to read */</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DRESULT res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> DEV_RAM :</span><br><span class="line">		<span class="comment">// translate the arguments here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// result = RAM_disk_read(buff, sector, count);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_MMC :</span><br><span class="line">		</span><br><span class="line">		res = (DRESULT) SD_ReadDisk(buff, sector, count);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(res)	<span class="comment">// 读出错</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;sd read error:%d\r\n&quot;</span>, res);</span><br><span class="line">			SD_Init();	<span class="comment">// 重新初始化SD卡</span></span><br><span class="line">			res =  (DRESULT) SD_ReadDisk(buff,sector,count);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_USB :</span><br><span class="line">		<span class="comment">// translate the arguments here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// result = USB_disk_read(buff, sector, count);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RES_PARERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写扇区函数，还是调用写好的驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">DRESULT <span class="title function_">disk_write</span> <span class="params">(</span></span><br><span class="line"><span class="params">	BYTE pdrv,			<span class="comment">/* Physical drive nmuber to identify the drive */</span></span></span><br><span class="line"><span class="params">	<span class="type">const</span> BYTE *buff,	<span class="comment">/* Data to be written */</span></span></span><br><span class="line"><span class="params">	LBA_t sector,		<span class="comment">/* Start sector in LBA */</span></span></span><br><span class="line"><span class="params">	UINT count			<span class="comment">/* Number of sectors to write */</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DRESULT res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> DEV_RAM :</span><br><span class="line">		<span class="comment">// translate the arguments here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// result = RAM_disk_write(buff, sector, count);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_MMC :</span><br><span class="line">		</span><br><span class="line">		res = (DRESULT) SD_WriteDisk((<span class="type">uint8_t</span> *)buff, sector, count);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(res)	<span class="comment">// 写出错</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;sd write error:%d\r\n&quot;</span>, res);</span><br><span class="line">			SD_Init();	<span class="comment">// 重新初始化SD卡</span></span><br><span class="line">			res = (DRESULT) SD_WriteDisk((<span class="type">uint8_t</span> *)buff, sector, count);			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_USB :</span><br><span class="line">		<span class="comment">// translate the arguments here</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// result = USB_disk_write(buff, sector, count);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// translate the reslut code here</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RES_PARERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">DRESULT <span class="title function_">disk_ioctl</span> <span class="params">(</span></span><br><span class="line"><span class="params">	BYTE pdrv,		<span class="comment">/* Physical drive nmuber (0..) */</span></span></span><br><span class="line"><span class="params">	BYTE cmd,		<span class="comment">/* Control code */</span></span></span><br><span class="line"><span class="params">	<span class="type">void</span> *buff		<span class="comment">/* Buffer to send/receive control data */</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	DRESULT res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pdrv) &#123;</span><br><span class="line">	<span class="keyword">case</span> DEV_RAM :</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process of the command for the RAM drive</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_MMC :</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span>(cmd)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_FS_READONLY == 0</span></span><br><span class="line">		    <span class="keyword">case</span> CTRL_SYNC:</span><br><span class="line">				res = RES_OK; </span><br><span class="line">		        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_USE_MKFS == 1</span></span><br><span class="line">		    <span class="keyword">case</span> GET_SECTOR_COUNT:</span><br><span class="line">		        *(DWORD*)buff = SD_GetSectorCount();</span><br><span class="line">		        res = RES_OK;</span><br><span class="line">		        <span class="keyword">break</span>;</span><br><span class="line">		    <span class="keyword">case</span> GET_BLOCK_SIZE:</span><br><span class="line">				*(WORD*)buff = <span class="number">8</span>;</span><br><span class="line">		        res = RES_OK;</span><br><span class="line">		        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_MAX_SS != FF_MIN_SS</span></span><br><span class="line">		    <span class="keyword">case</span> GET_SECTOR_SIZE:</span><br><span class="line">				*(DWORD*)buff = <span class="number">512</span>; </span><br><span class="line">		        res = RES_OK;</span><br><span class="line">		        <span class="keyword">break</span>;	 </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		    <span class="keyword">default</span>:</span><br><span class="line">		        res = RES_PARERR;</span><br><span class="line">		        <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> DEV_USB :</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process of the command the USB drive</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> RES_PARERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此文件的最后添加一个获取时间的函数，默认返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">get_fattime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;				 </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-4-验证-main-c"><a href="#3-3-4-验证-main-c" class="headerlink" title="3.3.4 验证 main.c"></a>3.3.4 验证 main.c</h3><p>把以下代码放在main函数中执行，如果成功执行，说明没问题。</p>
<blockquote>
<p>这里执行 f_res &#x3D; f_mount(&amp;fs, “0:”, 1)，标号0就是diskio.c开头定义的标号。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">FATFS fs;				<span class="comment">/* FatFs 文件系统对象 */</span></span><br><span class="line">FRESULT f_res;			<span class="comment">/* 文件操作结果 */</span></span><br><span class="line">BYTE work[FF_MAX_SS];</span><br><span class="line"></span><br><span class="line">FIL file;                       <span class="comment">/* 文件对象 */</span></span><br><span class="line">UINT fnum;                      <span class="comment">/* 文件成功读写数量 */</span></span><br><span class="line">BYTE ReadBuffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">/* 读缓冲区 */</span></span><br><span class="line">BYTE WriteBuffer[] = <span class="string">&quot;This is STM32 working with FatFs \r\n&quot;</span>;	<span class="comment">/* 写缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在外部 SD 卡挂载文件系统，文件系统挂载时会对 SD 卡初始化</span></span><br><span class="line"><span class="comment">// note:必须先要保证SD卡正常拥有FAT文件系统，如果没有会失败。</span></span><br><span class="line">   f_res = f_mount(&amp;fs, <span class="string">&quot;0:&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果没有文件系统就格式化创建创建文件系统 */</span></span><br><span class="line">   <span class="keyword">if</span>(f_res == FR_NO_FILESYSTEM)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;The SD card does not yet have a file system and is about to be formatted... \r\n&quot;</span>);</span><br><span class="line">       <span class="comment">/* 格式化 */</span></span><br><span class="line">	f_res = f_mkfs(<span class="string">&quot;0:&quot;</span>, <span class="literal">NULL</span>, work, <span class="keyword">sizeof</span>(work));	<span class="comment">/* Create a FAT volume */</span></span><br><span class="line">	</span><br><span class="line">       <span class="keyword">if</span>(f_res == FR_OK)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;The SD card successfully formatted the file system\r\n&quot;</span>);</span><br><span class="line">           <span class="comment">/* 格式化后，先取消挂载 */</span></span><br><span class="line">           f_res = f_mount(<span class="literal">NULL</span>, <span class="string">&quot;0:&quot;</span>, <span class="number">1</span>);</span><br><span class="line">           <span class="comment">/* 重新挂载 */</span></span><br><span class="line">           f_res = f_mount(&amp;fs, <span class="string">&quot;0:&quot;</span>, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;The format failed\r\n&quot;</span>);</span><br><span class="line">           <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(f_res != FR_OK)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;mount error : %d \r\n&quot;</span>, f_res);</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;mount sucess!!! \r\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------- 文件系统测试：写测试 -----------------------------*/</span></span><br><span class="line">   <span class="comment">/* 打开文件，如果文件不存在则创建它 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\r\n ****** Create and Open new text file objects with write access ****** \r\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">f_res = f_open(&amp;file, <span class="string">&quot;0:FatFs STM32cube.txt&quot;</span>, FA_CREATE_ALWAYS | FA_WRITE);</span><br><span class="line">   <span class="keyword">if</span>(f_res == FR_OK)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;open file sucess!!! \r\n&quot;</span>);</span><br><span class="line">       <span class="comment">/* 将指定存储区内容写入到文件内 */</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\r\n****** Write data to the text files ******\r\n&quot;</span>);</span><br><span class="line">       f_res = f_write(&amp;file, WriteBuffer, <span class="keyword">sizeof</span>(WriteBuffer), &amp;fnum);</span><br><span class="line">       <span class="keyword">if</span>(f_res == FR_OK)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;write file sucess!!! (%d)\r\n&quot;</span>, fnum);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;write Data : %s\r\n&quot;</span>, WriteBuffer);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;write file error : %d\r\n&quot;</span>, f_res);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* 不再读写，关闭文件 */</span></span><br><span class="line">       f_close(&amp;file);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;open file error : %d\r\n&quot;</span>, f_res);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*------------------- 文件系统测试：读测试 ------------------------------------*/</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\r\n****** Read data from the text files ******\r\n&quot;</span>);</span><br><span class="line">   f_res = f_open(&amp;file, <span class="string">&quot;0:FatFs STM32cube.txt&quot;</span>, FA_OPEN_EXISTING | FA_READ);</span><br><span class="line">   <span class="keyword">if</span>(f_res == FR_OK)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;open file sucess!!! \r\n&quot;</span>);</span><br><span class="line">       f_res = f_read(&amp;file, ReadBuffer, <span class="keyword">sizeof</span>(ReadBuffer), &amp;fnum);</span><br><span class="line">       <span class="keyword">if</span>(f_res == FR_OK)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;read sucess!!! (%d)\r\n&quot;</span>, fnum);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;read Data : %s\r\n&quot;</span>, ReadBuffer);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot; read error!!! %d\r\n&quot;</span>, f_res);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;open file error : %d\r\n&quot;</span>, f_res);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 不再读写，关闭文件 */</span></span><br><span class="line">   f_close(&amp;file);</span><br><span class="line">   <span class="comment">/* 不再使用文件系统，取消挂载文件系统 */</span></span><br><span class="line">   f_mount(<span class="literal">NULL</span>, <span class="string">&quot;0:&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="comment">/* 操作完成，停机 */</span></span><br></pre></td></tr></table></figure>



<p>其他 API 的使用参考 FATFS 官网：<a target="_blank" rel="noopener" href="http://elm-chan.org/fsw/ff/00index_e.html">http://elm-chan.org/fsw/ff/00index_e.html</a></p>
<h1 id="4-W25Q128-Q-SPI模式移植"><a href="#4-W25Q128-Q-SPI模式移植" class="headerlink" title="4. W25Q128 (Q)SPI模式移植"></a>4. W25Q128 (Q)SPI模式移植</h1><p>这里不同开发板与外部FALSH（W25Q128）的通信方式有一丢丢的区别。</p>
<p>两种流程是一样的，只有驱动部分有一丢丢区别。两个开发板都整一份。</p>
<h2 id="4-1-W25QXX系列芯片"><a href="#4-1-W25QXX系列芯片" class="headerlink" title="4.1 W25QXX系列芯片"></a>4.1 W25QXX系列芯片</h2><p>W25QXX系列芯片，共有八个引脚，可以使用不同的通信方式。</p>
<table>
<thead>
<tr>
<th align="center">引脚编号</th>
<th align="center">QSPI通信</th>
<th align="center">备注</th>
<th align="center">SPI通信</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">CS#</td>
<td align="center">片选引脚。低电平表示选中。</td>
<td align="center">CS#</td>
<td align="center">片选引脚。低电平表示选中。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">IO1</td>
<td align="center">数据线1，QSPI_BK1_IO1</td>
<td align="center">SO</td>
<td align="center">SPI数据输出接口</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">IO2</td>
<td align="center">数据线2，QSPI_BK1_IO2</td>
<td align="center">WP#</td>
<td align="center">硬件写保护引脚，输入高电平可以正常写入数据，输入低电平禁止写入。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">GND</td>
<td align="center">公共地</td>
<td align="center">GND</td>
<td align="center">公共地</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">IO0</td>
<td align="center">数据线0，QSPI_BK1_IO0</td>
<td align="center">SI</td>
<td align="center">SPI数据输入接口</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">CLK</td>
<td align="center">时钟线，QSPI_BK1_CLK</td>
<td align="center">CLK</td>
<td align="center">SPI时钟接口</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">IO3</td>
<td align="center">数据线3，QSPI_BK1_IO3</td>
<td align="center">HOLD</td>
<td align="center">状态保存接口，输入低电平禁止操作芯片，输入高电平可正常操作芯片。</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">VCC</td>
<td align="center">电源接口，2.7-3.6电源</td>
<td align="center">VCC</td>
<td align="center">电源接口，2.7-3.6电源</td>
</tr>
</tbody></table>
<p>以W25Q64为例，其容量规划如下：</p>
<table>
<thead>
<tr>
<th align="center">单位</th>
<th align="center">大小</th>
<th align="center">比例</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">页</td>
<td align="center">256字节</td>
<td align="center">最小单位</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">扇区</td>
<td align="center">4K字节（4096字节）</td>
<td align="center">1扇区&#x3D;16个页</td>
<td align="center">2048个</td>
</tr>
<tr>
<td align="center">块</td>
<td align="center">64K字节</td>
<td align="center">1块&#x3D;16个扇区</td>
<td align="center">128个</td>
</tr>
</tbody></table>
<p>其总容量为 64 * 1024 * 128 &#x3D; 8388608字节 &#x3D; 8192K字节 &#x3D; 8M 字节。</p>
<p>对于W25Q128，其共拥有256个块，总容量就为 16M 字节。</p>
<blockquote>
<p>芯片每次最小擦写单位为一个扇区，即4K字节。</p>
</blockquote>
<h2 id="4-2-创建工程"><a href="#4-2-创建工程" class="headerlink" title="4.2 创建工程"></a>4.2 创建工程</h2><p>使用CubeMX创建一个工程。需要配置的项目有：</p>
<ul>
<li>时钟</li>
<li>程序调试接口</li>
<li>串口（用于观察调试信息）</li>
<li>(Q)SPI。这里需要根据不同的通讯方式创建工程。</li>
</ul>
<p>如果使用QSPI创建工程（潘多拉loT Board开发板），则配置如下：</p>
<p><img src="/2025/01/01/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/fatfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/4.1.jpg" alt="4.1"></p>
<p>得到的初始化代码如下：</p>
<p>其中代码生成后需要手动修改的为：<strong>hqspi.Init.FlashSize</strong>，根据使用的Flash的大小修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_QUADSPI_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  hqspi.Instance = QUADSPI;</span><br><span class="line">  hqspi.Init.ClockPrescaler = <span class="number">0</span>;	<span class="comment">// QPSI分频比，W25Q128最大频率为104M，这里为80MHz</span></span><br><span class="line">  hqspi.Init.FifoThreshold = <span class="number">4</span>;		<span class="comment">// FIFO阈值为4个字节</span></span><br><span class="line">  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;	<span class="comment">// 采样移位半个周期(DDR模式下,必须设置为0)</span></span><br><span class="line">  hqspi.Init.FlashSize = POSITION_VAL(<span class="number">0x1000000</span>)<span class="number">-1</span>;		<span class="comment">// SPI FLASH大小，W25Q128大小为16M字节</span></span><br><span class="line">  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_4_CYCLE;	<span class="comment">// 片选高电平时间为4个时钟(12.5*4=50ns),即手册里面的tSHSL参数</span></span><br><span class="line">  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;	<span class="comment">// 模式0</span></span><br><span class="line">  <span class="keyword">if</span> (HAL_QSPI_Init(&amp;hqspi) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



























<h1 id="5-多磁盘移植"><a href="#5-多磁盘移植" class="headerlink" title="5. 多磁盘移植"></a>5. 多磁盘移植</h1><p>这里我们直接在第三章的基础上改。</p>
<p><strong>第一步：创建工程</strong>根据两种存储介质配置相应的接口。</p>
<p><strong>第二步：添加每种存储介质的驱动、FATFS的源码</strong></p>
<p><strong>第三步：修改配置文件 ffconf.h</strong></p>
<p>相较于上面的配置，需要修改的有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FF_VOLUMES		1	<span class="comment">// 有几个存储介质，这里就改为几（1-10）</span></span></span><br></pre></td></tr></table></figure>

<p><strong>第四步：修改底层接口 diskio.c</strong></p>
<p>设备定义。有几个就写几个，名字可以自己拟，但是标号要从0开始，这个标号就是挂载时的编号。</p>
<blockquote>
<p>如果自拟了名字，那后面的函数中switch (pdrv) 的选项名字要对应的改一下</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Definitions of physical drive number for each drive */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_RAM		1	<span class="comment">/* Example: Map Ramdisk to physical drive 0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_MMC		0	<span class="comment">/* Example: Map MMC/SD card to physical drive 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_USB		2	<span class="comment">/* Example: Map USB MSD to physical drive 2 */</span></span></span><br></pre></td></tr></table></figure>

<p>其他需要配置的接口如下，直接照抄上面，在需要的 case 中添加对应存储介质的实现即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DSTATUS <span class="title function_">disk_status</span> <span class="params">(BYTE pdrv)</span>;</span><br><span class="line">DSTATUS <span class="title function_">disk_initialize</span> <span class="params">(BYTE pdrv)</span>;</span><br><span class="line">DRESULT <span class="title function_">disk_read</span> <span class="params">(BYTE pdrv, BYTE *buff, LBA_t sector,	UINT count)</span>;</span><br><span class="line">DRESULT <span class="title function_">disk_write</span> <span class="params">(BYTE pdrv, BYTE *buff, LBA_t sector, UINT count)</span>;</span><br><span class="line">DRESULT <span class="title function_">disk_ioctl</span> <span class="params">(BYTE pdrv, BYTE cmd, <span class="type">void</span> *buff)</span>;</span><br><span class="line">DWORD <span class="title function_">get_fattime</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>第五步：挂载</strong></p>
<p>有几个存储设备，就挂载几个。其余操作和原来的一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FATFS fs0, fs1;</span><br><span class="line">f_res = f_mount(&amp;fs0, <span class="string">&quot;0:&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>()	<span class="comment">// 判断是否成功</span></span><br><span class="line">&#123;    </span><br><span class="line">&#125;</span><br><span class="line">f_res = f_mount(&amp;fs1, <span class="string">&quot;1:&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>()	<span class="comment">// 判断是否成功</span></span><br><span class="line">&#123;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















































</article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文由 imhaozi 编写，采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2025/06/01/10.%20%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86/%E5%85%85%E7%94%B5%E6%A1%A9%E5%9B%BD%E6%A0%87/">充电桩国标协议解析</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/10/08/05.%20%E5%BC%80%E6%BA%90%E5%BA%93/lvgl%E7%A7%BB%E6%A4%8D/">lvgl移植</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">imhaozi</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E7%A7%BB%E6%A4%8D"><span class="toc-text">第一部分：移植</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%87%86%E5%A4%87%E6%BA%90%E7%A0%81"><span class="toc-text">1. 准备源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-TF%E5%8D%A1-SDIO-%E6%A8%A1%E5%BC%8F%E7%A7%BB%E6%A4%8D-%E5%B0%9A%E6%9C%89%E9%97%AE%E9%A2%98%E6%9C%AA%E8%A7%A3%E5%86%B3"><span class="toc-text">2. TF卡 SDIO 模式移植(尚有问题未解决)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-text">2.1 创建工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-SD%E5%8D%A1%E8%AF%BB%E5%86%99%E9%AA%8C%E8%AF%81"><span class="toc-text">2.2 SD卡读写验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-sdio-sdcard-h"><span class="toc-text">2.2.1 sdio_sdcard.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-sdio-sdcard-c"><span class="toc-text">2.2.2 sdio_sdcard.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-main-c"><span class="toc-text">2.2.3 main.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%A7%BB%E6%A4%8D-FATFS-%E7%B3%BB%E7%BB%9F"><span class="toc-text">2.3 移植 FATFS 系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E6%B7%BB%E5%8A%A0%E6%BA%90%E7%A0%81"><span class="toc-text">2.3.1 添加源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE-ffconf-h"><span class="toc-text">2.3.2 修改配置 ffconf.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%BA%95%E5%B1%82%E9%80%82%E9%85%8D-diskio-c"><span class="toc-text">2.3.3 底层适配 diskio.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E9%AA%8C%E8%AF%81-main-c"><span class="toc-text">2.3.4 验证 main.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-TF%E5%8D%A1-SPI-%E6%A8%A1%E5%BC%8F%E7%A7%BB%E6%A4%8D"><span class="toc-text">3. TF卡 SPI 模式移植</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-text">3.1 创建工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-SD%E5%8D%A1%E8%AF%BB%E5%86%99%E9%AA%8C%E8%AF%81"><span class="toc-text">3.2 SD卡读写验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-spi-sdcard-h"><span class="toc-text">3.2.1 spi_sdcard.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-spi-sdcard-c"><span class="toc-text">3.2.2 spi_sdcard.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-main-c"><span class="toc-text">3.2.3 main.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%A7%BB%E6%A4%8D-FATFS-%E7%B3%BB%E7%BB%9F"><span class="toc-text">3.3 移植 FATFS 系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%B7%BB%E5%8A%A0%E6%BA%90%E7%A0%81"><span class="toc-text">3.3.1 添加源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE-ffconf-h"><span class="toc-text">3.3.2 修改配置 ffconf.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%BA%95%E5%B1%82%E9%80%82%E9%85%8D-diskio-c"><span class="toc-text">3.3.3 底层适配 diskio.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E9%AA%8C%E8%AF%81-main-c"><span class="toc-text">3.3.4 验证 main.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-W25Q128-Q-SPI%E6%A8%A1%E5%BC%8F%E7%A7%BB%E6%A4%8D"><span class="toc-text">4. W25Q128 (Q)SPI模式移植</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-W25QXX%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87"><span class="toc-text">4.1 W25QXX系列芯片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-text">4.2 创建工程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%A4%9A%E7%A3%81%E7%9B%98%E7%A7%BB%E6%A4%8D"><span class="toc-text">5. 多磁盘移植</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
