[{"title":"ros1小车diy记录","path":"/2025/11/15/04. Linux应用/TspRosCar/","content":"1. 泰山派设置1.1 官方镜像从官方资料中下载Ubuntu20系统镜像ubuntu20.04_hdmi_20231130_update.img，并按照官方教程烧录。 镜像地址：https://wiki.lckfb.com/zh-hans/tspi-rk3566/download-center.html 烧录完成后，板子上就有Ubuntu系统了。 1.2 内核修改默认镜像中仅引出一个用户可以使用的串口，上位机需要的端口如下： 下位机通信，串口 雷达通信，串口 最基础的功能，控制下位机控制、雷达通信还差一个串口。 因此需要修改内核配置： 编译过程参考：https://wiki.lckfb.com/zh-hans/tspi-rk3566/project-case/fat-little-cell-phone/sdk-compile.html 文件需要做的修改如下： 调试串口波特率修改（非必须） 找到下面这个文件 tsp/kernel/arch/arm64/boot/dts/rockchip/tspi-rk3566-core-v10.dtsi 修改下面这段，把调试串口波特率从1500000修改位115200。非必须。 fiq-debugger compatible = rockchip,fiq-debugger;\trockchip,serial-id = 2;\trockchip,wake-irq = 0;\t/* If enable uart uses irq instead of fiq */\trockchip,irq-mode-enable = 1;\trockchip,baudrate = 115200; /* Only 115200 and 1500000 */\tinterrupts = GIC_SPI 252 IRQ_TYPE_LEVEL_LOW;\tpinctrl-names = default;\tpinctrl-0 = uart2m0_xfer;\tstatus = okay;; 添加一个串口（必须） 板子上引出的排针功能定义如下，选择一个合适的串口使用，此处使用串口5。 引脚定义：https://wiki.lckfb.com/zh-hans/tspi-rk3566/documentation/io-allocation-table.html 找到下面这个文件 tsp/kernel/arch/arm64/boot/dts/rockchip/tspi-rk3566-user-v10-linux.dts 找到串口3的位置，将其复制一份，然后将3修改为5即可。 //用户串口3uart3 status = okay;\tpinctrl-names = default;\tpinctrl-0 = uart3m1_xfer;;//用户串口5（新添加的）uart5 status = okay;\tpinctrl-names = default;\tpinctrl-0 = uart5m1_xfer;; 然后按照教程中的步骤，只编译内核，生成boot.img文件即可，然后单独将boot.img烧录进板子。 烧录方法同样参考官方资料，比较简单。 烧录完成之后，板子上就的串口5就也可以用了，可以先接个串口工具试试能不能使用串口5收发数据。 1.3 空间分配镜像烧录后，16G的EMMC空间有很大一部分都是空闲的，不能被直接使用，可用的空间还不够安装ROS的，因此需要将空闲的空间重新分配一下。 以下步骤需要将泰山派连接屏幕，下面的图片是最早的时候拍的，如果你按照我的流程生成的镜像，用户名可能不是这个。 在shell窗口中安装分配工具 sudo apt-get install gparted 使用下面命令启动磁盘分配工具，将磁盘oem和userdata右键取消挂载，再右键删除。 sudo gparted 将删除掉的空间分配给rootfs，右键选择Resize。 完成之后，即可看到效果，点击对号应用即可。 查看磁盘空间，已分配完成。 1.4 安装SSH更新包 sudo apt-get update 安装服务 sudo apt-get install openssh-server 提示依赖关系不对时，提示需要哪个版本就安装哪个版本。 安装完成之后，将泰山派连接一个WIFI，使用ifconfig命令查看一下板子的IP地址，并记录一下。 ifconfig 1.5 安装ROS这里使用小鱼的一键安装，方便省力。 wget http://fishros.com/install -O fishros bash fishros lckfb@MiWiFi-R3GV2-srv:~$lckfb@MiWiFi-R3GV2-srv:~$ wget http://fishros.com/install -O fishros bash fishros--2025-05-24 16:05:00-- http://fishros.com/install# 省略一堆文字# 等待弹出选项ROS相关: [1]:一键安装(推荐):ROS(支持ROS/ROS2,树莓派Jetson) [3]:一键安装:rosdep(小鱼的rosdepc,又快又好用) [4]:一键配置:ROS环境(快速更新ROS环境设置,自动生成环境选择) [9]:一键安装:Cartographer(18 20测试通过,16未测. updateTime 20240125) [11]:一键安装:ROS Docker版(支持所有版本ROS/ROS2) [16]:一键安装：系统自带ROS (！！警告！！仅供特殊情况下使用)常用软件: [2]:一键安装:github桌面版(小鱼常用的github客户端) [6]:一键安装:NodeJS环境 [7]:一键安装:VsCode开发工具 [8]:一键安装:Docker [10]:一键安装:微信(可以在Linux上使用的微信) [12]:一键安装:PlateformIO MicroROS开发环境(支持Fishbot) [15]:一键安装：QQ for Linux配置工具: [5]:一键配置:系统源(更换系统源,支持全版本Ubuntu系统) [13]:一键配置:python国内源 [17]:一键配置: Docker代理(支持VPN+代理服务两种模式)[0]:quit请输入[]内的数字以选择:1# 输入1 选择安装ros# 省略一堆文字# 等待弹出选项RUN Choose Task:[请输入括号内的数字]新手或首次安装一定要一定要一定要换源并清理三方源，换源!!!系统默认国外源容易失败!![1]:更换系统源再继续安装[2]:不更换继续安装[0]:quit请输入[]内的数字以选择:1RUN Choose Task:[请输入括号内的数字]请选择换源方式,如果不知道选什么请选2[1]:仅更换系统源[2]:更换系统源并清理第三方源[0]:quit请输入[]内的数字以选择:2# 分别输入1、2# 省略一堆文字# 等待弹出选项RUN Choose Task:[请输入括号内的数字]请选择你要安装的ROS版本名称(请注意ROS1和ROS2区别):[1]:foxy(ROS2)[2]:galactic(ROS2)[3]:noetic(ROS1)[4]:rolling(ROS2)[0]:quit请输入[]内的数字以选择:3RUN Choose Task:[请输入括号内的数字]请选择安装的具体版本(如果不知道怎么选,请选1桌面版):[1]:noetic(ROS1)桌面版[2]:noetic(ROS1)基础版(小)[0]:quit请输入[]内的数字以选择:1# 分别输入3、1；这里很重要安装的版本一定不要选错# 然后开始等待 等待一段时间后，第一次提示软件包依赖不对，这里先敲回车继续。 ============================================================请注意我，检测你在安装过程中出现依赖问题，请在稍后输入n,再选择y,即可解决（若无法解决，清在稍后手动运行命令: sudo aptitude install ros-noetic-desktop-full)确认了解情况，请输入回车继续安装# 第一次弹出上面的框，直接敲回车继续# 片刻后，第一次弹出推荐方案。是否接受该解决方案？[Y/n/q/?] n# 输入n敲回车，拒绝第一次的方案。# 片刻后，第二次弹出推荐方案。是否接受该解决方案？[Y/n/q/?] Y# 输入Y敲回车，接收第二次的方案。# 片刻后，弹出要安装的包需要确认。40 个软件包被升级，新安装 1025 个， 1 个将被删除， 同时 199 个将不升级。需要获取 575 MB 的存档。 解包后将要使用 3,812 MB。您要继续吗？[Y/n/?] Y# 输入Y确认即可。# 然后就是漫长漫长漫长漫长漫长漫长的等待# 最后看到下面这句话 就安装完成了恭喜你，安装成功了，再附赠你机器人学习宝藏网站：鱼香社区:https://fishros.org.cn/forumRun CMD Task:[ls /opt/ros/noetic/setup.bash][-][0.01s] CMD Result:success小鱼，黄黄的提示：您安装的是ROS1，可以打开一个新的终端输入roscore测试！ 如果，这里第二次接受方案，然后往下走还是报错了，那就从头来，然后前两次都拒绝，第三次再接受。如果还失败，就再从头来，第四次再接受。 安装完成后，重新起一个终端，输入roscore指令，能看到如下信息，就表示ros安装完成了。 lckfb@MiWiFi-R3GV2-srv:~$ roscore... logging to /home/lckfb/.ros/log/1647e6b0-38bd-11f0-b3d3-b81332af56be/roslaunch-MiWiFi-R3GV2-srv-16753.logChecking log directory for disk usage. This may take a while.Press Ctrl-C to interruptDone checking log file disk usage. Usage is 1GB.started roslaunch server http://MiWiFi-R3GV2-srv:35197/ros_comm version 1.17.3SUMMARY========PARAMETERS * /rosdistro: noetic * /rosversion: 1.17.3NODESauto-starting new masterprocess[master]: started with pid [16761]ROS_MASTER_URI=http://MiWiFi-R3GV2-srv:11311/setting /run_id to 1647e6b0-38bd-11f0-b3d3-b81332af56beprocess[rosout-1]: started with pid [16771]started core service [/rosout] 1.6 安装Vscode 已经有经验的话，不需要频繁修改就可以不用装了。 我这里刚开始调试的时候装了，后来基础硬件调试完之后，重新烧录过系统，就没再安装了，在虚拟机中修改之后，再把代码放过去编译。 其实这个开发板跑Vscode只能将就，但是主要开发过程中需要不断改，装一个还是方便一点。 安装完成后，Vscode中安装个ssh插件，就可以在电脑上编辑开发板中的代码了。 Vscode其实相对好装，但是这里还是使用一键安装命令，省时省力。 wget http://fishros.com/install -O fishros bash fishros lckfb@MiWiFi-R3GV2-srv:~$ wget http://fishros.com/install -O fishros bash fishros--2025-05-25 08:07:07-- http://fishros.com/install# 稍等片刻，然后选择数字7即可ROS相关: [1]:一键安装(推荐):ROS(支持ROS/ROS2,树莓派Jetson) [3]:一键安装:rosdep(小鱼的rosdepc,又快又好用) [4]:一键配置:ROS环境(快速更新ROS环境设置,自动生成环境选择) [9]:一键安装:Cartographer(18 20测试通过,16未测. updateTime 20240125) [11]:一键安装:ROS Docker版(支持所有版本ROS/ROS2) [16]:一键安装：系统自带ROS (！！警告！！仅供特殊情况下使用)常用软件: [2]:一键安装:github桌面版(小鱼常用的github客户端) [6]:一键安装:NodeJS环境 [7]:一键安装:VsCode开发工具 [8]:一键安装:Docker [10]:一键安装:微信(可以在Linux上使用的微信) [12]:一键安装:PlateformIO MicroROS开发环境(支持Fishbot) [15]:一键安装：QQ for Linux配置工具: [5]:一键配置:系统源(更换系统源,支持全版本Ubuntu系统) [13]:一键配置:python国内源 [17]:一键配置: Docker代理(支持VPN+代理服务两种模式)[0]:quit请输入[]内的数字以选择:7# 然后等待安装完成即可 1.7 权限设置1.7.1 串口权限两个串口/dev/ttyS3和/dev/ttyS5使用普通用户登录默认都是没有操作权限的，在代码里不方便操作。 因此这里永久修改一下权限。 # 创建udev规则文件sudo vi /etc/udev/rules.d/99-serial-ports.rules 添加以下内容 KERNEL==ttyS3, MODE=0666KERNEL==ttyS5, MODE=0666 添加完成后重新加载 # 重新加载udev规则sudo udevadm control --reload-rulessudo udevadm trigger# 或者重启系统使规则生效sudo reboot 查看串口权限，可以看到有读写权限了 lckfb@MiWiFi-R3GV2-srv:~/ros1-car-ws$ ls -l /dev/ttyS5crw-rw-rw- 1 root dialout 4, 69 11月 28 14:21 /dev/ttyS5lckfb@MiWiFi-R3GV2-srv:~/ros1-car-ws$ ls -l /dev/ttyS3crw-rw-rw- 1 root dialout 4, 67 11月 28 14:21 /dev/ttyS3 1.7.2 IO引脚风扇和雷达供电控制引脚上电后默认也是没有操作权限的。 lckfb@MiWiFi-R3GV2-srv:~$ echo 36 /sys/class/gpio/export-bash: /sys/class/gpio/export: 权限不够lckfb@MiWiFi-R3GV2-srv:~$ sudo echo 36 /sys/class/gpio/export-bash: /sys/class/gpio/export: 权限不够 创建gpio用户组 sudo groupadd gpio # 创建组（如果不存在）sudo usermod -a -G gpio $USER # 将当前用户加入 gpio 组 创建文件 sudo vi /etc/udev/rules.d/99-gpio.rules 添加以下内容 # Set permissions for GPIO sysfs interfaceSUBSYSTEM==gpio, KERNEL==gpiochip*, ACTION==add, PROGRAM=/bin/sh -c chown -R root:gpio /sys/class/gpio chmod -R 775 /sys/class/gpioSUBSYSTEM==gpio, KERNEL==gpio*, ACTION==add, PROGRAM=/bin/sh -c chown -R root:gpio /sys/class/gpio/gpio* chmod -R 775 /sys/class/gpio/gpio* 添加完成后重新加载 # 重新加载udev规则sudo udevadm control --reload-rulessudo udevadm trigger --subsystem-match=gpiosudo reboot 查看分组，可以看到gpio lckfb@MiWiFi-R3GV2-srv:~$ groupslckfb sudo audio video gpio 然后重新测试就可以了。 1.7.3 摄像头权限执行以下命令，重启生效。 # 添加权限sudo usermod -aG video $USER# 或者重启系统使规则生效sudo reboot 重启完成之后，执行以下命令，看到有video输出即表示成功。 lckfb@MiWiFi-R3GV2-srv:~$ groupslckfb sudo audio video 2. 下位机开发（Base）下位机相对来说核心逻辑比较简单，一共需要实现以下功能： 串口接收上位机发送的目标电机速度，使用PID调节电机速度，保持速度稳定； 获取电机编码器值、电池电量，通过串口定时上报； 2.1 目标速度控制这里速度控制使用5ms的定时器中断完成，并且每4次中断，上报一次编码器和电池电压数据。 核心处理逻辑就是下面这个函数 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\t// 这个回调函数 是共用的，因此需要先判断，是不是定时器2 if(htim-Instance == htim1.Instance) /* 实际上 因为编码器接线差异 导致编码器数值增加的方向不一定是电机正转的方向 这里测试结果： 右电机正转（顺时针，小车往前走）编码器值从0加，反转（逆时针，小车往后退）往后退是从65535减 左电机反转（逆时针，小车往前走）编码器值从0加，正转（顺时针，小车往后退）往后退是从65535减 也就是：左右轮都是 编码器值从0加是小车往前走 但是这里需要都处理为顺时针正转时，编码器值增加。 ROS就是规范~~~ */ // 获取左右电机编码器计数 这里测试都是前进方向是从0加 后退方向是从65535减 int32_t right_encoder_diff = __HAL_TIM_GET_COUNTER(htim2); int32_t left_encoder_diff = __HAL_TIM_GET_COUNTER(htim4); // 方向处理 得到的速度都是电机正转的速度（右电机往前走 左电机往后走） // 右轮 编码器值增加的方向就是电机正向旋转的方向 也是前进的方向(100表示正转了100 65535表示反转了1，需要处理为-1) if(right_encoder_diff 30000) right_encoder_diff = right_encoder_diff - 65536; // 左轮 编码器值增加的方向就是电机反向旋转的方向 也是前进的方向(100表示反转了100，需要处理为-100，65535表示正转了1) if(left_encoder_diff 30000) left_encoder_diff = 65536 - left_encoder_diff; else left_encoder_diff = 0 - left_encoder_diff; // 清除计数 __HAL_TIM_SET_COUNTER(htim2, 0); __HAL_TIM_SET_COUNTER(htim4, 0); // 编码器值累加（用于上报编码器值） left_encoder_count += left_encoder_diff; right_encoder_count += right_encoder_diff; // 计算为速度 // 电机一圈7个脉冲 减速比50 也就是一圈350个脉冲 上下边沿都检测 一圈计数值为 350 * 4 = 1400 // 圈数 = 编码器值 / 1400 // 旋转的弧度 = 圈数 * 2PI // 电机速度(rad/s) = 旋转的弧度 / 0.005 = 圈数 * 2PI / 0.005 = 编码器值 / 1400 * 2PI / 0.005 // 电机速度(rad/s) = 编码器值 * 6.2831852 / 7 float left_speed = (float)left_encoder_diff * 6.2831852 / 7; float right_speed = (float)right_encoder_diff * 6.2831852 / 7; // 滤波 left_speed = left_speed * 0.3 + real_left_speed * 0.7; right_speed = right_speed * 0.3 + real_right_speed * 0.7; // PID闭环计算 float left_out = pic_ctrl(left_pid, target_left_speed, left_speed); float right_out = pic_ctrl(right_pid, target_right_speed, right_speed); // 设置 if(left_out = 0)\t// 正转 HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_7, GPIO_PIN_SET); __HAL_TIM_SET_COMPARE(htim3, TIM_CHANNEL_3, left_out); else // 反转 HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_7, GPIO_PIN_RESET); __HAL_TIM_SET_COMPARE(htim3, TIM_CHANNEL_3, -left_out); if(right_out = 0)\t// 正转 HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET); __HAL_TIM_SET_COMPARE(htim3, TIM_CHANNEL_1, right_out); else // 反转 HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET); __HAL_TIM_SET_COMPARE(htim3, TIM_CHANNEL_1, -right_out); #if PID_DEBUG_NEED // 数据顺序（tar real kp ki kd）// float send_data[5] = target_left_speed, left_speed, left_pid.kp, left_pid.ki, left_pid.kd; float send_data[5] = target_right_speed, right_speed, right_pid.kp, right_pid.ki, right_pid.kd; debug_data_send(send_data, 5);#else status_send_count++; if(status_send_count = 4) // 电池电压 uint16_t battery_vol_mv = (uint16_t)(battery_vol_read() * 1000); uint8_t send_data[10]; send_data[0] = R; send_data[1] = O; send_data[2] = S; send_data[3] = (left_encoder_count 0) 0xFF; send_data[4] = (left_encoder_count 8) 0xFF; send_data[5] = (right_encoder_count 0) 0xFF; send_data[6] = (right_encoder_count 8) 0xFF; send_data[7] = (battery_vol_mv 0) 0xFF; send_data[8] = (battery_vol_mv 8) 0xFF; send_data[9] = check_sum(send_data, 9); // 发送 if(upper_data_send(send_data, 10) == 0) // 清空累计值 left_encoder_count = 0; right_encoder_count = 0; // 清除计数 status_send_count = 0; #endif 2.2 目标速度获取解析上位机数据使用串口中断完成 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\t// 判断是不是串口1 中断\tif(huart-Instance == USART1)\t#if PID_DEBUG_NEED if(rx_buff[0] == 1) left_pid.kp = left_pid.kp + 10; else if(rx_buff[0] == 2) left_pid.kp = left_pid.kp - 10; if(rx_buff[0] == 3) left_pid.ki = left_pid.ki + 0.01; else if(rx_buff[0] == 4) left_pid.ki = left_pid.ki - 0.01; if(rx_buff[0] == 5) left_pid.kd = left_pid.kd + 0.01; else if(rx_buff[0] == 6) left_pid.kd= left_pid.kd - 0.01;#else if((rx_len == 0) (rx_buff[rx_len] != R)) rx_len = 0; else if((rx_len == 1) (rx_buff[rx_len] != O)) rx_len = 0; else if((rx_len == 2) (rx_buff[rx_len] != S)) rx_len = 0; else rx_len++; // 一包数据接收完了 if(rx_len = 8) // 校验 if(rx_buff[7] == check_sum(rx_buff, 7)) float left_speed = (float)((int16_t)((rx_buff[4] 8) | (rx_buff[3] 0))) / 1000; float right_speed = (float)((int16_t)((rx_buff[6] 8) | (rx_buff[5] 0))) / 1000; motor_write_speed(left_speed, right_speed); comm_count = 0; rx_len = 0; #endif // 重新使能接收中断 HAL_UART_Receive_IT(huart1, (uint8_t *)rx_buff[rx_len], 1); 2.3 状态显示另外添加了个LED显示功能，在main函数中处理。 正常情况下，下位机亮绿灯 发生通信超时，下位机亮红灯，并且停止移动 uint32_t last_led_time = HAL_GetTick();\t// led周期闪烁时间while (1) // 发送数据 uint32_t current_time = HAL_GetTick(); // LED状态 if((current_time - last_led_time) = 1000) // 五秒未收到上位机有效命令 comm_count++; if(comm_count 5) motor_write_speed(0, 0); led_write(LED_RED); else led_write(LED_GREEN); last_led_time = current_time; 3. 上位机开发（RosWs）主要规划和构建各个软件包的功能。 3.1 创建项目创建一个工作空间文件夹（就是一个工程文件夹） 工作空间中可以有多个软件包 软件包中又可以又多个节点 步骤1：创建工作空间 比如这里想创建一个小车项目，就可以创建下面的文件目录 Ros1CarWs src：存放代码，源代码、功能包等 创建一个Ros1CarWs目录作为本项目的工作空间。 haozi@computer:~/develop$ mkdir Ros1CarWshaozi@computer:~/develop$ cd Ros1CarWs/haozi@computer:~/develop/Ros1CarWs$ mkdir src 步骤2：创建软件包 在工作空间的src目录下可以有多个软件包。 因此需要在src目录下进行创建，切换到工作空间的src目录下，执行如下格式指令： catkin_create_pkg 包名 依赖项1 依赖项2 ... 比如，创建一个名叫test_pkg的包，指令如下： haozi@computer:~/develop/Ros1CarWs/src$ catkin_create_pkg test_pkg rospy roscpp std_msgs 执行完成后，在src目录下就会多出一个新的目录test_pkg，该目录就是一个包了，包里面又包含了多个文件。 haozi@computer:~/develop/Ros1CarWs/src$ lsCMakeLists.txt test_pkg wpr_simulationhaozi@computer:~/develop/Ros1CarWs/src$ cd test_pkg/haozi@computer:~/develop/Ros1CarWs/src/test_pkg$ lsCMakeLists.txt include package.xml src 步骤3：添加节点代码 在软件包的src目录下创建代码文件main.cpp #include ros/ros.hint main(int argc, char *argv[]) printf(test_pkg running~ ); // 后面的是节点名称 ros::init(argc, argv, test_node); while(ros::ok()) printf(test_node running~ ); sleep(1); return 0; 在这个包的CMakeLists.txt文件中，build部分，找到对应的注释的位置，添加如下两条（没注释掉的是添加的，注释掉的是原有的）。 ## Declare a C++ executable## With catkin_make all packages are built within a single CMake context## The recommended prefix ensures that target names across packages dont collide# add_executable($PROJECT_NAME_node src/test_pkg_node.cpp)add_executable(test_node src/main.cpp)## Specify libraries to link a library or executable target against# target_link_libraries($PROJECT_NAME_node# $catkin_LIBRARIES# )target_link_libraries(test_node $catkin_LIBRARIES) 其中： add_executable：表示需要编译可执行文件 target_link_libraries：表示需要链接ros库 步骤4：编译代码 在工作空间目录Ros1CarWs下执行编译命令 haozi@computer:~/develop/Ros1CarWs$ pwd/home/haozi/develop/Ros1CarWshaozi@computer:~/develop/Ros1CarWs$ catkin_make[100%] Linking CXX executable /home/haozi/develop/Ros1CarWs/devel/lib/test_pkg/test_node[100%] Built target test_node 编译完成后，工作空间下就会多出来两个文件夹，build、devel haozi@computer:~/develop/Ros1CarWs$ lsbuild devel src build：编译文件 devel：执行文件，执行前需要在这里添加源 步骤5：执行 启动一个新的终端，启动ros roscore 添加代码源（注意相对目录或者绝对目录） haozi@computer:~/develop/Ros1CarWs$ source devel/setup.bash 执行代码 # 命令格式：rosrun 包名 节点名haozi@computer:~/develop/Ros1CarWs$ rosrun test_pkg test_nodetest_pkg running~ test_node running~ test_node running~ test_node running~ 到这里，创建一个ros软件包并执行的流程就完成了。 还可以继续重复步骤2-5，就可以创建多个不同的软件包了。 步骤6：优化 每次打开终端总要source一下，可以修改配置，打开终端时自动source。 执行如下指令 haozi@computer:~$ gedit ~/.bashrc 在弹出的编辑器中，最后一行添加如下内容。 source ~/Ros1CarWs/devel/setup.bash 这样每次打开终端，就会自动执行这一行命令了。 不过这里我还是不用了。 3.2 电脑端可视化小车主控不具有可视化能力，需要借用电脑来进行可视化操作。 步骤1： 虚拟机网络设置为桥接模式（这样开发板和虚拟机才可以在一个网段下） 步骤2： 将电脑和开发板连接同一个wifi 步骤3： 查看电脑端和开发板IP地址和设备名 hostname 结果： 虚拟机 主机名：computer IP：192.168.31.28 开发板 主机名：MiWiFi-R3GV2-srv IP：192.168.31.35 步骤4： 编辑/etc/hosts文件，添加一行，添加对方的IP和主机名 开发板端 192.168.31.28 computer 电脑端 192.168.31.35 MiWiFi-R3GV2-srv 设置完成之后，分别ping对方的ip和主机名，应该都是可以ping通的。 步骤5： 这里将开发板作为ROS主机使用。编辑~/.bashrc文件，添加几行。 开发板端 # ROS网络配置export ROS_MASTER_URI=http://MiWiFi-R3GV2-srv:11311export ROS_HOSTNAME=MiWiFi-R3GV2-srv# 执行sourcesource ~/.bashrc 电脑端 # ROS网络配置export ROS_MASTER_URI=http://MiWiFi-R3GV2-srv:11311export ROS_HOSTNAME=computer# 执行sourcesource ~/.bashrc 然后在开发板端运行roscore及其他服务，在电脑端就可以使用相关命令看到状态了。 也可以直接将上面两行写入到这个文件，就不用每次打开终端都需要重新导入了。 这里就这么干了！！！ 3.3 下位机控制包（base_ctrl_pkg）本软件包主要实现以下功能： 订阅速度控制消息，解析为两个轮子的速度后，定时下发给下位机 解析两个轮子编码器值，计算里程计状态，发布里程计消息 3.3.1 速度订阅创建一个速度订阅者对象 tar_speed_sub_ = nh_.subscribe(/cmd_vel, 10, BaseCtrl::CmdVelCallback, this); // 订阅目标速度 回调函数中根据差速轮模型解析两个轮子速度 // 速度指令订阅回调函数void BaseCtrl::CmdVelCallback(const geometry_msgs::Twist::ConstPtr msg) // 解析为左右电机的速度 // ROS_INFO(tar linear = %f(m/s), angular = %f(rad/s) ~ , msg-linear.x, msg-angular.z); // 第一步：把小车的移动速度，计算为小车轮子的线速度 float left_linear = msg-linear.x - 0.5 * WHEEL_TRACK * msg-angular.z; float right_linear = msg-linear.x + 0.5 * WHEEL_TRACK * msg-angular.z; // 第二步：把轮子的线速度，计算为行走电机的旋转速度 float left_angular = left_linear / WHEEL_RADIUS; float right_angular = right_linear / WHEEL_RADIUS; // 转换为可以下发的单位 0.001倍 // 轮子向前线速度为正 轮子顺时针角速度为正 则左轮子的线速度和角速度符号是反的 h2l_data_.left_speed = (int16_t)(-left_angular * 1000); h2l_data_.right_speed = (int16_t)(right_angular * 1000); 在定时器的中断回调函数中定时调用以下函数，将目标速度发送给下位机 // 下位机命令定时发布void BaseCtrl::TimerUartSend() uint8_t send_data[8]; // 数据头 send_data[0] = R; send_data[1] = O; send_data[2] = S; // 电机速度 send_data[3] = (h2l_data_.left_speed 0) 0xFF; send_data[4] = (h2l_data_.left_speed 8) 0xFF; send_data[5] = (h2l_data_.right_speed 0) 0xFF; send_data[6] = (h2l_data_.right_speed 8) 0xFF; // 校验 send_data[7] = CheckSum(send_data, 7); // 发送 uart_.Write(send_data, 8); 测试效果 在小车上将base_ctrl_pkg节点运行起来，在虚拟机中利用现成的速度控制节点，就可以控制小车进行移动了。 rosrun rqt_robot_steering rqt_robot_steering 先完成这个功能，才能继续往下走 3.3.2 里程计发布创建一个发布者对象，用于发布里程计消息 odom_pub_ = nh_.advertisenav_msgs::Odometry(odom, 50); // 发布里程计数据 里程计消息的计算如下，相对好理解，此函数也是在定时器回调函数中调用。 // 里程计消息定时发布void BaseCtrl::TimerOdomPub() ros::Time current_time = ros::Time::now(); // 第一次运行则不计算 if (first_update_) last_encoder_.left = now_encoder_.left; last_encoder_.right = now_encoder_.right; last_update_time_ = current_time; first_update_ = 0; return; // 计算时间间隔(要说这里都已经用定时器了 其实这个时间间隔可以固定一个的) double dt = (current_time - last_update_time_).toSec(); if (dt = 0.001) ROS_WARN_THROTTLE(1.0, Time interval too small: %.3f s, dt); return; // 计算编码器增量(脉冲数) int64_t left_encoder_delta = now_encoder_.left - last_encoder_.left; int64_t right_encoder_delta = now_encoder_.right - last_encoder_.right; // 尽快更新编码器 防止计算过程中now_encoder_值更新 导致下一轮计算丢数 last_encoder_.left = now_encoder_.left; last_encoder_.right = now_encoder_.right; // 计算左右电机移动的距离(m) double left_distance = (double)left_encoder_delta / ENCODER_RESOLUTION * WHEEL_RADIUS * M_PI; double right_distance = (double)right_encoder_delta / ENCODER_RESOLUTION * WHEEL_RADIUS * M_PI; // 转换为统一方向 往前走是正 left_distance *= -1; right_distance *= 1; // 计算平均移动距离和方向变化 double delta_distance = (left_distance + right_distance) / 2.0; // 本次距离变化 double delta_theta = (right_distance - left_distance) / WHEEL_TRACK; // 本次角度变化 // 计算线速度(m/s)和角速度(rad/s) double linear_vel = delta_distance / dt; double angular_vel = delta_theta / dt; // ROS_INFO(left_encoder_delta=%d, right_encoder_delta=%d, left_encoder_delta, right_encoder_delta); // ROS_INFO(left_distance=%.4f m, right_distance=%.4f m, left_distance, right_distance); // ROS_INFO(delta_distance=%.4f m, delta_theta=%.4f rad, delta_distance, delta_theta); // ROS_INFO(linear_vel=%.4f m/s, angular_vel=%.4f rad/s, linear_vel, angular_vel); // ROS_INFO(-----------------); // 累计位置 x_ += delta_distance * cos(theta_ + delta_theta / 2); y_ += delta_distance * sin(theta_ + delta_theta / 2); // 累计角度 并标准化角度到 [-pi, pi] theta_ += delta_theta; while (theta_ M_PI) theta_ -= 2.0 * M_PI; while (theta_ -M_PI) theta_ += 2.0 * M_PI; // 发布数据 // 创建四元数从偏航角 tf2::Quaternion odom_quat; odom_quat.setRPY(0, 0, theta_); // 1. 发布里程计消息 nav_msgs::Odometry odom_msg; odom_msg.header.stamp = current_time; odom_msg.header.frame_id = odom; odom_msg.child_frame_id = base_footprint; // 设置位置 odom_msg.pose.pose.position.x = x_; odom_msg.pose.pose.position.y = y_; odom_msg.pose.pose.position.z = 0.0; // 设置姿态（四元数） odom_msg.pose.pose.orientation.x = odom_quat.x(); odom_msg.pose.pose.orientation.y = odom_quat.y(); odom_msg.pose.pose.orientation.z = odom_quat.z(); odom_msg.pose.pose.orientation.w = odom_quat.w(); // 设置位置协方差 // odom_msg.pose.covariance[0] = 0.1; // x // odom_msg.pose.covariance[7] = 0.1; // y // odom_msg.pose.covariance[35] = 0.2; // 偏航 // 设置速度 odom_msg.twist.twist.linear.x = linear_vel; odom_msg.twist.twist.linear.y = 0; odom_msg.twist.twist.angular.z = angular_vel; // 速度协方差 // odom_msg.twist.covariance[0] = 0.1; // vx // odom_msg.twist.covariance[7] = 0.0; // vy // odom_msg.twist.covariance[14] = 0.0; // vz // odom_msg.twist.covariance[21] = 0.0; // 滚转角速度 // odom_msg.twist.covariance[28] = 0.0; // 俯仰角速度 // odom_msg.twist.covariance[35] = 0.2; // 偏航角速度 // 发布里程计消息 odom_pub_.publish(odom_msg); // 2. 发布TF变换: odom - base_link geometry_msgs::TransformStamped odom_trans; odom_trans.header.stamp = current_time; odom_trans.header.frame_id = odom; odom_trans.child_frame_id = base_footprint; odom_trans.transform.translation.x = x_; odom_trans.transform.translation.y = y_; odom_trans.transform.translation.z = 0.0; odom_trans.transform.rotation.x = odom_quat.x(); odom_trans.transform.rotation.y = odom_quat.y(); odom_trans.transform.rotation.z = odom_quat.z(); odom_trans.transform.rotation.w = odom_quat.w(); // 发布TF变换 tf_broadcaster_.sendTransform(odom_trans); // 更新上一时刻数据 last_update_time_ = current_time; 测试效果 在小车上将base_ctrl_node节点运行起来，在虚拟机中利用现成的速度控制节点，控制小车移动，或者手推着小车走也是可以的，让小车可以读到轮子的编码器数据即可。 在虚拟机中运行rviz，add添加里程计选项，并且将话题修改为/odom，全局设置中Fixed Frame也修改为odom，即可看到里程计运动效果 rosrun rviz rviz 3.4 雷达消息包（lidar_pkg）本软件包主要实现以下功能： 接收雷达数据，将雷达原始数据解析为雷达话题数据并发布 创建一个新的软件包lidar_pkg，用于发布雷达数据。 haozi@computer:~/develop/Ros1CarWs/src$ catkin_create_pkg lidar_pkg rospy roscpp std_msgs sensor_msgs 创建一个地图发布者对象 laser_pub_ = nh_.advertisesensor_msgs::LaserScan(/scan, 10); 雷达数据读取如下，按照雷达数据长度格式，获取到一包数据长度即可。 // 接收一包雷达数据int Lidar::ReadLidarData(lidar_data_t lidar_data) /* 雷达数据格式 参考lidar_data数据类型定义 */ int len; uint8_t recv_buff[100]; // 接收数据头 找第一个字节 最多尝试100次 uint8_t i = 0; while (1) len = uart_.Read(recv_buff, 1); if ((len == 1) (recv_buff[0] == 0xAA)) len = uart_.Read(recv_buff, 1); if ((len == 1) (recv_buff[0] == 0x55)) break; // 找到数据头了 else ROS_INFO(find data header2 failed. ); return -2; // 未找到数据头第2个字节 if (i++ 100) ROS_INFO(find data header1 failed. ); return -1; // 未找到数据头第1个字节 lidar_data.header[0] = 0xAA; lidar_data.header[1] = 0x55; // 包类型 len = uart_.Read(recv_buff, 1); if (len == 1) if ((recv_buff[0] != 0) (recv_buff[0] != 1)) ROS_INFO(ct out range %d. , recv_buff[0]); return -3; lidar_data.ct = recv_buff[0]; else ROS_INFO(find data ct failed. ); return -4; // 采样点数量 len = uart_.Read(recv_buff, 1); if (len == 1) if ((recv_buff[0] 1) || (recv_buff[0] 25)) ROS_INFO(lsn out range %d. , recv_buff[0]); return -5; lidar_data.lsn = recv_buff[0]; else ROS_INFO(find data lsn failed. ); return -6; // 剩下 起始角度2字节 结束角度2字节 校验2字节 采样数据2*lsn字节 uint8_t read_len = 0; uint8_t need_len = 6 + 2 * lidar_data.lsn; len = uart_.Read((recv_buff[read_len]), need_len); if (len need_len) // 继续读剩下的 read_len = read_len + len; need_len = need_len - len; len = uart_.Read((recv_buff[read_len]), need_len); if (len need_len) // 继续读剩下的 read_len = read_len + len; need_len = need_len - len; len = uart_.Read((recv_buff[read_len]), need_len); if (len need_len) ROS_INFO(find data si failed. len=%d, lsn=%d., read_len, lidar_data.lsn); return -7; lidar_data.fsa = ((recv_buff[1] 8) | recv_buff[0]); lidar_data.lsa = ((recv_buff[3] 8) | recv_buff[2]); lidar_data.cs = ((recv_buff[5] 8) | recv_buff[4]); for (uint8_t i = 0; i lidar_data.lsn; i++) lidar_data.si[i] = ((recv_buff[7 + i * 2] 8) | recv_buff[6 + i * 2]); return 0; 按照长度和距离解析格式进行解析，并发布雷达话题数据 #define POINTS_SIZE 800 // 修正和插值到800点(本身390个点左右)void Lidar::LidarTask() ROS_INFO(LidarTask running... ); int ret; int start_cnt = 0; // 数据缓冲定义 lidar_data_t lidar_data; // 雷达串口发送过来的数据 // 雷达数据类型 sensor_msgs::LaserScan laser_scan; // scan要发布的数据 laser_scan.header.frame_id = laser_link; laser_scan.angle_min = -M_PI; // 从正前方顺时针旋转到正后方 正后方就是-PI laser_scan.angle_max = M_PI; // 从正前方逆时针旋转到正后方 正后方就是 PI laser_scan.angle_increment = (laser_scan.angle_max - laser_scan.angle_min) / POINTS_SIZE; laser_scan.range_min = 0.1; // 雷达最小量程 laser_scan.range_max = 8.0; // 雷达最大量程 laser_scan.ranges.resize(POINTS_SIZE); std::fill(laser_scan.ranges.begin(), laser_scan.ranges.end(), std::numeric_limitsfloat::infinity()); // 全部填充为无限远 laser_scan.intensities.resize(POINTS_SIZE, 127); // 假设强度值为127 while (ros::ok()) // 清空数据 memset(lidar_data, 0, sizeof(lidar_data)); // 读取数据 ret = ReadLidarData(lidar_data); if (ret != 0) if (ret != -1) // 雷达断电后会返回-1，雷达断电不用打印报错 ROS_INFO(read_lidar_data ret=%d, ret); continue; #if 0 printf(header %d %d , lidar_data.header[0], lidar_data.header[1]); printf(ct %d , lidar_data.ct); printf(lsn %d , lidar_data.lsn); printf(fsa %d %f , lidar_data.fsa, (lidar_data.fsa 1) / 64.0); printf(lsa %d %f , lidar_data.lsa, (lidar_data.lsa 1) / 64.0); printf(cs %d , lidar_data.cs); printf(si = ); for (uint8_t i = 0; i lidar_data.lsn; i++) printf(0x%x, , lidar_data.si[i]); printf( );#endif // 解析数据 float fsa = (lidar_data.fsa 1) / 64.0; float lsa = (lidar_data.lsa 1) / 64.0; for (int i = 0; i lidar_data.lsn; i++) // 解析距离：单位mm float distance_mm = (lidar_data.si[i] 2); // 角度修正 float angle_correct = (distance_mm == 0) ? 0 : atan(19.16 * (distance_mm - 90.15) / (90.15 * distance_mm)); // 找到第i个数据的实际角度(把数据均分到起始角度到截至角度之间) float angle = (lidar_data.lsn = 1) ? fsa : fsa + ((lsa - fsa) / (lidar_data.lsn - 1)) * i; angle = angle - angle_correct; /* distance_mm 和 angle 已经是一对方向和距离了 这个雷达的数据定义和这里的安装方式是： 从正后方顺时针旋转12度为0度，然后顺时针旋转表示度数增加 ros正常的定义为： 正前方度数为0 雷达数组中的数据 从-PI到PI，也就是从正后方开始逆时针旋转一周 因此这里需要做个转换 比如 angle=0 distange=1 需要转换为angle=168 distange=1 比如 angle=168 distange=1 需要转换为angle=0 distange=1 比如 angle=348 distange=1 需要转换为angle=-180 distange=1 比如 angle=359 distange=1 需要转换为angle=169 distange=1 */ // 角度转换 angle = 168 - angle; angle = (angle -180) ? angle + 360.0 : angle; // 索引计算 计算这个角度对应的距离在雷达距离数组中的索引(-180度对应0索引 180度对应799索引) 加上0.5是为了四舍五入 要不然799索引永远出不来 int index = (angle + 180.0) / 360.0 * (POINTS_SIZE - 1) + 0.5; // 填充距离数据到雷达消息数组中 laser_scan.ranges[index] = distance_mm / 1000.0; // 一圈结束 发布消息 if (lidar_data.ct == 1) // 发布LaserScan消息 laser_scan.header.stamp = ros::Time::now(); laser_pub_.publish(laser_scan); // 发布后清除数据 全部填充为无限远 std::fill(laser_scan.ranges.begin(), laser_scan.ranges.end(), std::numeric_limitsfloat::infinity()); 测试效果 在小车上将lidar_node节点运行起来。 在虚拟机中运行rviz，add添加雷达数据选项，并且将话题修改为/scan，全局设置中Fixed Frame也修改为laser_link，即可看到雷达数据标注效果。 rosrun rviz rviz 3.5 Launch启动当需要启动多个软件包时，需要打开多个终端，并且输入多次命令。 为了实现一条命令启动，创建一个软件包用于启动所有节点 catkin_create_pkg launch_pkg rospy roscpp std_msgs 在软件包中创建一个launch文件夹，文件夹中创建all.launch文件，文件内容如下，把所有需要启动的节点都放进来 launch !-- 启动文件 - 启动所有软件包 -- node pkg=base_ctrl_pkg type=base_ctrl_node name=base_ctrl_node output=screen/ node pkg=lidar_pkg type=lidar_node name=lidar_node output=screen//launch 完成后编译工作空间，编译完成后，使用如下命令即可直接启动所有软件包。 # roslaunch 包名 launch文件名roslaunch launch_pkg all.launch 实际上，这个launch文件，放在任意一个软件包里都可以，但是为了结构清晰，就创建了一个空的软件包来干这件事了。 3.6 TF系统基础工作做完了，接下来需要理解一些东西了，否则拿别人的东西运行也不知道咋回事，或者有地方不一样的甚至跑不起来。 前面里程计和雷达分别在RVIZ中仿真的时候发现，这两个竟然不能同时显示！！！ Global Options中的Fixed Frame选项只能同时满足一个传感器，这里就有点问题。 将两个软件包都运行起来之后，使用以下命令查看TF树 rosrun rqt_tf_tree rqt_tf_tree 效果如下 TF（TransForm，坐标变换系），主要搞清楚几个坐标系之间的关系。 地图坐标系 地图坐标系/map，最根本的坐标系，坐标系原点从建图开始就固定不动了。 原点：在机器人建图时候的初始位置 方向：遵循右手法则，正前方为X，正左方为Y，正上方为Z 机器人坐标系 机器人坐标系base_footprint，坐标系原点永远跟随机器人移动。 原点：在机器人地面投影的正中心 方向：遵循右手法则，机器人的正前方为X，机器人正左方为Y，机器人正上方为Z 为了描述机器人在地图中的位置，把地图坐标系作为父坐标系，机器人坐标系作为子坐标系。 只需要六个值就可以表示机器人在地图中的位置： 机器人坐标系在地图坐标系中，xyz三个方向上距离的偏差 机器人坐标系在地图坐标系中，xyz三个方向上角度的偏差 对于小车来说，不可能在空中，所以z方向距离永远为0，不会向前或者向后倒，所以xy方向的角度永远为0。 有了这两个坐标系，就可以使用雷达进行建图了，雷达建图使用的就是这两个坐标系之间的转换关系。 3.7 SLAM（gmapping）创建一个SLAM软件包（里面的内容当然是用开源的了） # 安装sudo apt install ros-noetic-gmapping 安装完成后就可以傻瓜式使用了，直接在launch文件中添加一行 !-- 运行gmapping建图包 --node pkg=gmapping type=slam_gmapping name=slam_gmapping output=screen/ 也可以添加一些参数 !-- 运行gmapping建图包 --node pkg=gmapping type=slam_gmapping name=slam_gmapping output=screen !-- 地图更新时间间隔 5s更新一次地图 -- param name=map_update_interval value=5.0/ !-- 移动距离更新值 1.0m更新一次地图 -- param name=linearUpdate value=1.0/ /node 然后将所有节点运行起来，运行RVIZ，添加一个Map显示，就可以看到建图效果了，可以控制小车到处跑跑看看建图效果如何。 3.8 地图保存和加载当建图完成之后，需要把这个地图保存起来，下次启动直接调用即可。 3.8.1 地图保存软件包安装命令如下。会报某些软件包依赖不对的错误，根据提示补充相关依赖即可。 sudo apt install ros-noetic-map-server 安装完成后，先使用建图软件包完成建图，保持建图程序不要关闭。 运行地图保存程序 rosrun map_server map_saver -f 文件名 如果只有一个文件名就是当前终端的路径，这里使用绝对路径 需要先创建/home/lckfb/TspRosCar/RosCarWs/src/map_config/home这个文件夹，否则会保存失败 rosrun map_server map_saver -f /home/lckfb/TspRosCar/RosCarWs/src/map_config/home/home_map 运行结果如下 lckfb@MiWiFi-R3GV2-srv:~/TspRosCar/RosCarWs$ rosrun map_server map_saver -f /home/lckfb/TspRosCar/RosCarWs/src/map_config/home/home_map[INFO] [1764853848.865978437]: Waiting for the map[INFO] [1764853849.171315087]: Received a 4000 X 4000 map @ 0.050 m/pix[INFO] [1764853849.171582836]: Writing map occupancy data to /home/lckfb/TspRosCar/RosCarWs/src/map_config/home/home_map.pgm[INFO] [1764853850.342584721]: Writing map occupancy data to /home/lckfb/TspRosCar/RosCarWs/src/map_config/home/home_map.yaml[INFO] [1764853850.343969550]: Donelckfb@MiWiFi-R3GV2-srv:~/TspRosCar/RosCarWs/src/map_config$ cd /home/lckfb/TspRosCar/RosCarWs/src/map_config/homelckfb@MiWiFi-R3GV2-srv:~/TspRosCar/RosCarWs/src/map_config/home$ lshome_map.pgm home_map.yaml 得到两个文件，两个文件共同组成了一个地图数据。 home_map.pgm：一张图片的格式 home_map.yaml：描述了这个图片的信息，比如每个像素点对应的实际大小、起始点等信息 3.8.2 地图加载地图加载完成后，关闭建图节点，只运行一个roscore即可。 运行之后，查看当前ros存在的话题是找不到/map的 rostopic list 然后运行以下命令加载地图（只需要yaml文件即可，文件中有对应的地图图片的名字） rosrun map_server map_server 地图名.yaml 同样的这里使用绝对路径 rosrun map_server map_server /home/lckfb/TspRosCar/RosCarWs/src/map_config/home/home_map.yaml 加载完成之后就有地图话题了，在rviz中可以看到发布的地图。 3.9 导航节点创建一个导航软件包 catkin_create_pkg nav_pkg roscpp rospy move_base_msgs actionlib 3.10 摄像头节点这里使用系统镜像里默认支持的摄像头OV5695 lckfb@MiWiFi-R3GV2-srv:~$ v4l2-ctl --list-devicesrkisp-statistics (platform: rkisp): /dev/video7 /dev/video8rkisp_mainpath (platform:rkisp-vir0): /dev/video0 /dev/video1 /dev/video2 /dev/video3 /dev/video4 /dev/video5 /dev/video6 /dev/media0 安装依赖 创建一个软件包，用于发布摄像头数据 3.15 manage每个单独的功能都可以实现，但是和上位机交互时，需要在不同情况下调用不同的软件包。 这里创建一个软件包用来管理不同的功能同步。 创建管理包 catkin_create_pkg manage_pkg rospy roscpp std_msgs 3.20 常用命令节点相关 # 查看节点图关系rqt_graph 话题相关 # 查看当前存在的话题rostopic list# 查看话题的订阅者和发布者rostopic info /cmd_vel# 查看实时消息内容rostopic echo /cmd_vel 工具节点 # 运行速度控制器rosrun rqt_robot_steering rqt_robot_steering 4. APP开发这里为了实现任意电脑控制，而不是在虚拟机中的进行可视化，制作了QT上位机。 4.1 通信支持包我们的上位机中肯定是无法直接运行ros来和小车进行通信的，可以使用网络通信获取ros中的消息内容。 在小车中需要一个将Ros消息和网络消息转换的东西（有现成的）。 将ROS环境的运行信息进行上报需要软件包rosbridge_server，安装命令如下 sudo apt install ros-noetic-rosbridge-suite 和其他的软件包一样，最后把这个软件包也启动起来即可。 roslaunch rosbridge_server rosbridge_websocket.launch # 安装movebasesudo apt-get install ros-noetic-navigation# 创建导航包catkin_create_pkg nav_pkg roscpp rospy move_base_msgs actionlib","tags":["ROS","ROS1","泰山派"],"categories":["Linux应用"]},{"title":"CanDBC文件制作","path":"/2025/11/05/08. 开发工具/candbc/","content":"1. 工具下载这里使用的工具是：Vector CANdb++ Editor 下载地址：https://www.vector.com/cn/zh/support-downloads/download-center 按照下图中的选项找到软件。 下载完成之后，按照提示安装即可。 可能需要翻墙，不然加载很慢，或者加载不出来。 2. dbc制作CAN消息结构如下： CAN消息 ID DATA 字节位 根据上述结构，将报文进行分解： 一条消息：对应一个ID 一串数据：对应一串Data，标准8字节数据则共64个位 一个位数据：对应Data中的一个或多个字节或位 这里创建dbc的消息也是按照这个结构开始的。 2.1 创建dbc文件打开软件后，点击左上角File-Create Database 选择CANTemplate.dbc，然后点击OK，起个名字，保存文件即可。 创建完成后，左侧主要看Messages和Signals， Message定义了一共有几条消息 Signals定义了消息中用到的各个字节和位的含义。 2.2 创建消息上位机发送以下消息 id：\t0x010AFEdata：\t字节0：要控制的设备编号\t字节1：0：关机，1：启动\t字节2：0：充电，1：放电\t字节3-7：保留len：\t8 上位机接收以下消息 id：\t0x02FE0Adata：\t字节0：设备编号\t字节1：bit0:短路; bit1:输出过压; bit2:输入欠压; bit3:过温保护;\t字节2-3：当前电压（u16,低字节在前） 字节4-5：当前电流（u16,低字节在前）\t字节6：当前温度（u8,偏移40）len：\t8 先创建这两条消息 在左侧目录的Message处，点击右键New，在弹出的界面中填入 消息名称（随便写） 消息类型（扩展帧标准帧） 消息ID 消息长度 重复操作，添加需要的所有消息。 添加完成后如下图所示。 这个时候消息已经添加完成了，但是还没有定义消息中的数据分别是干啥的。 2.3 添加单字节信号比如以下数据是由一个字节定义的。 0x010AFE 字节0、1、2 0x02FE0A 字节0 在左侧目录的Signals处，点击右键New，或者点击Signals后，右侧在空白处右键New。 在弹出的界面中填入信号信息。 然后将这个信号添加到对应的消息中。 双击消息名称，在消息的Signals中点击Add，选择创建的信号，然后点击OK即可。 同一个信号可以在多条消息中重复添加。 枚举信号 比如以下数据是有固定的枚举类型的，就可以给这个信号创建枚举类型的选择表。 0x010AFE 字节1、2 同样的方法首先创建一个单字节信号，比如这里只有0和1。 然后创建一个枚举表。 点击View-Value Tables，在弹出的页面中右键New，在Value Descriptions中多次点击Add并修改不同枚举值的含义，Definition中可定义这个枚举值的名称，然后点击确定即可。 然后把这个枚举值绑定到一个Signals中。 双击要绑定的信号，选择目标枚举表，然后点击确定即可。 创建完成后，把这个信号也绑定到消息中。 重复上述步骤可以继续添加消息中的其他信号。 验证 保存当前dbc文件，在ZCANPRO中使用dbc发送，并加载此dbc文件。 字节0未定义枚举，可以直接在实际值中填写 字节1定义了枚举，可以在值描述中选择已经定义的值 2.4 添加位信号比如以下数据是需要按位解析的 0x02FE0A 字节1的bit0-bit4 创建一个信号，其中信号长度填1个bit。 然后将信号绑定到消息中，可以看到这个消息是从bit8开始的，长度为1个bit。 重复此操作，创建并添加剩下的bit信息。 这些bit信号也可以创建并绑定枚举表，比如0正常，1错误。 2.5 添加多字节信号同单字节信号，将信号长度改为16位，根据实际需求设置大小端模式和倍率。","tags":["Can","DBC"],"categories":["开发工具"]},{"title":"博客搭建指南","path":"/2025/08/29/博客搭建指南/","content":"1. 环境准备 安装git 安装nodejs 在cmd或git命令行中，执行以下命令安装hexo。 npm install -g hexo-cli 如果后续有些命令无法识别，可能说明安装完需要重启一下电脑。 2. 仓库创建创建一个GitHub仓库，仓库名固定用户名.github.io。 仓库默认包含一个主分支main，再手动创建一个分支hexo。 main：存放编译后的静态页面，访问的博客也就是此处的内容。 hexo：存放编译前的源码文件，在此处进行文档编写，此分支用来在多设备同步内容。 在github仓库设置中，找到Pages，找到Build and deployment，选择从分支获取资源，分支选择main，然后保存。 3. 创建博客创建一个空的文件夹Blog，并在此文件夹中打开git命令。 按顺序调用这三行命令。 hexo init // 初始化，将本文件夹初始化为博客文件夹hexo g // 将源文件生成静态文件hexo s // 在本地启动服务 执行效果如下 XCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/Blog$ hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependenciesINFO Start blogging with Hexo!XCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/Blog$ hexo gINFO Validating configINFO Start processingINFO Files loaded in 368 msINFO Generated: archives/index.htmlINFO Generated: index.htmlINFO Generated: archives/2025/08/index.htmlINFO Generated: fancybox/jquery.fancybox.min.cssINFO Generated: css/style.cssINFO Generated: js/script.jsINFO Generated: archives/2025/index.htmlINFO Generated: fancybox/jquery.fancybox.min.jsINFO Generated: js/jquery-3.6.4.min.jsINFO Generated: 2025/08/29/hello-world/index.htmlINFO Generated: css/images/banner.jpgINFO 11 files generated in 283 msXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/Blog$ hexo sINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. 执行完成后，将最后的地址http://localhost:4000/复制到浏览器即可看到默认的博客效果。 4. 修改主题4.1 下载主题源码在官网自带的主题https://hexo.io/themes/中找到一个喜欢的主题，这里选择NexT主题 按照github中提供的教程，将主题仓库clone到Blogtheme文件夹下。 XCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/Blog$ git clone https://github.com/next-theme/hexo-theme-next themes/nextCloning into themes/next...remote: Enumerating objects: 7752, done.remote: Counting objects: 100% (1052/1052), done.remote: Compressing objects: 100% (209/209), done.remote: Total 7752 (delta 926), reused 846 (delta 843), pack-reused 6700 (from 3)Receiving objects: 100% (7752/7752), 1.64 MiB | 13.08 MiB/s, done.Resolving deltas: 100% (4927/4927), done. 可以看到多出了Blog/theme/next这个文件夹。 4.2 主题美化4.2.1 主题基本信息修改主题标志，打开Blog/_config.yml这个文件，找到最下面的theme字段，修改为目标主题next，然后保存。 # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 语言修改，还是这个文件，找到language: en，修改为中文。 language: zh-CN 网站显示的基本信息如下： # Sitetitle: Blogsubtitle: 攻城狮装备搭建日记description: 身体和心灵总有一个在路上keywords:author: Haozilanguage: zh-CNtimezone: 4.2.2 布局信息美化这个主题内部还有很多其他的配置项，保存在Blog\\themes ext\\_config.yml，但是NexT文档不推荐直接修改此文件，建议修改方式如下： 将主题文件夹下默认的配置文件Blog\\themes ext复制到项目根目录并重命名为Blog\\_config.next.yml cp themes/next/_config.yml _config.next.yml 主题布局选择 主题内部还分为四种不同的主题布局，配置方式如下： 将Blog\\_config.next.yml文件中的如下字段选择如下： # Schemes# scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 4.2.3 分类和标签功能Blog\\_config.next.yml文件下，找到以下字段，根据需要打开对应的菜单项 menu: home: / || fa fa-home # about: /about/ || fa fa-user tags: /tags/ || fa fa-tags categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive # schedule: /schedule/ || fa fa-calendar #sitemap: /sitemap.xml || fa fa-sitemap #commonweal: /404/ || fa fa-heartbeat# Enable / Disable menu icons / item badges.menu_settings: icons: true badges: false 其中使用的菜单图标都是来自于Font Awesome，可以在这个网站找到自己喜欢的图标后，把图标名称写在 || 后面即可。 此时，当我们在首页点击 标签 或 分类 时，会报 404 ，这是因为我们还没有创建对应的文件夹，所以报 404 找不到。因此，需要在本地创建标签和分类文件夹。 hexo new page tags # 创建tags子目录hexo new page categories # 创建categories子目录 执行效果如下，本地会多出来两个文件夹。 XCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/imhaozi.github.io (hexo)$ hexo new page tagsINFO Validating configINFO Created: ~\\Desktop\\imhaozi.github.io\\source\\tags\\index.mdXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/imhaozi.github.io (hexo)$ hexo new page categoriesINFO Validating configINFO Created: ~\\Desktop\\imhaozi.github.io\\source\\categories\\index.md 此时如果重新发布网站之后，页面不会报错，但是还不能自动检索文章，需要在刚才生成的文件夹中的index.md 中增加对应的 type 属性。 添加完之后如下： categories下的index ---title: categoriesdate: 2025-09-01 15:44:04type: categories--- tags下的index ---title: tagsdate: 2025-09-01 15:43:56type: tags--- 新发布的文章也需要加上对应的标签和主题才可以被检索到，比如本文章。 ---title: 博客搭建指南date: 2025-08-29 18:49:27tags: - blog - hexocategories: - 工具--- 上面这个文章，属于工具类别，标签加了两个hexo、blog. 4.2.4 首页不显示全文网站首页默认会将文章全文显示，但是一般都不是我们想看的内容，可以选择把文章都只显示一个概要，然后可以点进去再看全文。 只需要在文章头部添加description字段即可。 ---title: 博客搭建指南date: 2025-08-29 18:49:27tags: [hexo,blog]categories: 工具description: 记录搭建博客和美化主题的过程--- 4.2.5 文章搜索功能安装插件 npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 安装效果如下 XCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/imhaozi.github.io (hexo)$ npm install hexo-generator-search --saveadded 1 package, and audited 238 packages in 2s37 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilitiesXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/imhaozi.github.io (hexo)$ npm install hexo-generator-searchdb --saveadded 1 package, and audited 239 packages in 2s37 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilities Blog\\_config.next.yml文件下，添加如下字段（默认是没有这个字段的） search: path: search.xml field: post format: html limit: 10000 然后将以下字段修改使能 # Local Search# Dependencies: https://github.com/next-theme/hexo-generator-searchdblocal_search: enable: true # Show top n results per article, show all results by setting to -1 top_n_per_article: -1 # Unescape html strings to the readable one. unescape: false # Preload the search data when the page loads. preload: false 4.2.6 隐藏底部强力驱动Blog\\_config.next.yml文件下 # Powered by Hexo NexTpowered: false 4.2.7 目录自己编号主题默认会给文章目录加编号，如果我们自己已经加了编号了就会重复，需要关掉此功能。 Blog\\_config.next.yml文件下 toc: enable: true # Automatically add list number to toc. number: false 4.2.8 文章默认格式在 Hexo 根目录下 修改 scaffolds/post.md title: title date: date tags: [tag1,tag2]categories: [类别]description: null 4.2.9 代码块格式和复制按钮Blog\\_config.next.yml文件下 codeblock: # Code Highlight theme # All available themes: https://theme-next.js.org/highlight/ theme: light: default dark: stackoverflow-dark prism: light: prism dark: prism-dark # Add copy button on codeblock copy_button: enable: true # Available values: default | flat | mac style: # Fold code block fold: enable: true height: 500 # Display language name language: true 4.2.10 文章阅读进度Blog\\_config.next.yml文件下 # Reading progress barreading_progress: enable: true # Available values: left | right start_at: left # Available values: top | bottom position: top reversed: false color: #37c6c0 height: 3px 4.2.11 文章和图片单独创建文件夹Blog/_config.yml这个文件 post_asset_folder: true 4.3 重新运行执行下面三行命令，重新生成静态文件。 hexo cleanhexo ghexo s 执行完成后，将最后的地址http://localhost:4000/复制到浏览器即可看到修改后的主题博客效果。 5. github推送打开Blog/_config.yml这个文件，找到最下面的deploy字段，添加如下信息，然后保存。其中repo为仓库的链接。 # Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/imhaozi/imhaozi.github.io.git branch: main 安装git部署插件 XCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/Blog$ npm install hexo-deployer-git --saveadded 10 packages, and audited 237 packages in 3s37 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilities 重新生成界面并推送到远端。 hexo cleanhexo ghexo d // 部署到服务上 完成后在浏览器中访问用户名.github.io即可访问博客内容。 6. 多端同步本机操作： 将远端仓库克隆到本地，并切换到hexo分支。并将此分支下的文件都删掉，仅留下.git 将创建的Blog文件夹中的内容全部复制到，hexo分支的仓库文件夹，并删去.deploy_git文件夹 如果你在Blog/themes文件夹下 clone 过其它主题文件，把其中的 .git文件夹删除掉 将hexo分支的内容推送到远端 异地操作： 首次创建博客的电脑需要先将首次创建完成的博客源码推送到远端（上面的步骤） 本机下载已经上传到远端的源码 本机安装环境npm install hexo-cli -g、npm install hexo-deployer-git --save（如果创建的博客还需要其他的就分别安装） 在本机的hexo分支上继续写博客，写完之后生成并推送 博客推送完成后，记得把源码推送到远端。 7. 博客图片显示安装图片插件 npm install https://github.com/CodeFalling/hexo-asset-image --save 修改配置，打开Blog/_config.yml这个文件，找到最下面的post_asset_folder字段 post_asset_folder: true 后面新建文章的时候，会自动创建同文件名的文件夹（或者手动创建md文件和文件夹），图片都可以放到这个文件夹下。 插入图片的时候，采用如下形式。 ![CAN接线方式](./canopen/CAN接线方式.jpg)","tags":["blog","hexo"],"categories":["工具"]},{"title":"v3s开发板制作","path":"/2025/06/01/04. Linux应用/v3s开发板制作/","content":"1. 硬件准备1.1 开发板1.2 SD卡格式化将SD卡插入虚拟机，使用gparted工具将SD卡格式化。 先删除所有分区。 创建分区1，存放内核 创建分区2，存放文件系统，用完剩下的所有的空间。 完成之后点击应用即可，分区结果如下图所示。 2. 系统开发系统编译在虚拟机中进行。 在虚拟机中创建一个新的文件夹v3s存放所有的软件工程。 系统开发一共需要三部分，uboot、linux内核、文件系统，同时因为我们在虚拟机中开发，还需要交叉编译器。 参考链接：https://wiki.sipeed.com/soft/Lichee/zh/Zero-Doc/System_Development/type.html 2.1 交叉编译器去ARM交叉编译器的官网下载，下载地址： https://releases.linaro.org/components/toolchain/binaries/6.3-2017.05/arm-linux-gnueabihf/ 版本： gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf.tar.xz 下载完成之后，在v3s文件夹下新建toolchain文件夹，用于存放交叉编译工具。 解压 cd toolchain/# 解压tar xvf gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf.tar.xz 结果 haozi@haozi:~/work/develop/v3s$ cd toolchain/haozi@haozi:~/work/develop/v3s/toolchain$ lsgcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihfgcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf.tar.xz 2.2 uboot这里参考荔枝派的相关资料。 软件下载： cd v3s# 下载git clone https://github.com/Lichee-Pi/u-boot.git -b v3s-current 下载完成后在v3s文件夹下得到一个u-boot文件夹。 haozi@haozi:~/work/develop/v3s$ cd u-boot/haozi@haozi:~/work/develop/v3s/u-boot$ lsapi common doc fs lib net snapshot.commitarch config.mk drivers include Licenses post splboard configs dts Kbuild MAINTAINERS README testcmd disk examples Kconfig Makefile scripts tools 参考仓库：https://github.com/Lichee-Pi/u-boot 得到的uboot文件结构如下： ├── api 存放uboot提供的API接口函数├── arch 平台相关的部分我们只需要关心这个目录下的ARM文件夹│ ├──arm│ │ └──cpu│ │ │ └──armv7│ │ └──dts │ │ │ └──*.dts 存放设备的dts,也就是设备配置相关的引脚信息├── board 对于不同的平台的开发板对应的代码├── cmd 顾名思义，大部分的命令的实现都在这个文件夹下面。├── common 公共的代码├── configs 各个板子的对应的配置文件都在里面，我们的Lichee配置也在里面├── disk 对磁盘的一些操作都在这个文件夹里面，例如分区等。├── doc 参考文档，这里面有很多跟平台等相关的使用文档。├── drivers 各式各样的驱动文件都在这里面├── dts 一种树形结构（device tree）这个应该是uboot新的语法├── examples 官方给出的一些样例程序├── fs 文件系统，uboot会用到的一些文件系统├── include 头文件，所有的头文件都在这个文件夹下面├── lib 一些常用的库文件在这个文件夹下面 ├── Licenses 这个其实跟编译无关了，就是一些license的声明├── net 网络相关的，需要用的小型网络协议栈├── post 上电自检程序├── scripts 编译脚本和Makefile文件├── spl second program loader，即相当于二级uboot启动。├── test 小型的单元测试程序。└── tools 里面有很多uboot常用的工具。 下载完成后开始编译。 安装依赖（一个用于编译和反编译设备树的工具） sudo apt-get install device-tree-compiler 编译 cd u-boot# 使用默认配置make ARCH=arm CROSS_COMPILE=/home/haozi/develop/V3s/toolchain/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf- LicheePi_Zero_defconfig# 编译time make ARCH=arm CROSS_COMPILE=/home/haozi/develop/V3s/toolchain/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf- 21 | tee build.log# 如果报错/bin/sh: 1: ./tools/binman/binman: not found# 则需要安装个pythonsudo apt-get install python 等待编译完成后，在当前目录下生成了u-boot-sunxi-with-spl.bin haozi@haozi:~/work/develop/v3s/u-boot$ lsapi config.mk examples Licenses scripts u-boot u-boot-dtb.img u-boot-sunxi-with-spl.binarch configs fs MAINTAINERS snapshot.commit u-boot.bin u-boot.img u-boot.symboard disk include Makefile spl u-boot.cfg u-boot.ldsbuild.log doc Kbuild net System.map u-boot.cfg.configs u-boot.mapcmd drivers Kconfig post test u-boot.dtb u-boot-nodtb.bincommon dts lib README tools u-boot-dtb.bin u-boot.srec 先确保能编译成功，然后修改以下配置，重新编译。 设置U-Boot从TF卡启动，修改include/configs/sun8i.h这个文件，填入如下信息。 #define CONFIG_BOOTCOMMAND setenv bootm_boot_mode sec; \\ load mmc 0:1 0x41000000 zImage; \\ load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb; \\ bootz 0x41000000 - 0x41800000;#define CONFIG_BOOTARGS console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0 添加完成后如下图所示 然后重新执行上面的编译步骤即可。 最终结果为u-boot-sunxi-with-spl.bin。 使用SD Card Formatter软件，将SD卡格式化。 然后将SD卡插进虚拟机，运行以下命令烧录。 sudo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8 然后将SD卡插入到板子，按复位运行，从串口可以看到以下信息，表示uboot正常工作。 U-Boot SPL 2017.01-rc2-00057-g32ab1804cd-dirty (Nov 22 2025 - 20:10:34)DRAM: 64 MiBTrying to boot from MMC1U-Boot 2017.01-rc2-00057-g32ab1804cd-dirty (Nov 22 2025 - 20:10:34 +0800) Allwinner TeCPU: Allwinner V3s (SUN8I 1681)Model: Lichee Pi ZeroDRAM: 64 MiBMMC: SUNXI SD/MMC: 0*** Warning - bad CRC, using default environmentIn: serial@01c28000Out: serial@01c28000Err: serial@01c28000U-Boot 2017.01-rc2-00057-g32ab1804cd-dirty (Nov 22 2025 - 20:10:34 +0800) Allwinner TeCPU: Allwinner V3s (SUN8I 1681)Model: Lichee Pi ZeroDRAM: 64 MiBMMC: SUNXI SD/MMC: 0*** Warning - bad CRC, using default environmentIn: serial@01c28000Out: serial@01c28000Err: serial@01c28000Net: No ethernet found.starting USB...No controllers foundHit any key to stop autoboot: 0reading zImage** Unable to read file zImage **reading sun8i-v3s-licheepi-zero-dock.dtb** Unable to read file sun8i-v3s-licheepi-zero-dock.dtb **== 2.3 Kernel软件下载，下载后v3s文件夹下会多出一个linux文件夹 cd v3s# 下载git clone -b zero-5.2.y --depth 1 https://github.com/Lichee-Pi/linux.git 修改makefile配置 cd linux# 修改Makefile# 修改第364行ARCH ?= $(SUBARCH)# 修改后（第一行是修改的 后面两行是新增的）ARCH = armCROSS_COMPILE = /home/haozi/work/develop/v3s/toolchain/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-INSTALL_MOD_PATH = out 修改效果如下 编译 cd linuxmake licheepi_zero_defconfig# make menuconfig #一般不用修改，需要时单独改make -j16make dtbs #编译设备树 编译完成后，在archarmboot目录下生成了zImage，在archarmbootdts目录下生成了sun8i-v3s-licheepi-zero.dtb 把SD卡插到虚拟机，可以看到以下路径。 然后拷贝内核文件到这个文件夹 find ./ -name zImagecp ./arch/arm/boot/zImage /media/haozi/KERNEL/find ./ -name sun8i-v3s-licheepi-zero-dock.dtbcp ./arch/arm/boot/dts/sun8i-v3s-licheepi-zero-dock.dtb /media/haozi/KERNEL/ 完成后把SD卡插到开发板验证效果，串口可以看到以下信息，uboot之后可以找到内核了（这里运行到内核后一直重启，因为还没有文件系统）。 U-Boot SPL 2017.01-rc2-00057-g32ab1804cd-dirty (Nov 22 2025 - 20:10:34)DRAM: 64 MiBTrying to boot from MMC1U-Boot 2017.01-rc2-00057-g32ab1804cd-dirty (Nov 22 2025 - 20:10:34 +0800) Allwinner TechnologyCPU: Allwinner V3s (SUN8I 1681)Model: Lichee Pi ZeroDRAM: 64 MiBMMC: SUNXI SD/MMC: 0*** Warning - bad CRC, using default environmentIn: serial@01c28000Out: serial@01c28000Err: serial@01c28000U-Boot 2017.01-rc2-00057-g32ab1804cd-dirty (Nov 22 2025 - 20:10:34 +0800) Allwinner TechnologyCPU: Allwinner V3s (SUN8I 1681)Model: Lichee Pi ZeroDRAM: 64 MiBMMC: SUNXI SD/MMC: 0*** Warning - bad CRC, using default environmentIn: serial@01c28000Out: serial@01c28000Err: serial@01c28000Net: No ethernet found.starting USB...No controllers foundHit any key to stop autoboot: 0reading zImage4182880 bytes read in 216 ms (18.5 MiB/s)reading sun8i-v3s-licheepi-zero-dock.dtb12100 bytes read in 27 ms (437.5 KiB/s)## Flattened Device Tree blob at 41800000 Booting using the fdt blob at 0x41800000 Loading Device Tree to 42dfa000, end 42dfff43 ... OKStarting kernel ...[ 0.000000] Booting Linux on physical CPU 0x0[ 0.000000] Linux version 5.2.0-licheepi-zero+ (haozi@computer) (gcc version 6.3.1 20170404 (Linaro GCC 6.3-2017.05)) #1 SMP Wed Nov 19 23:22:23 CST 2025[ 0.000000] CPU: ARMv7 Processor [410fc075] revision 5 (ARMv7), cr=10c5387d[ 0.000000] CPU: div instructions available: patching division code[ 0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache[ 0.000000] OF: fdt: Machine model: Lichee Pi Zero with Dock[ 0.000000] Memory policy: Data cache writealloc[ 0.000000] percpu: Embedded 16 pages/cpu s34508 r8192 d22836 u65536[ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 16256[ 0.000000] Kernel command line: console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0此处省略一部分[ 1.420431] 3fa0: 00000000 00000000 00000000 00000000[ 1.428600] 3fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000[ 1.436766] 3fe0: 00000000 00000000 00000000 00000000 00000013 00000000[ 1.443384] Rebooting in 5 seconds..然后从这里自动重启。 2.4 buildroot去官网下载：https://buildroot.org/download.html 这个选择最下方的长期支持版本。 haozi@computer:~/develop/V3s/buildroot$ lsarch boot Config.in configs DEVELOPERS fs Makefile package support toolchainboard CHANGES Config.in.legacy COPYING docs linux Makefile.legacy README system utils 得到的buildroot文件结构如下： .├── arch: #存放CPU架构相关的配置脚本，如arm/mips/x86,这些CPU相关的配置，在制作工具链时，编译uboot和kernel时很关键.├── board├── boot├── CHANGES├── Config.in├── Config.in.legacy├── configs: #放置开发板的一些配置参数. ├── COPYING├── DEVELOPERS├── dl: #存放下载的源代码及应用软件的压缩包. ├── docs: #存放相关的参考文档. ├── fs: #放各种文件系统的源代码. ├── linux: #存放着Linux kernel的自动构建脚本. ├── Makefile├── Makefile.legacy├── output: #是编译出来的输出文件夹. │ ├── build: #存放解压后的各种软件包编译完成后的现场.│ ├── host: #存放着制作好的编译工具链，如gcc、arm-linux-gcc等工具.│ ├── images: #存放着编译好的uboot.bin, zImage, rootfs等镜像文件，可烧写到板子里, 让linux系统跑起来.│ ├── staging│ └── target: #用来制作rootfs文件系统，里面放着Linux系统基本的目录结构，以及编译好的应用库和bin可执行文件. (buildroot根据用户配置把.ko .so .bin文件安装到对应的目录下去，根据用户的配置安装指定位置)├── package：#下面放着应用软件的配置文件，每个应用软件的配置文件有Config.in和soft_name.mk。├── README├── support├── system├── toolchain└── utils # 实用工具 安装下面依赖 sudo apt-get install linux-headers-$(uname -r)sudo apt-get install libncurses5-devsudo apt-get install wgetsudo apt-get install gcc automake autoconf libtool make 输入以下指令进入配置页面 make menuconfig 先选择架构，V3s的芯片信息如下 CPUARM Cortex A7 @ 1.2GHzSupport NEON Advanced SIMD instructionVFPv4 Floating Point Unit Target options可以按照如下结果配置。 Build options配置这三项 配置文件保存位置，在重新构建时，只需要调用make 然后make即可，不用重新配置一遍。这里配置为：$(CONFIG_DIR)/configs/my_v3s_defconfig。 配置下载位置，因为系统构建的时候需要从网络上抓起很多软件报的代码进行编译构建。这个一般不需要修改。 strip target binaries建议使能，这样会使文件尺寸变小。 其他默认即可 Toolchain按照下图中配置 Fortran、OpenMP刚开始没勾选，但是编译报错提示需要勾选，就又加上了。 System configuration System hostname：根据需要定义一个字符串，是控制台前面的提示符xxx@vsi，这里填haozi Root password：root用户的密码 配置完成后，点击save选项。然后退出。 退出配置界面后，使用以下命令，将配置好的配置文件保存到文件（路径就是前面配置的）。 make savedefconfig# 可以看到多了这个文件haozi@computer:~/develop/V3s/buildroot$ ls configs/ | grep v3smy_v3s_defconfig 编译（过程极慢，需要下载一堆东西，最好找个网靠谱的地方） make 编译完成后会在outputimages下生成rootfs.tar，复制解压到第二分区后就能使用了。 find ./ -name rootfs.tarcp ./output/images/rootfs.tar /media/haozi/rootfs/# 解压sudo tar -xvf rootfs.tar SD卡插入开发板，串口可看到系统可以正常启动了。目前只有一个账户root，密码是前面配置的。 Saving 2048 bits of non-creditable seed for next bootStarting syslogd: OKStarting klogd: OKRunning sysctl: OKStarting network: OKStarting crond: OKWelcome to Buildroothaozi login: rootPassword: 验证是否可用 # 查看内核版本uname -a# 查看 CPU 信息cat /proc/cpuinfo# 查看内存free -h# 查看存储空间df -h 测试结果如下 # pwd/root## uname -aLinux haozi 5.2.0-licheepi-zero+ #1 SMP Wed Nov 19 23:22:23 CST 2025 armv7l GNU/Linux## cat /proc/cpuinfoprocessor : 0model name : ARMv7 Processor rev 5 (v7l)BogoMIPS : 48.00Features : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrmCPU implementer : 0x41CPU architecture: 7CPU variant : 0x0CPU part : 0xc07CPU revision : 5Hardware : Allwinner sun8i FamilyRevision : 0000Serial : 12c00001887825cd## free -h total used free shared buff/cache availableMem: 54.8M 6.6M 44.7M 40.0K 3.4M 45.0MSwap: 0 0 0# df -hFilesystem Size Used Available Use% Mounted on/dev/root 3.5G 16.7M 3.3G 0% /devtmpfs 26.9M 0 26.9M 0% /devtmpfs 27.4M 0 27.4M 0% /dev/shmtmpfs 27.4M 20.0K 27.4M 0% /tmptmpfs 27.4M 20.0K 27.4M 0% /run 3. 系统修改系统虽然跑起来了，但是设备都还没办法运行，需要进行配置，主要是针对内核的。","tags":["Linux","V3S"],"categories":["Linux应用"]},{"title":"充电桩国标协议解析","path":"/2025/06/01/10. 国际标准/充电桩国标/","content":"1. 国标概述 以2015国标（新国标）为主进行记录，对于2011国标（老国标）中有不同的地方进行补充。 国标充电文件主要有以下几个： GBT_18487.1-2015：主要描述了充电桩与车辆之间的电气连接方式（连接方式C常用）、充电控制引导电路原理和信号编号、充电过程中状态和流程图。 GBT20234.1-2015：主要是电气连接设备通用要求，包含充电流程描述、控制时序、直流充电电压最大1000V，电流最大400A。 GBT20234.2-2015：交流充电接口规定。 GBT20234.3-2015：直流充电接口规定，包含充电插座中线的信号定义。 目前，最大电压电流分别为1000V、400A，然后根据充电枪线的限制，来做软件上的最大电流限制。 GBT27930-2015：充电机和车辆之间的通信协议规定，软件重点。 2. 充电流程 物理接连完成 低压辅助上电 充电握手阶段 充电参数配置阶段 充电阶段 充电结束阶段 结束充电 3. 通信协议总则： 使用CAN2.0B通信协议 CAN协议采用SAE J1939-21协议 CANID使用扩展帧数据格式 数据传输有两个节点，充电机、BMS 数据传输采用低字节在前格式 电流正数代表放电，电流负数表示充电（TODO???） ID数据格式 ID使用29位扩展帧格式。 地址定义： 充电机：0x56（十进制86） BMS：0xF4（十进制244） /*SA：源地址PS：目标地址PF：命令码（PGN）DP：数据页，固定0R：保留，固定0P：优先权*/typedef union _can_id uint32_t id; struct // 从低到高 uint32_t sa : 8; // 源地址 uint32_t ps : 8; // 目标地址 uint32_t pf : 8; // puu格式，确定数据域参数组编号（PGN的第二个字节） uint32_t dp : 1; // 数据页，固定为0 uint32_t r : 1; // 保留位，固定为0 uint32_t p : 3; // 优先权 uint32_t : 3; bits; can_id_t; 3.1 物理连接当充电枪与车辆连接完成后，充电枪上的按键S闭合，R2和R4并联后和R1串联，供电电源12V最终分压为4V。 即：充电机检测到CC1电压为4V时，表示充电枪与车辆连接完成。 3.2 低压辅助上电检测到车辆连接完成后，闭合继电器K3、K4，通过充电枪线上的A+、A-两根线给BMS低压辅助上电。 此时，才能和车辆进行CAN通信。 3.3 充电握手充电握手分为两个阶段。 阶段一：握手启动 充电机给BMS发送充电握手报文CHM，周期250ms 车辆回应充电机车辆握手报文BHM，周期250ms 报文代号 描述 PGN 优先权 源地址 目标地址 数据长度 数据（从低到高） CHM 充电机握手 0x002600 6 充电机 BMS 3 0x01, 0x01, 0x00 BHM 车辆握手 0x002700 6 BMS 充电机 2 0x58, 0x1B 其中： CHM数据部分表示：充电机通信协议版本，一般为1.1 BHM数据部分表示：电池最高允许电压，单位0.1V，比如上述0x1B58表示最高允许电压为700V 绝缘检测 开始绝缘检测，可以使用最高允许的电压进行。等待绝缘检测完成。 阶段二：握手参数辨识 充电机给BMS发送充电机辨识报文CRM，周期250ms 车辆回应充电机车辆辨识报文BRM，周期250ms 报文代号 描述 PGN 优先权 源地址 目标地址 数据长度 数据 CRM 充电机辨识 0x000100 6 充电机 BMS 8 BRM BMS辨识 0x000200 7 BMS 充电机 41 其中 CRM数据部分： 字节1：未辨识到BMS报文前0x00，收到BMS辨识报文后0xAA； 字节2-5：充电机编号，范围0到0xFFFFFFFF； 字节6-8：充电机所在的区域编码，ASCII编码。（非必须） BRM数据部分（超过8字节，需要进行多帧发送）： 字节1-3：BMS协议版本号，同CHM部分； 字节4：电池类型，枚举。 字节5-6：电池额定容量 字节7-8：电池额定总电压 字节9-12：厂商名称，ASCII编码（非必须） 字节13-16：电池组序号（非必须） 字节17：电池生产日期，年，偏移1985（非必须） 字节18：电池生产日期，月，偏移0（非必须） 字节19：电池生产日期，日，偏移0（非必须） 字节20-22：电池充电次数（非必须） 字节23：电池组产权（非必须） 字节24：预留（非必须） 字节25-41：VIN，车辆识别码（非必须） 字节42-49：BMS软件号（非必须） 3.4 充电参数配置阶段握手完成后进入充电参数配置。 充电机向BMS发送最大输出能力，BMS判断是否能够充电。 报文代号 描述 PGN 优先权 源地址 目标地址 数据长度 数据 BCP 电池充电参数 0x000600 7 BMS 充电机 13 CTS 时间同步信息 0x000700 6 充电机 BMS 7 CML 充电机最大输出能力 0x000800 6 充电机 BMS 8 BRO 电池就绪状态 0x000900 4 BMS 充电机 1 CRO 充电机就绪状态 0x000A00 4 充电机 BMS 1 BCP数据部分：","tags":["Can","充电桩国标"],"categories":["标准"]},{"title":"fatfs文件系统移植","path":"/2025/01/01/05. 开源库/fatfs文件系统移植/","content":"使用的开发板：RTT正点原子的潘多拉loT Board开发板、普中Z-100开发板。主控：STM32L475VET6、STM32F103ZET6 软件：CubeMX 6.7.0、Keil 5.38、FatFs R0.15 学习路线： 学会FATFS文件系统的移植； 学会API的使用； 第一部分：移植FatFs 是一个通用的文件系统(FATexFAT)模块，用于在小型嵌入式系统中实现FAT文件系统。 FatFs 组件的编写遵循ANSI C(C89)，完全分离于磁盘 IO 层l，因此不依赖于硬件平台。它可以嵌入到资源有限的微控制器中，如 8051, PIC, AVR, ARM, Z80, RX等等，不需要做任何修改。 1. 准备源码FATFS网站：http://elm-chan.org/fsw/ff/00index_e.html 从官网中即可下载源码。这里选择最新版本R0.15。 下载压缩包解压后目录如下： ff15 documents（官网网页，没啥用可删除） source（源码） diskio.c \\ diskio.h ff.c \\ ff.h ffconf.h ffsystem.h ffunicode.c 00history.txt 00readme.txt LICENSE.txt（开源协议） 其中： ff.c ff.h：文件系统协议层，几乎不用修改； ffconf.h：FatFs模块的配置文件； diskio.c \\ diskio.h：将现有磁盘IO模块连接到FatFs的粘合功能，即适配低层硬件接口读写操作，是主要移植修改的重点； ffunicode.c：字符编码层，可以选择utf8、ascii、GBK。根据需要选择。 ffsystem.c：可选OS相关功能的示例。 这是 FatFs 官方所提供的程序之间的依赖网络。其中虚线框不是必须的，为用户自行编写定义。 在官方提供的文件中，ff.c、ff.h、diskio.h 是不需要操作的。 需要修改的有： ffconf.h：通过修改其中的宏定义可裁剪 FatFs 的部分功能。 diskio.c：底层驱动函数。 具体文件如何配置或修改看移植部分。 2. TF卡 SDIO 模式移植(尚有问题未解决)这里使用普中Z-100开发板，主控芯片为STM32F103ZET6。开发板上TF卡与主控的通信采用SDIO通信。 原理图如下： 2.1 创建工程使用CubeMX创建一个工程。需要配置的项目有： 时钟 程序调试接口 串口（用于观察调试信息） SDIO接口（带DMA） 其中 SDIO 接口的配置如下： Clock transition on which the bit capture is made：Rising transition。主时钟 SDIOCLK 产生 CLK 引脚时钟有效沿选择，可选上升沿或下降沿，它设定 SDIO 时钟控制寄存器(SDIO_CLKCR)的 NEGEDGE 位的值，一般选择设置为上升沿。 SDIO Clock divider bypass：Disable。时钟分频旁路使用，可选使能或禁用，它设定 SDIO_CLKCR 寄存器的 BYPASS 位。如果使能旁路，SDIOCLK 直接驱动 CLK 线输出时钟；如果禁用，使用 SDIO_CLKCR 寄存器的 CLKDIV 位值分频 SDIOCLK，然后输出到 CLK 线。一般选择禁用时钟分频旁路。 SDIO Clock output enable when the bus is idle： Disable the power save for the clock。节能模式选择，可选使能或禁用，它设定 SDIO_CLKCR 寄存器的 PWRSAV 位的值。如果使能节能模式，CLK 线只有在总线激活时才有时钟输出；如果禁用节能模式，始终使能 CLK 线输出时钟。 SDIO hardware flow control： The hardware control flow is disabled。硬件流控制选择，可选使能或禁用，它设定 SDIO_CLKCR 寄存器的 HWFC_EN 位的值。硬件流控制功能可以避免 FIFO 发送上溢和下溢错误。 SDIOCLK clock divide factor： 2。时钟分频系数，它设定 SDIO_CLKCR 寄存器的 CLKDIV 位的值，设置 SDIOCLK 与 CLK 线输出时钟分频系数：CLK 线时钟频率SDIOCLK([CLKDIV+2])。 SDIO相关的时钟分为两部分： SDIO适配器时钟(SDIOCLK)，用于驱动SDIO适配器，可用于产生SDIO_CK时钟。在STM32F1中，SDIOCLK来自HCLK(72MHz)。改时钟经过上述的分频后产生SDIO_CK时钟。 AHB总线接口时钟(HCLK2)，该时钟用于驱动SDIO的AHB总线接口，其频率为HCLK2(36MHz)（）在cubemx时钟配置页面可以看得到。 需要注意的是，不同的SD卡对时钟的最高频率范围不同。因此建议将**SDIOCLK clock divide factor：**从0开始慢慢增大试试，可以读写数据成功即可。 我这里用的卡，经过测试设置为0时，卡信息读写成功，数据读写失败。设置为2时，均可成功。 DMA配置如下：（一般应用中都是用DMA传输） 此处，可以发现，DMA只能配置一个方向的，即两个方向共用了一个传输通道。在使用时，实际上可以通过重新初始化DMA来更改传输方向。这里先随便设置一个方向即可。 最后勾选上中断： 生成工程后： 修改sdio.c文件中的void MX_SDIO_SD_Init(void)函数。正确的如下： void MX_SDIO_SD_Init(void) hsd.Instance = SDIO; hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING; hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE; hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE; hsd.Init.BusWide = SDIO_BUS_WIDE_1B;\t// 注意要修改这里为 SDIO_BUS_WIDE_1B hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE; hsd.Init.ClockDiv = 2; if (HAL_SD_Init(hsd) != HAL_OK) Error_Handler(); if (HAL_SD_ConfigWideBusOperation(hsd, SDIO_BUS_WIDE_4B) != HAL_OK) Error_Handler(); 如果生成的代码中 本来就是 hsd.Init.BusWide SDIO_BUS_WIDE_1B; 那就不用管。 如果生成的默认是 4B，则要修改为 1B，否则此函数执行的时候不会通过。 （不同固件包生成的不一样，因此要确认一下） 2.2 SD卡读写验证2.2.1 sdio_sdcard.h两个 test 函数，测试完成之后不需要的话可以删除。跟后续移植关系不是很大。 #ifndef __SDIO_SDCARD_H#define __SDIO_SDCARD_H#include sdio.h#include stdint.hvoid SD_info_print(void);void SD_read_writer_test(void);HAL_StatusTypeDef SDIO_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks);HAL_StatusTypeDef SDIO_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks);void SD_read_writer_dma_test(void);#endif\t/* __SDIO_SDCARD_H */ 2.2.2 sdio_sdcard.c#include sdio_sdcard.h#include stdio.h // 调试信息输出#include sdio.h // cubemx生成的extern SD_HandleTypeDef hsd;extern DMA_HandleTypeDef hdma_sdio;/** * @brief 打印SD卡信息 * * @param none * * @return none */void SD_info_print(void) HAL_SD_CardInfoTypeDef SDCardInfo; // SD卡信息结构体\tHAL_SD_CardCIDTypeDef sdcard_cid; // HAL_SD_GetCardInfo(hsd, SDCardInfo);\t// 得到卡的信息\t// 打印SD卡基本信息\tprintf(SD card information! \\r ); printf(Card Type:%d \\r , SDCardInfo.CardType); // 卡类型 printf(Card CardVersion:%d \\r ,\tSDCardInfo.CardVersion); // CardVersion printf(Card Class:%d \\r , SDCardInfo.Class); // 卡Class\tprintf(Card RCA:%d \\r , SDCardInfo.RelCardAdd); // 卡相对地址 printf(Card BlockNumber: %d \\r , SDCardInfo.BlockNbr); // 有多少个块\tprintf(Card BlockSize(Byte): %d \\r ,\tSDCardInfo.BlockSize); // 块大小 默认512个字节\tprintf(Card Capacity(Byte): %llu \\r , ((unsigned long long)SDCardInfo.BlockSize * SDCardInfo.BlockNbr));\t// 容量 printf(Card Capacity:%d MB \\r , (uint32_t)(SDCardInfo.LogBlockNbr) 11); // 显示容量 printf(Card BlockSize:%d \\r , SDCardInfo.LogBlockSize); // 显示块大小 // 读取并打印SD卡的CID信息\tHAL_SD_GetCardCID(hsd, sdcard_cid);\tprintf(ManufacturerID: %d \\r , sdcard_cid.ManufacturerID);\t// 制造商/** * @brief SD卡读写测试 * * @param none * * @return none */void SD_read_writer_test(void) /* SD卡状态 */ int sdcard_status = 0; uint8_t read_buf[512]; // 读数据缓存 uint8_t write_buf[512]; // 写数据缓存 /* 读取未操作之前的数据 */ printf(------------------- Read SD card block data Test ------------------\\r ); /* 读一个扇区的数据： 0: 从第0个扇区开始。 1：读一个扇区的数据。 0xffff：等待时间。 note：也就是只读了第0个扇区。 */ sdcard_status = HAL_SD_ReadBlocks(hsd, (uint8_t *)read_buf, 0, 1, 0xffff); if(sdcard_status == HAL_OK) printf(Read block data ok! \\r ); for(int i = 0; i 512; i++) printf(0x%02x , read_buf[i]); if((i + 1) % 16 == 0) printf(\\r ); else printf(Read block data fail! status = %d \\r , sdcard_status); /* 向SD卡块写入数据 */ printf(------------------- Write SD card block data Test ------------------\\r ); /* 填充缓冲区数据 */ for(int i = 0; i 512; i++) write_buf[i] = i % 256; // 开始写入数据 /* 写一个扇区的数据： 0: 从第0个扇区开始。 1：写一个扇区的数据。 0xffff：等待时间。 note：也就是只写了第0个扇区。 */ sdcard_status = HAL_SD_WriteBlocks(hsd, (uint8_t *)write_buf, 0, 1, 0xffff); if(sdcard_status == HAL_OK) /* 传输完成不代表写入完成，因此要等待SD卡状态变为可传输状态。擦除操作也是一样。 */ printf(Writing block data. state = %d \\r , HAL_SD_GetCardState(hsd)); while(HAL_SD_GetCardState(hsd) == HAL_SD_CARD_PROGRAMMING); printf(Write block data ok，state = %d \\r , HAL_SD_GetCardState(hsd)); else printf(Write block data fail! status = %d \\r , sdcard_status); /* 读取写入之后的数据 */ printf(------------------- Read SD card block data after Write ------------------\\r ); sdcard_status = HAL_SD_ReadBlocks(hsd, (uint8_t *)read_buf, 0, 1, 0xffff); if(sdcard_status == HAL_OK) printf(Read block data ok! \\r ); for(int i = 0; i 512; i++) printf(0x%02x , read_buf[i]); if((i + 1) % 16 == 0) printf(\\r ); else printf(Read block data fail! status = %d \\r , sdcard_status); /* 擦除SD卡块 */ printf(------------------- Block Erase -------------------------------\\r ); /* 擦除512个扇区的数据： 0: 从第0个扇区开始。 1：一直擦除到512扇区。 note：擦除第0到第512个扇区数据，也包括0和512，也就是一共512个。 */ sdcard_status = HAL_SD_Erase(hsd, 0, 512); // 等待擦除完毕 if(sdcard_status == HAL_OK) printf(Erasing block. state = %d \\r , HAL_SD_GetCardState(hsd)); while(HAL_SD_GetCardState(hsd) == HAL_SD_CARD_PROGRAMMING); printf(Erase block ok state = %d \\r , HAL_SD_GetCardState(hsd)); else printf(Erase block fail! status = %d \\r , sdcard_status); /* 读取擦除之后的数据 */ printf(------------------- Read SD card block data after Erase ------------------\\r ); sdcard_status = HAL_SD_ReadBlocks(hsd, (uint8_t *)read_buf, 0, 1, 0xffff); if(sdcard_status == HAL_OK) printf(Read block data ok \\r ); for(int i = 0; i 512; i++) printf(0x%02x , read_buf[i]); if((i + 1) % 16 == 0) printf(\\r ); else printf(Read block data fail! status = %d \\r , sdcard_status); /** * @brief SD卡DMA读数据（开始前重新初始化DMA，更改传输方向） * * @param hsd * @param pData * @param BlockAdd * @param NumberOfBlocks * * @return none */HAL_StatusTypeDef SDIO_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks) HAL_StatusTypeDef Return_Status; HAL_SD_CardStateTypeDef SD_Card_Status;\t// 读之前，确保SD卡处于可传输状态 do SD_Card_Status = HAL_SD_GetCardState(hsd); while(SD_Card_Status != HAL_SD_CARD_TRANSFER);\t// 重新初始化MDA传输方向 HAL_DMA_DeInit(hdma_sdio); hdma_sdio.Instance = DMA2_Channel4; hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY; hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE; hdma_sdio.Init.MemInc = DMA_MINC_ENABLE; hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD; hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD; hdma_sdio.Init.Mode = DMA_NORMAL; hdma_sdio.Init.Priority = DMA_PRIORITY_LOW; if(HAL_DMA_Init(hdma_sdio) != HAL_OK) Error_Handler(); __HAL_LINKDMA(hsd, hdmarx, hdma_sdio);\t// 开始一次DMA传输 Return_Status = HAL_SD_ReadBlocks_DMA(hsd, pData, BlockAdd, NumberOfBlocks); return Return_Status;/** * @brief SD卡DMA写数据（开始前重新初始化DMA，更改传输方向） * * @param hsd * @param pData * @param BlockAdd * @param NumberOfBlocks * * @return none */HAL_StatusTypeDef SDIO_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks) HAL_StatusTypeDef Return_Status; HAL_SD_CardStateTypeDef SD_Card_Status; do SD_Card_Status = HAL_SD_GetCardState(hsd); while(SD_Card_Status != HAL_SD_CARD_TRANSFER); // 重新初始化MDA传输方向 HAL_DMA_DeInit(hdma_sdio); hdma_sdio.Instance = DMA2_Channel4; hdma_sdio.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE; hdma_sdio.Init.MemInc = DMA_MINC_ENABLE; hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD; hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD; hdma_sdio.Init.Mode = DMA_NORMAL; hdma_sdio.Init.Priority = DMA_PRIORITY_LOW; if(HAL_DMA_Init(hdma_sdio) != HAL_OK) Error_Handler(); __HAL_LINKDMA(hsd, hdmatx, hdma_sdio);\t// 开始一次DMA传输 Return_Status = HAL_SD_WriteBlocks_DMA(hsd, pData, BlockAdd, NumberOfBlocks); return Return_Status;/** * @brief SD卡DMA读写测试 * * @param none * * @return none */void SD_read_writer_dma_test(void) /* SD卡状态 */ int sdcard_status = 0; uint8_t read_buf[512]; // 读数据缓存 uint8_t write_buf[512]; // 写数据缓存 /* 读取未操作之前的数据 */ printf(------------------- Read SD card block data Test ------------------\\r ); /* 读一个扇区的数据： 0: 从第0个扇区开始。 1：读一个扇区的数据。 note：也就是只读了第0个扇区。 */ sdcard_status = SDIO_ReadBlocks_DMA(hsd, (uint8_t *)read_buf, 0, 1); if(sdcard_status == HAL_OK) printf(Read block data ok! \\r ); for(int i = 0; i 512; i++) printf(0x%02x , read_buf[i]); if((i + 1) % 16 == 0) printf(\\r ); else printf(Read block data fail! status = %d \\r , sdcard_status); /* 向SD卡块写入数据 */ printf(------------------- Write SD card block data Test ------------------\\r ); /* 填充缓冲区数据 */ for(int i = 0; i 512; i++) write_buf[i] = i % 256; // 开始写入数据 /* 写一个扇区的数据： 0: 从第0个扇区开始。 1：写一个扇区的数据。 note：也就是只写了第0个扇区。 */ sdcard_status = SDIO_WriteBlocks_DMA(hsd, (uint8_t *)write_buf, 0, 1); if(sdcard_status == HAL_OK) /* 传输完成不代表写入完成，因此要等待SD卡状态变为可传输状态。擦除操作也是一样。 */ printf(Writing block data. state = %d \\r , HAL_SD_GetCardState(hsd)); while(HAL_SD_GetCardState(hsd) == HAL_SD_CARD_PROGRAMMING); printf(Write block data ok，state = %d \\r , HAL_SD_GetCardState(hsd)); else printf(Write block data fail! status = %d \\r , sdcard_status); /* 读取写入之后的数据 */ printf(------------------- Read SD card block data after Write ------------------\\r ); sdcard_status = SDIO_ReadBlocks_DMA(hsd, (uint8_t *)read_buf, 0, 1); if(sdcard_status == HAL_OK) printf(Read block data ok! \\r ); for(int i = 0; i 512; i++) printf(0x%02x , read_buf[i]); if((i + 1) % 16 == 0) printf(\\r ); else printf(Read block data fail! status = %d \\r , sdcard_status); 2.2.3 main.c添加printf支持，在usart.c中添加如下代码 // 需要调用stdio.h文件#include stdio.h// 取消ARM的半主机工作模式#pragma import(__use_no_semihosting)// 标准库需要的支持函数 struct __FILE int handle; ; FILE __stdout; void _sys_exit(int x) // 定义_sys_exit()以避免使用半主机模式 x = x; void _ttywrch(int ch)\t// 这个函数一般情况下应该是不需要的，但是在这里需要\tch = ch;int fputc(int ch, FILE *f) HAL_UART_Transmit(huart1, (uint8_t *)ch, 1, 0xffff);\treturn ch; 在main.c中while之前运行： SD_info_print();SD_read_writer_test(); // 阻塞式读写测试SD_read_writer_dma_test();\t// DMA读写测试 如果均能正常执行，即表示配置无误。 如果第二个函数读写失败：参照修改2.1小节SDIOCLK clock divide factor参数。 如果生成的初始化函数运行卡死：参照修改2.1小节中的void MX_SDIO_SD_Init(void)函数。 注意：如果按照上述流程配置下来，SD_read_writer_test();写出错，而SD_read_writer_dma_test();正常运行是没什么问题的。 因为上面的时钟频率设置的挺高的（SDIOCLK clock divide factor： 2），在此情况下，只能使用DMA模式。 如果不放心，可以把这个参数调大一点之后，然后验证阻塞式读写。验证可以之后再调回来（实际应用中肯定希望速度快一点）。 2.3 移植 FATFS 系统2.3.1 添加源码在确保SD卡读写无误之后，开始移植。 在工程目录创建文件夹并放入FATFS系统源码 Middlewares\\FATFS_R0.15 ffunicode.c ffsystem.c ffconf.h ff.h ff.c diskio.h diskio.c 00readme.txt 00history.txt 并在 Keil 中添加文件和头文件路径。 然后开始适配工作。 2.3.2 修改配置 ffconf.h一些声明的含义可以参考一下网址：http://elm-chan.org/fsw/ff/doc/config.html。 以下内容是把原有的英文注释换成了中文的。并且修改了自己需要的配置。 需要注意的点（需要进行适配）： #define FF_CODE_PAGE\t936 // 支持中文 #define FF_USE_LFN 3 // 支持长文件名，且存在堆区 #define FF_VOLUMES 1 // 一共有一个卷 /* 以下是全部默认拥有的配置 *//* 版本ID */#define FFCONF_DEF\t80286\t/* Revision ID *//* 设置是否只读。建议为0，否则很多API用不了（0：可读写。1：只读）*/#define FF_FS_READONLY\t0/* 此选项定义了最小化级别，以删除一些基本API函数。 0：基本功能已完全启用。建议为0\t1：f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_truncate() and f_rename() 被移除\t2：在 1 的基础上 f_opendir(), f_readdir() and f_closedir() 被移除\t3：在 2 的基础上 f_lseek() 被移除*/#define FF_FS_MINIMIZE\t0/* 设置是否使用查找功能 f_findfirst() and f_findnext(). 0：不启用\t1：启用\t2：同时启用匹配altname[]*/#define FF_USE_FIND 0/* 是否启用格式化功能 f_mkfs()，对于没有格式化为Fat32的U盘或者SD卡，设置为1，否则无法正常初始化。 0：禁止使用 f_mkfs()\t1：允许使用 f_mkfs()*/#define FF_USE_MKFS 1/* 设置是否使用快速查找功能（0：不使用。1：使用）*/#define FF_USE_FASTSEEK\t1/* 设置是否使用拓展功能（0：不使用。1：使用） */#define FF_USE_EXPAND\t1/* 切换属性操作函数 f_chmod（）和 f_utime（）（0：不使用。1：使用）仅在 FF_FS_READONLY 模式下可用*/#define FF_USE_CHMOD\t0/* 切换卷标函数 f_getlabel() and f_setlabel() （0：不使用。1：使用）*/#define FF_USE_LABEL\t1/* 此选项切换 f_forward（）函数。（0:禁用或1:启用） */#define FF_USE_FORWARD\t0/* 设置对字符串的操作 */#define FF_USE_STRFUNC\t1#define FF_PRINT_LLI\t1#define FF_PRINT_FLOAT\t1#define FF_STRF_ENCODE\t3/* FF_USE_STRFUNC switches string functions, f_gets(), f_putc(), f_puts() and f_printf().// 0: Disable. FF_PRINT_LLI, FF_PRINT_FLOAT and FF_STRF_ENCODE have no effect./ 1: Enable without LF-CRLF conversion./ 2: Enable with LF-CRLF conversion.// FF_PRINT_LLI = 1 makes f_printf() support long long argument and FF_PRINT_FLOAT = 1/2/ makes f_printf() support floating point argument. These features want C99 or later./ When FF_LFN_UNICODE = 1 with LFN enabled, string functions convert the character/ encoding in it. FF_STRF_ENCODE selects assumption of character encoding ON THE FILE/ to be read/written via those functions.// 0: ANSI/OEM in current CP/ 1: Unicode in UTF-16LE/ 2: Unicode in UTF-16BE/ 3: Unicode in UTF-8*//* 设置语言支持（932：中文支持。437：英文支持）*/#define FF_CODE_PAGE\t932/* This option specifies the OEM code page to be used on the target system./ Incorrect code page setting can cause a file open failure./ 437 - U.S./ 720 - Arabic/ 737 - Greek/ 771 - KBL/ 775 - Baltic/ 850 - Latin 1/ 852 - Latin 2/ 855 - Cyrillic/ 857 - Turkish/ 860 - Portuguese/ 861 - Icelandic/ 862 - Hebrew/ 863 - Canadian French/ 864 - Arabic/ 865 - Nordic/ 866 - Russian/ 869 - Greek 2/ 932 - Japanese (DBCS)/ 936 - Simplified Chinese (DBCS)/ 949 - Korean (DBCS)/ 950 - Traditional Chinese (DBCS)/ 0 - Include all code pages above and configured by f_setcp()*/#define FF_USE_LFN 0#define FF_MAX_LFN 255/* The FF_USE_LFN switches the support for LFN (long file name).// 0: Disable LFN. FF_MAX_LFN has no effect.（默认最长12个字符）/ 1: Enable LFN with static working buffer on the BSS. Always NOT thread-safe./ 2: Enable LFN with dynamic working buffer on the STACK./ 3: Enable LFN with dynamic working buffer on the HEAP.// To enable the LFN, ffunicode.c needs to be added to the project. The LFN function/ requiers certain internal working buffer occupies (FF_MAX_LFN + 1) * 2 bytes and/ additional (FF_MAX_LFN + 44) / 15 * 32 bytes when exFAT is enabled./ The FF_MAX_LFN defines size of the working buffer in UTF-16 code unit and it can/ be in range of 12 to 255. It is recommended to be set it 255 to fully support LFN/ specification./ When use stack for the working buffer, take care on stack overflow. When use heap/ memory for the working buffer, memory management functions, ff_memalloc() and/ ff_memfree() exemplified in ffsystem.c, need to be added to the project. */#define FF_LFN_UNICODE\t0/* This option switches the character encoding on the API when LFN is enabled.// 0: ANSI/OEM in current CP (TCHAR = char)/ 1: Unicode in UTF-16 (TCHAR = WCHAR)/ 2: Unicode in UTF-8 (TCHAR = char)/ 3: Unicode in UTF-32 (TCHAR = DWORD)// Also behavior of string I/O functions will be affected by this option./ When LFN is not enabled, this option has no effect. */#define FF_LFN_BUF 255#define FF_SFN_BUF 12/* This set of options defines size of file name members in the FILINFO structure/ which is used to read out directory items. These values should be suffcient for/ the file names to read. The maximum possible length of the read file name depends/ on character encoding. When LFN is not enabled, these options have no effect. */#define FF_FS_RPATH 0/* This option confatfs文件系统移植 support for relative path.// 0: Disable relative path and remove related functions./ 1: Enable relative path. f_chdir() and f_chdrive() are available./ 2: f_getcwd() function is available in addition to 1.*//* Number of volumes (logical drives) to be used. (1-10) */#define FF_VOLUMES 1#define FF_STR_VOLUME_ID\t0#define FF_VOLUME_STRS RAM,NAND,CF,SD,SD2,USB,USB2,USB3/* FF_STR_VOLUME_ID switches support for volume ID in arbitrary strings./ When FF_STR_VOLUME_ID is set to 1 or 2, arbitrary strings can be used as drive/ number in the path name. FF_VOLUME_STRS defines the volume ID strings for each/ logical drives. Number of items must not be less than FF_VOLUMES. Valid/ characters for the volume ID strings are A-Z, a-z and 0-9, however, they are/ compared in case-insensitive. If FF_STR_VOLUME_ID = 1 and FF_VOLUME_STRS is/ not defined, a user defined volume string table is needed as:// const char* VolumeStr[FF_VOLUMES] = ram,flash,sd,usb,...*/#define FF_MULTI_PARTITION\t0/* This option switches support for multiple volumes on the physical drive./ By default (0), each logical drive number is bound to the same physical drive/ number and only an FAT volume found on the physical drive will be mounted./ When this function is enabled (1), each logical drive number can be bound to/ arbitrary physical drive and partition listed in the VolToPart[]. Also f_fdisk()/ function will be available. */#define FF_MIN_SS 512#define FF_MAX_SS 512/* This set of options confatfs文件系统移植 the range of sector size to be supported. (512,/ 1024, 2048 or 4096) Always set both 512 for most systems, generic memory card and/ harddisk, but a larger value may be required for on-board flash memory and some/ type of optical media. When FF_MAX_SS is larger than FF_MIN_SS, FatFs is configured/ for variable sector size mode and disk_ioctl() function needs to implement/ GET_SECTOR_SIZE command. */#define FF_LBA64 0/* This option switches support for 64-bit LBA. (0:Disable or 1:Enable)/ To enable the 64-bit LBA, also exFAT needs to be enabled. (FF_FS_EXFAT == 1) */#define FF_MIN_GPT 0x10000000/* Minimum number of sectors to switch GPT as partitioning format in f_mkfs and/ f_fdisk function. 0x100000000 max. This option has no effect when FF_LBA64 == 0. */#define FF_USE_TRIM 0/* This option switches support for ATA-TRIM. (0:Disable or 1:Enable)/ To enable Trim function, also CTRL_TRIM command should be implemented to the/ disk_ioctl() function. */#define FF_FS_TINY 0/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)/ At the tiny configuration, size of file object (FIL) is shrinked FF_MAX_SS bytes./ Instead of private sector buffer eliminated from the file object, common sector/ buffer in the filesystem object (FATFS) is used for the file data transfer. */#define FF_FS_EXFAT 0/* This option switches support for exFAT filesystem. (0:Disable or 1:Enable)/ To enable exFAT, also LFN needs to be enabled. (FF_USE_LFN = 1)/ Note that enabling exFAT discards ANSI C (C89) compatibility. */#define FF_FS_NORTC 0#define FF_NORTC_MON\t1#define FF_NORTC_MDAY\t1#define FF_NORTC_YEAR\t2022/* The option FF_FS_NORTC switches timestamp feature. If the system does not have/ an RTC or valid timestamp is not needed, set FF_FS_NORTC = 1 to disable the/ timestamp feature. Every object modified by FatFs will have a fixed timestamp/ defined by FF_NORTC_MON, FF_NORTC_MDAY and FF_NORTC_YEAR in local time./ To enable timestamp function (FF_FS_NORTC = 0), get_fattime() function need to be/ added to the project to read current time form real-time clock. FF_NORTC_MON,/ FF_NORTC_MDAY and FF_NORTC_YEAR have no effect./ These options have no effect in read-only configuration (FF_FS_READONLY = 1). */#define FF_FS_NOFSINFO\t0/* If you need to know correct free space on the FAT32 volume, set bit 0 of this/ option, and f_getfree() function at the first time after volume mount will force/ a full FAT scan. Bit 1 controls the use of last allocated cluster number.// bit0=0: Use free cluster count in the FSINFO if available./ bit0=1: Do not trust free cluster count in the FSINFO./ bit1=0: Use last allocated cluster number in the FSINFO if available./ bit1=1: Do not trust last allocated cluster number in the FSINFO.*/#define FF_FS_LOCK 0/* The option FF_FS_LOCK switches file lock function to control duplicated file open/ and illegal operation to open objects. This option must be 0 when FF_FS_READONLY/ is 1.// 0: Disable file lock function. To avoid volume corruption, application program/ should avoid illegal open, remove and rename to the open objects./ 0: Enable file lock function. The value defines how many files/sub-directories/ can be opened simultaneously under file lock control. Note that the file/ lock control is independent of re-entrancy. */#define FF_FS_REENTRANT\t0#define FF_FS_TIMEOUT\t1000/* The option FF_FS_REENTRANT switches the re-entrancy (thread safe) of the FatFs/ module itself. Note that regardless of this option, file access to different/ volume is always re-entrant and volume control functions, f_mount(), f_mkfs()/ and f_fdisk() function, are always not re-entrant. Only file/directory access/ to the same volume is under control of this featuer.// 0: Disable re-entrancy. FF_FS_TIMEOUT have no effect./ 1: Enable re-entrancy. Also user provided synchronization handlers,/ ff_mutex_create(), ff_mutex_delete(), ff_mutex_take() and ff_mutex_give()/ function, must be added to the project. Samples are available in ffsystem.c.// The FF_FS_TIMEOUT defines timeout period in unit of O/S time tick.*/ 这里设置了支持长文件名，并且相关内容要申请堆中的内存，因此这里需要增大堆内存的空间。 也可以直接从启动文件处修改 2.3.3 底层适配 diskio.c需要适配的函数如下 第一步：设备编号定义 这里只有一个设备（SD卡），把DEV_MMC编号改为0。（要求从0开始按顺序增加） 其他的可以按顺序编号，当然也可以直接删掉。但是为了以后增加，建议保留。 /* Definitions of physical drive number for each drive */#define DEV_RAM 1\t/* Example: Map Ramdisk to physical drive 0 */#define DEV_MMC 0\t/* Example: Map MMC/SD card to physical drive 1 */#define DEV_USB 2\t/* Example: Map USB MSD to physical drive 2 */ 这里名字其实是可以改的，比如改为（正点原子就是这样的）： #define SD_CARD 0 // SD卡,卷标为0#define EX_FLASH 1 // 外部spi flash,卷标为1 如果改了，下面的适配函数也都一样改就可以了。 第二步：添加头文件 因为需要用到我们前面写好的驱动以及printf调试输出，把头文件添加进来。 #include spi_sdcard.h#include stdio.h 第三步：函数适配 这里直接默认返回OK，没什么问题，其他类型的设备注释掉即可。需要用的话再修改。 DSTATUS disk_status (\tBYTE pdrv /* Physical drive nmuber to identify the drive */)\tDSTATUS stat;\tswitch (pdrv) case DEV_RAM :\t// 还没用到，先注释掉 // result = RAM_disk_status(); // translate the reslut code here return stat;\tcase DEV_MMC : return 0;\t// 默认没什么问题\tcase DEV_USB :\t// 还没用到，先注释掉 // result = USB_disk_status(); // translate the reslut code here return stat; return STA_NOINIT; 初始化调用我们前面写好的驱动 DSTATUS disk_initialize (\tBYTE pdrv /* Physical drive nmuber to identify the drive */)\tDSTATUS stat;\tswitch (pdrv) case DEV_RAM :\t// 还没用到，先注释掉 // result = RAM_disk_initialize(); // translate the reslut code here return stat;\tcase DEV_MMC : if(SD_Init() == 0) // SD_Init()是SD初始化函数，无错误返回0 return 0; else return STA_NOINIT;\tcase DEV_USB :\t// 还没用到，先注释掉 // result = USB_disk_initialize(); // translate the reslut code here return stat; return STA_NOINIT; 读扇区函数，一样的调用前面的驱动 DRESULT disk_read (\tBYTE pdrv, /* Physical drive nmuber to identify the drive */\tBYTE *buff, /* Data buffer to store read data */\tLBA_t sector,\t/* Start sector in LBA */\tUINT count /* Number of sectors to read */)\tDRESULT res;\tswitch (pdrv) case DEV_RAM : // translate the arguments here // result = RAM_disk_read(buff, sector, count); // translate the reslut code here return res;\tcase DEV_MMC : res = (DRESULT) SD_ReadDisk(buff, sector, count); while(res)\t// 读出错 printf(sd read error:%d\\r , res); SD_Init();\t// 重新初始化SD卡 res = (DRESULT) SD_ReadDisk(buff,sector,count); return res;\tcase DEV_USB : // translate the arguments here // result = USB_disk_read(buff, sector, count); // translate the reslut code here return res; return RES_PARERR; 写扇区函数，还是调用写好的驱动 DRESULT disk_write (\tBYTE pdrv, /* Physical drive nmuber to identify the drive */\tconst BYTE *buff,\t/* Data to be written */\tLBA_t sector, /* Start sector in LBA */\tUINT count /* Number of sectors to write */)\tDRESULT res;\tswitch (pdrv) case DEV_RAM : // translate the arguments here // result = RAM_disk_write(buff, sector, count); // translate the reslut code here return res;\tcase DEV_MMC : res = (DRESULT) SD_WriteDisk((uint8_t *)buff, sector, count); while(res)\t// 写出错 printf(sd write error:%d\\r , res); SD_Init();\t// 重新初始化SD卡 res = (DRESULT) SD_WriteDisk((uint8_t *)buff, sector, count); return res;\tcase DEV_USB : // translate the arguments here // result = USB_disk_write(buff, sector, count); // translate the reslut code here return res; return RES_PARERR; 命令函数 DRESULT disk_ioctl (\tBYTE pdrv, /* Physical drive nmuber (0..) */\tBYTE cmd, /* Control code */\tvoid *buff /* Buffer to send/receive control data */)\tDRESULT res;\tswitch (pdrv) case DEV_RAM : // Process of the command for the RAM drive return res;\tcase DEV_MMC : switch(cmd) #if FF_FS_READONLY == 0 case CTRL_SYNC: res = RES_OK; break;#endif#if FF_USE_MKFS == 1 case GET_SECTOR_COUNT: *(DWORD*)buff = SD_GetSectorCount(); res = RES_OK; break; case GET_BLOCK_SIZE: *(WORD*)buff = 8; res = RES_OK; break;#endif#if FF_MAX_SS != FF_MIN_SS case GET_SECTOR_SIZE: *(DWORD*)buff = 512; res = RES_OK; break; #endif default: res = RES_PARERR; break; return res;\tcase DEV_USB : // Process of the command the USB drive return res; return RES_PARERR; 在此文件的最后添加一个获取时间的函数，默认返回0 DWORD get_fattime(void) return 0; 2.3.4 验证 main.c把以下代码放在main函数中执行，如果成功执行，说明没问题。 这里执行 f_res f_mount(fs, “0:”, 1)，标号0就是diskio.c开头定义的标号。 FATFS fs; /* FatFs 文件系统对象 */FRESULT f_res; /* 文件操作结果 */BYTE work[FF_MAX_SS];FIL file; /* 文件对象 */UINT fnum; /* 文件成功读写数量 */BYTE ReadBuffer[1024] = 0; /* 读缓冲区 */BYTE WriteBuffer[] = This is STM32 working with FatFs \\r ;\t/* 写缓冲区 */// 在外部 SD 卡挂载文件系统，文件系统挂载时会对 SD 卡初始化// note:必须先要保证SD卡正常拥有FAT文件系统，如果没有会失败。 f_res = f_mount(fs, 0:, 1);/* 如果没有文件系统就格式化创建创建文件系统 */ if(f_res == FR_NO_FILESYSTEM) printf(The SD card does not yet have a file system and is about to be formatted... \\r ); /* 格式化 */\tf_res = f_mkfs(0:, NULL, work, sizeof(work));\t/* Create a FAT volume */ if(f_res == FR_OK) printf(The SD card successfully formatted the file system\\r ); /* 格式化后，先取消挂载 */ f_res = f_mount(NULL, 0:, 1); /* 重新挂载 */ f_res = f_mount(fs, 0:, 1); else printf(The format failed\\r ); while(1); else if(f_res != FR_OK) printf(mount error : %d \\r , f_res); while(1); else printf(mount sucess!!! \\r ); /*----------------------- 文件系统测试：写测试 -----------------------------*/ /* 打开文件，如果文件不存在则创建它 */ printf(\\r ****** Create and Open new text file objects with write access ****** \\r ); f_res = f_open(file, 0:FatFs STM32cube.txt, FA_CREATE_ALWAYS | FA_WRITE); if(f_res == FR_OK) printf(open file sucess!!! \\r ); /* 将指定存储区内容写入到文件内 */ printf(\\r ****** Write data to the text files ******\\r ); f_res = f_write(file, WriteBuffer, sizeof(WriteBuffer), fnum); if(f_res == FR_OK) printf(write file sucess!!! (%d)\\r , fnum); printf(write Data : %s\\r , WriteBuffer); else printf(write file error : %d\\r , f_res); /* 不再读写，关闭文件 */ f_close(file); else printf(open file error : %d\\r , f_res); /*------------------- 文件系统测试：读测试 ------------------------------------*/ printf(\\r ****** Read data from the text files ******\\r ); f_res = f_open(file, 0:FatFs STM32cube.txt, FA_OPEN_EXISTING | FA_READ); if(f_res == FR_OK) printf(open file sucess!!! \\r ); f_res = f_read(file, ReadBuffer, sizeof(ReadBuffer), fnum); if(f_res == FR_OK) printf(read sucess!!! (%d)\\r , fnum); printf(read Data : %s\\r , ReadBuffer); else printf( read error!!! %d\\r , f_res); else printf(open file error : %d\\r , f_res); /* 不再读写，关闭文件 */ f_close(file); /* 不再使用文件系统，取消挂载文件系统 */ f_mount(NULL, 0:, 1); /* 操作完成，停机 */ 其他 API 的使用参考 FATFS 官网：http://elm-chan.org/fsw/ff/00index_e.html 3. TF卡 SPI 模式移植这里使用RTT正点原子的潘多拉loT Board开发板，主控芯片为STM32L475VET6。开发板上TF卡与主控的通信采用SPI通信。 原理图如下： SPI1_SCK：PA5 SPI1_MISO：PA6 SPI1_MOSI：PA7 SD_CS：PC3 3.1 创建工程使用CubeMX创建一个工程。需要配置的项目有： 时钟 程序调试接口 串口（用于观察调试信息） SPI 接口 片选引脚CS（推挽输出，默认高电平，速度最快，上拉） 其中 SPI 接口的配置如下： SPI 与 SD卡 通信，在卡识别阶段，时钟频率不能超过400K。在传输数据阶段可以更高，最多不超过25M。不同的卡上限不太一样。 这里初始化时先设置一个较低的速度，识别完成之后更改 SPI 波特率即可。 3.2 SD卡读写验证3.2.1 spi_sdcard.h#ifndef __SPI_SDCARD_H#define __SPI_SDCARD_H#include stdint.h/*\tSD_CS: PC3 // 片选*/#define\tSD_CS_SET(n)\t(n?HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_SET):HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET))// SD卡类型定义 #define SD_TYPE_ERR 0X00#define SD_TYPE_MMC 0X01#define SD_TYPE_V1 0X02#define SD_TYPE_V2 0X04#define SD_TYPE_V2HC 0X06// SD卡指令表 #define CMD0 0 // 卡复位#define CMD1 1#define CMD8 8 // 命令8 ，SEND_IF_COND#define CMD9 9 // 命令9 ，读CSD数据#define CMD10 10 // 命令10，读CID数据#define CMD12 12 // 命令12，停止数据传输#define CMD16 16 // 命令16，设置SectorSize 应返回0x00#define CMD17 17 // 命令17，读sector#define CMD18 18 // 命令18，读Multi sector#define CMD23 23 // 命令23，设置多sector写入前预先擦除N个block#define CMD24 24 // 命令24，写sector#define CMD25 25 // 命令25，写Multi sector#define CMD41 41 // 命令41，应返回0x00#define CMD55 55 // 命令55，应返回0x01#define CMD58 58 // 命令58，读OCR信息#define CMD59 59 // 命令59，使能/禁止CRC，应返回0x00// 数据写入回应字意义#define MSD_DATA_OK 0x05#define MSD_DATA_CRC_ERROR 0x0B#define MSD_DATA_WRITE_ERROR 0x0D#define MSD_DATA_OTHER_ERROR 0xFF// SD卡回应标记字#define MSD_RESPONSE_NO_ERROR 0x00#define MSD_IN_IDLE_STATE 0x01#define MSD_ERASE_RESET 0x02#define MSD_ILLEGAL_COMMAND 0x04#define MSD_COM_CRC_ERROR 0x08#define MSD_ERASE_SEQUENCE_ERROR 0x10#define MSD_ADDRESS_ERROR 0x20#define MSD_PARAMETER_ERROR 0x40#define MSD_RESPONSE_FAILURE 0xFF/* ========================== 以下通信部分修改区 ============================*/void SD_SPI_SetSpeed(uint8_t SPI_BaudRatePrescaler);uint8_t SD_SPI_ReadWriteByte(uint8_t TxData);uint8_t SD_SPI_WriteByte(uint8_t TxData);/* ========================== 以上通信部分修改区 ============================*//* ========================== 以下SD卡通信修改区 ============================*/extern uint8_t SD_Type; //SD卡的类型uint8_t SD_ReadWriteByte(uint8_t data);void SD_SpeedLow(void);void SD_SpeedHigh(void);/* ========================== 以上SD卡通信修改区 ============================*//* ========================== 以下SD卡通信实现区（无需修改） ============================*/uint8_t SD_WaitReady(void); // 等待SD卡准备void SD_DisSelect(void); // 取消片选uint8_t SD_Select(void); // 片选选中uint8_t SD_GetResponse(uint8_t Response); // 获得响应uint8_t SD_RecvData(uint8_t *buf, uint16_t len); // 读sd卡512字节（一个扇区）uint8_t SD_SendBlock(uint8_t *buf, uint8_t cmd); // 向sd卡写512字节（一个扇区）uint8_t SD_SendCmd(uint8_t cmd, uint32_t arg, uint8_t crc); // 发送命令uint8_t SD_GetCID(uint8_t *cid_data); // 读SD卡CIDuint8_t SD_GetCSD(uint8_t *csd_data); // 读SD卡CSDuint32_t SD_GetSectorCount(void); // 读扇区数uint8_t SD_Init(void); // 初始化uint8_t SD_ReadDisk(uint8_t *buf, uint32_t sector, uint8_t cnt);\t// 写块，连续读扇区uint8_t SD_WriteDisk(uint8_t *buf, uint32_t sector, uint8_t cnt);\t// 读块，连续写扇区/* ========================== 以上SD卡通信实现区（无需修改） ============================*/#endif\t/* __SPI_SDCARD_H */ 3.2.2 spi_sdcard.c#include spi_sdcard.h#include stdio.h\t// 调试信息输出#include spi.h // cubemx生成的#include usart.h // cubemx生成的/* ========================== 以下通信部分修改区 ============================*/extern SPI_HandleTypeDef hspi1;#define SD_SPI hspi1 // 减少移植时需要修改的地方/** * @brief SD_SPI 速度设置函数 * * @param SPI_BaudRate_Prescaler SPI_BAUDRATEPRESCALER_2~SPI_BAUDRATEPRESCALER_256（2的倍数） * * @return void * * @remark SD卡初始化时，波特率不能超过400k，传输数据时可以很高（不同SD卡的最高范围不同）。 * */void SD_SPI_SetSpeed(uint8_t SPI_BaudRatePrescaler) assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler)); // 判断有效性 __HAL_SPI_DISABLE(SD_SPI); // 先关闭SPI // hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256; // 设置波特率 SD_SPI.Instance-CR1 = 0XFFC7; // 位3-5清零，用来设置波特率 SD_SPI.Instance-CR1 |= SPI_BaudRatePrescaler; // 设置SPI速度 __HAL_SPI_ENABLE(SD_SPI); // 重新使能SPI/** * @brief SD_SPI 读写一个字节 * * @param TxData 要写入的字节 * * @return uint8_t 读取到的字节 */uint8_t SD_SPI_ReadWriteByte(uint8_t TxData) uint8_t Rxdata; HAL_SPI_TransmitReceive(SD_SPI, TxData, Rxdata, 1, 1000); return Rxdata;/** * @brief SD_SPI 写入一个字节 * * @param TxData 要写入的字节 * * @return uint8_t 0:写入成功,其他:写入失败 */uint8_t SD_SPI_WriteByte(uint8_t TxData) return HAL_SPI_Transmit(SD_SPI, TxData, 1, 1000);/* ========================== 以上通信部分修改区 ============================*//* ========================== 以下SD卡通信修改区 ============================*/uint8_t SD_Type = 0; // SD卡的类型/** * @brief SD卡底层读写一个字节 * * @param data 要写入的字节 * * @return uint8_t 读取到的字节 * * @remark 调用SPI读写 */uint8_t SD_ReadWriteByte(uint8_t data) return SD_SPI_ReadWriteByte(data);/** * @brief SD卡初始化的时候,需要低速（400K以下） * * @param void * * @return void * * @remark 根据自己的芯片选择合适的分频系数 STM32L475VET6在这个分频系数下对应的是312.5K */void SD_SpeedLow(void) // 初始化时设置到低速模式 SD_SPI_SetSpeed(SPI_BAUDRATEPRESCALER_256);/** * @brief SD卡正常工作的时候,可以高速 * * @param void * * @return void * * @remark 根据自己的芯片选择合适的分频系数 STM32L475VET6在这个分频系数下对应的是40M */void SD_SpeedHigh(void) // 传输数据时设置到高速模式 SD_SPI_SetSpeed(SPI_BAUDRATEPRESCALER_2); // STM32L475VET6对应的是40M/* ========================== 以上SD卡通信修改区 ============================*//* ========================== 以下SD卡通信实现区（无需修改） ============================*//** * @brief 等待卡准备好 * * @param void * * @return uint8_t 0,准备好了;其他,错误代码 */uint8_t SD_WaitReady(void) uint32_t t = 0; do if(SD_SPI_ReadWriteByte(0XFF) == 0XFF) return 0; // OK t++; while(t 0XFFFFFF);\t// 等待 return 1;/** * @brief 取消选择,释放SPI总线 * * @param void * * @return void */void SD_DisSelect(void) SD_CS_SET(1); SD_ReadWriteByte(0xff); // 提供额外的8个时钟/** * @brief 选择SD卡,并且等待卡准备OK * * @param void * * @return 0,成功;1,失败; */uint8_t SD_Select(void) SD_CS_SET(0); if(SD_WaitReady() == 0) return 0;\t// 等待成功 SD_DisSelect(); return 1;\t// 等待失败/** * @brief 等待SD卡回应 * * @param Response\t要得到的回应值 * * @return uint8_t 0,成功得到了该回应值。其他,得到回应值失败。 */uint8_t SD_GetResponse(uint8_t Response) uint16_t Count = 0xFFFF; // 等待次数 while((SD_SPI_ReadWriteByte(0XFF) != Response) Count) Count--; // 等待得到准确的回应 if(Count == 0) return MSD_RESPONSE_FAILURE;\t// 得到回应失败 else return MSD_RESPONSE_NO_ERROR;\t// 正确回应/** * @brief 从sd卡读取一个数据包的内容 * * @param buf 数据缓存区 * @param len 要读取的数据长度 * * @return uint8_t 0,成功;其他,失败 */uint8_t SD_RecvData(uint8_t *buf, uint16_t len) if(SD_GetResponse(0xFE)) return 1;\t// 等待SD卡发回数据起始令牌0xFE while(len--)\t// 开始接收数据 *buf = SD_ReadWriteByte(0xFF); buf++; //下面是2个伪CRC（dummy CRC） SD_SPI_ReadWriteByte(0xFF); SD_SPI_ReadWriteByte(0xFF); return 0; // 读取成功/** * @brief 向sd卡写入一个数据包的内容 512字节 * * @param buf 数据缓存区 * @param cmd 指令 * * @return uint8_t 0,成功;其他,失败 */uint8_t SD_SendBlock(uint8_t *buf, uint8_t cmd) uint16_t t; if(SD_WaitReady()) return 1;\t// 等待准备失效 SD_ReadWriteByte(cmd); if(cmd != 0XFD)\t// 不是结束指令 for(t = 0; t 512; t++) SD_ReadWriteByte(buf[t]); // 提高速度,减少函数传参时间 SD_ReadWriteByte(0xFF);\t// 忽略crc SD_ReadWriteByte(0xFF); t = SD_SPI_ReadWriteByte(0xFF);\t// 接收响应 if((t 0x1F) != 0x05) return 2;\t// 响应错误 return 0;\t// 写入成功/** * @brief 向SD卡发送一个命令 * * @param cmd 命令 * @param arg 命令参数 * @param crc crc校验值 * * @return uint8_t SD卡返回的响应 */uint8_t SD_SendCmd(uint8_t cmd, uint32_t arg, uint8_t crc) uint8_t r1; uint8_t Retry = 0; SD_DisSelect(); // 取消上次片选 if(SD_Select()) return 0XFF;\t// 片选失效 // 发送 SD_ReadWriteByte(cmd | 0x40);\t// 分别写入命令 SD_ReadWriteByte(arg 24); SD_ReadWriteByte(arg 16); SD_ReadWriteByte(arg 8); SD_ReadWriteByte(arg); SD_ReadWriteByte(crc); if(cmd == CMD12) SD_ReadWriteByte(0xff); // Skip a stuff byte when stop reading // 等待响应，或超时退出 Retry = 0X1F;\tdo r1 = SD_ReadWriteByte(0xFF); while((r1 0X80) Retry--); return r1;\t// 返回状态值/** * @brief 获取SD卡的CID信息，包括制造商信息 * * @param cid_data 存放CID的内存，至少16Byte * * @return uint8_t 0：NO_ERR。1：错误 */uint8_t SD_GetCID(uint8_t *cid_data) uint8_t r1; // 发CMD10命令，读CID r1 = SD_SendCmd(CMD10, 0, 0x01); if(r1 == 0x00) r1 = SD_RecvData(cid_data, 16); // 接收16个字节的数据 SD_DisSelect();\t// 取消片选 if(r1) return 1; else return 0;/** * @brief 获取SD卡的CSD信息，包括容量和速度信息 * * @param cid_data 存放CSD的内存，至少16Byte * * @return uint8_t 0：NO_ERR。1：错误 */uint8_t SD_GetCSD(uint8_t *csd_data) uint8_t r1; r1 = SD_SendCmd(CMD9, 0, 0x01); // 发CMD9命令，读CSD if(r1 == 0) r1 = SD_RecvData(csd_data, 16); // 接收16个字节的数据 SD_DisSelect();//取消片选 if(r1)return 1; else return 0;/** * @brief 获取SD卡的总扇区数（扇区数）每扇区的字节数必为512，因为如果不是512，则初始化不能通过. * * @param void * * @return uint32_t\t0： 取容量出错。其他:SD卡的容量(扇区数/512字节) */uint32_t SD_GetSectorCount(void) uint8_t csd[16]; uint32_t Capacity; uint8_t n; uint16_t csize; // 取CSD信息，如果期间出错，返回0 if(SD_GetCSD(csd) != 0) return 0; printf(SD_GetCSD(csd):[%d]\\r , csd[0]); // 如果为SDHC卡，按照下面方式计算 if((csd[0] 0xC0) == 0x40)\t// V2.00的卡 csize = csd[9] + ((uint16_t)csd[8] 8) + 1; Capacity = (uint32_t)csize 10;\t// 得到扇区数 else // V1.XX的卡 n = (csd[5] 15) + ((csd[10] 128) 7) + ((csd[9] 3) 1) + 2; csize = (csd[8] 6) + ((uint16_t)csd[7] 2) + ((uint16_t)(csd[6] 3) 10) + 1; Capacity = (uint32_t)csize (n - 9); // 得到扇区数 return Capacity;/** * @brief 初始化SD卡 * * @param void * * @return uint8_t 0:初始化成功,其他：初始化错误 */uint8_t SD_Init(void) uint8_t r1; // 存放SD卡的返回值 uint16_t retry; // 用来进行超时计数 uint8_t buf[4]; uint16_t i; SD_SpeedLow(); // 设置到低速模式 for(i = 0; i 10; i++) SD_ReadWriteByte(0XFF);\t// 发送最少74个脉冲 retry = 20; do r1 = SD_SendCmd(CMD0, 0, 0x95); // 进入IDLE状态 while((r1 != 0X01) retry--); SD_Type = 0;\t// 默认无卡 if(r1 == 0X01) if(SD_SendCmd(CMD8, 0x1AA, 0x87) == 1)\t// SD V2.0 for(i = 0; i 4; i++) buf[i] = SD_ReadWriteByte(0XFF);\t// Get trailing return value of R7 resp if(buf[2] == 0X01 buf[3] == 0XAA) // 卡是否支持2.7~3.6V retry = 0XFFFE; do SD_SendCmd(CMD55, 0, 0X01); // 发送CMD55 r1 = SD_SendCmd(CMD41, 0x40000000, 0X01);\t// 发送CMD41 while(r1 retry--); if(retry SD_SendCmd(CMD58, 0, 0X01) == 0)\t// 鉴别SD2.0卡版本开始 for(i = 0; i 4; i++) buf[i] = SD_ReadWriteByte(0XFF);\t// 得到OCR值 if(buf[0] 0x40) SD_Type = SD_TYPE_V2HC; // 检查CCS else SD_Type = SD_TYPE_V2; else // SD V1.x/ MMC V3 SD_SendCmd(CMD55, 0, 0X01); // 发送CMD55 r1 = SD_SendCmd(CMD41, 0, 0X01);\t// 发送CMD41 if(r1 = 1) SD_Type = SD_TYPE_V1; retry = 0XFFFE; do // 等待退出IDLE模式 SD_SendCmd(CMD55, 0, 0X01); // 发送CMD55 r1 = SD_SendCmd(CMD41, 0, 0X01);\t// 发送CMD41 while(r1 retry--); else // MMC卡不支持CMD55+CMD41识别 SD_Type = SD_TYPE_MMC; // MMC V3 retry = 0XFFFE; do // 等待退出IDLE模式 r1 = SD_SendCmd(CMD1, 0, 0X01); // 发送CMD1 while(r1 retry--); if(retry == 0 || SD_SendCmd(CMD16, 512, 0X01) != 0)SD_Type = SD_TYPE_ERR; // 错误的卡 SD_DisSelect(); // 取消片选 SD_SpeedHigh(); // 高速 if(SD_Type) return 0; else if(r1) return r1; return 0xaa;\t// 其他错误/** * @brief 读SD卡，连续读扇区 * * @param buf 数据缓存区 * @param sector 扇区 * @param cnt 扇区数 * * @return uint8_t 0,OK;其他,失败. */uint8_t SD_ReadDisk(uint8_t *buf, uint32_t sector, uint8_t cnt) uint8_t r1; if(SD_Type != SD_TYPE_V2HC) sector = 9;\t// 转换为字节地址 if(cnt == 1) r1 = SD_SendCmd(CMD17, sector, 0X01); // 读命令 if(r1 == 0) // 指令发送成功 r1 = SD_RecvData(buf, 512); // 接收512个字节 else r1 = SD_SendCmd(CMD18, sector, 0X01);\t// 连续读命令 do r1 = SD_RecvData(buf, 512); // 接收512个字节 buf += 512; while(--cnt r1 == 0); SD_SendCmd(CMD12, 0, 0X01); // 发送停止命令 SD_DisSelect();\t// 取消片选 return r1;/** * @brief 写SD卡，连续写扇区 * * @param buf 数据缓存区 * @param sector 起始扇区 * @param cnt 扇区数 * * @return uint8_t 0,OK;其他,失败. */uint8_t SD_WriteDisk(uint8_t *buf, uint32_t sector, uint8_t cnt) uint8_t r1; if(SD_Type != SD_TYPE_V2HC) sector *= 512;\t// 转换为字节地址 if(cnt == 1) r1 = SD_SendCmd(CMD24, sector, 0X01); // 读命令 if(r1 == 0) // 指令发送成功 r1 = SD_SendBlock(buf, 0xFE);\t// 写512个字节 else if(SD_Type != SD_TYPE_MMC) SD_SendCmd(CMD55, 0, 0X01); SD_SendCmd(CMD23, cnt, 0X01); // 发送指令 r1 = SD_SendCmd(CMD25, sector, 0X01);\t// 连续读命令 if(r1 == 0) do r1 = SD_SendBlock(buf, 0xFC);\t// 接收512个字节 buf += 512; while(--cnt r1 == 0); r1 = SD_SendBlock(0, 0xFD); // 接收512个字节 SD_DisSelect();\t// 取消片选 return r1;/* ========================== 以上SD卡通信实现区（无需修改） ============================*/ 3.2.3 main.c添加printf支持，在usart.c中添加如下代码 // 需要调用stdio.h文件#include stdio.h// 取消ARM的半主机工作模式#pragma import(__use_no_semihosting)// 标准库需要的支持函数 struct __FILE int handle; ; FILE __stdout; void _sys_exit(int x) // 定义_sys_exit()以避免使用半主机模式 x = x; void _ttywrch(int ch)\t// 这个函数一般情况下应该是不需要的，但是在这里需要\tch = ch;int fputc(int ch, FILE *f) HAL_UART_Transmit(huart1, (uint8_t *)ch, 1, 0xffff);\treturn ch; 把以下代码放在main函数中执行 uint8_t buf[512];uint8_t sta = 0;while(SD_Init())\t// 检测不到SD卡 printf(initing...!\\r ); HAL_Delay(100);printf(SD Card Size = %d MB \\r , SD_GetSectorCount() 11);\t// 每个扇区512字节printf(SD Card Capacity = %d\\r , SD_GetSectorCount()); // 每个扇区512字节// 从0扇区开始，读取一个扇区的数据if(SD_ReadDisk(buf, 0, 1) == 0) printf(USART1 Sending Data...\\r ); printf(SECTOR 0 DATA:\\r ); for(uint32_t sd_size = 0; sd_size 512; sd_size++) printf(%x , buf[sd_size]); // 打印0扇区数据 printf(\\r USART1 Send Data Over! \\r );// 修改数组中的数据for(uint32_t i = 0; i 512; i++) buf[i] = i * 3; // 初始化写入的数据,是3的倍数.// 从第0个扇区开始读取一个扇区的数据sta = SD_WriteDisk(buf, 0, 1);if(sta == 0) printf(Write over!\\r );else printf(err:%d\\r , sta);// 从0扇区开始，读取一个扇区的数据（验证是否是写入的数据）if(SD_ReadDisk(buf, 0, 1) == 0) printf(USART1 Sending Data...\\r ); printf(SECTOR 0 DATA:\\r ); for(uint32_t sd_size = 0; sd_size 512; sd_size++) printf(%x , buf[sd_size]); // 打印0扇区数据 printf(\\r USART1 Send Data Over! \\r ); 如果程序正常执行，说明SD卡读写没问题。可以进行下一步。 3.3 移植 FATFS 系统3.3.1 添加源码在工程目录创建文件夹并放入FATFS系统源码 Middlewares\\FATFS_R0.15 ffunicode.c ffsystem.c ffconf.h ff.h ff.c diskio.h diskio.c 00readme.txt 00history.txt 并在 Keil 中添加文件和头文件路径。 3.3.2 修改配置 ffconf.h一些声明的含义可以参考一下网址：http://elm-chan.org/fsw/ff/doc/config.html。 以下内容是把原有的英文注释换成了中文的。并且修改了自己需要的配置。 需要注意的点（需要进行适配）： #define FF_CODE_PAGE\t936 // 支持中文 #define FF_USE_LFN 3 // 支持长文件名，且存在堆区 #define FF_VOLUMES 1 // 一共有一个卷 /* 版本ID */#define FFCONF_DEF\t80286\t/* Revision ID *//*---------------------------------------------------------------------------// Function Configurations/---------------------------------------------------------------------------*//* 设置是否只读。建议为0，否则很多API用不了（0：可读写。1：只读）*/#define FF_FS_READONLY\t0/* 此选项定义了最小化级别，以删除一些基本API函数。 0：基本功能已完全启用。建议为0\t1：f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_truncate() and f_rename() 被移除\t2：在 1 的基础上 f_opendir(), f_readdir() and f_closedir() 被移除\t3：在 2 的基础上 f_lseek() 被移除*/#define FF_FS_MINIMIZE\t0/* 设置是否使用查找功能 f_findfirst() and f_findnext(). 0：不启用\t1：启用\t2：同时启用匹配altname[]*/#define FF_USE_FIND 0/* 是否启用格式化功能 f_mkfs()，对于没有格式化为Fat32的U盘或者SD卡，设置为1，否则无法正常初始化。 0：禁止使用 f_mkfs()\t1：允许使用 f_mkfs()*/#define FF_USE_MKFS 1/* 设置是否使用快速查找功能（0：不使用。1：使用）*/#define FF_USE_FASTSEEK\t1/* 设置是否使用拓展功能（0：不使用。1：使用） */#define FF_USE_EXPAND\t1/* 切换属性操作函数 f_chmod（）和 f_utime（）（0：不使用。1：使用）仅在 FF_FS_READONLY 模式下可用*/#define FF_USE_CHMOD\t0/* 切换卷标函数 f_getlabel() and f_setlabel() （0：不使用。1：使用）*/#define FF_USE_LABEL\t1/* 此选项切换 f_forward（）函数。（0:禁用或1:启用） */#define FF_USE_FORWARD\t0/* 设置对字符串的操作 */#define FF_USE_STRFUNC\t1#define FF_PRINT_LLI\t1#define FF_PRINT_FLOAT\t1#define FF_STRF_ENCODE\t3/* FF_USE_STRFUNC switches string functions, f_gets(), f_putc(), f_puts() and f_printf().// 0: Disable. FF_PRINT_LLI, FF_PRINT_FLOAT and FF_STRF_ENCODE have no effect./ 1: Enable without LF-CRLF conversion./ 2: Enable with LF-CRLF conversion.// FF_PRINT_LLI = 1 makes f_printf() support long long argument and FF_PRINT_FLOAT = 1/2/ makes f_printf() support floating point argument. These features want C99 or later./ When FF_LFN_UNICODE = 1 with LFN enabled, string functions convert the character/ encoding in it. FF_STRF_ENCODE selects assumption of character encoding ON THE FILE/ to be read/written via those functions.// 0: ANSI/OEM in current CP/ 1: Unicode in UTF-16LE/ 2: Unicode in UTF-16BE/ 3: Unicode in UTF-8*//*---------------------------------------------------------------------------// Locale and Namespace Configurations/---------------------------------------------------------------------------*//* 设置语言支持（936：中文支持。437：英文支持）*/#define FF_CODE_PAGE\t936/* This option specifies the OEM code page to be used on the target system./ Incorrect code page setting can cause a file open failure./ 437 - U.S./ 720 - Arabic/ 737 - Greek/ 771 - KBL/ 775 - Baltic/ 850 - Latin 1/ 852 - Latin 2/ 855 - Cyrillic/ 857 - Turkish/ 860 - Portuguese/ 861 - Icelandic/ 862 - Hebrew/ 863 - Canadian French/ 864 - Arabic/ 865 - Nordic/ 866 - Russian/ 869 - Greek 2/ 932 - Japanese (DBCS)/ 936 - Simplified Chinese (DBCS)/ 949 - Korean (DBCS)/ 950 - Traditional Chinese (DBCS)/ 0 - Include all code pages above and configured by f_setcp()*//* 设置是否支持长文件名（如果设置了支持中文，建议一定要使用，中文一个字符两个字节） 0：不启用（最长12个字符，FF_MAX_LFN参数不生效）\t1：启用(工作空间在BSS段，线程不安全。可以使用)\t2：启用（使用动态缓存在栈区。不推荐）\t3：启用（使用动态缓存在堆区。推荐使用）*/#define FF_USE_LFN 3#define FF_MAX_LFN 255/* 当FF_USE_LFN启用时，此处设置字符编码。（IO函数也会被影响）\t0: ANSI/OEM in current CP (TCHAR = char)\t1: Unicode in UTF-16 (TCHAR = WCHAR)\t2: Unicode in UTF-8 (TCHAR = char)\t3: Unicode in UTF-32 (TCHAR = DWORD)*/#define FF_LFN_UNICODE\t0/* 这组选项定义FILINFO结构中用于读取目录项的文件名成员的大小。\t这些值应该足以读取文件名。读取文件名的最大可能长度取决于字符编码。\t当LFN未启用时，这些选项无效。*/#define FF_LFN_BUF 255#define FF_SFN_BUF 12/* 设置是否支持相对路径\t0: 不支持相对路径，并删除相关函数\t1: 支持相对路径，f_chdir（）和f_chdrive（）可用。\t2: 在1的基础上，f_getcwd() 可用。*/#define FF_FS_RPATH 0/*---------------------------------------------------------------------------// Drive/Volume Configurations/---------------------------------------------------------------------------*//*\t一共有几个卷。（1-10）\t有几个存储设备就设置为几，比如只有SD卡就是1；如果有SD卡和W25Q128就是2。*/#define FF_VOLUMES 1/*\tFF_STR_VOLUME_ID：卷标从几开始。\t当 FF_STR_VOLUME_ID 设置为1或2时，路径名称中的驱动器号可以使用任意字符串。 FF_VOLUME_STRS 定义每个逻辑驱动器的卷ID字符串。项目数量不得小于FF_VOLUMES。\t卷ID字符串的有效字符为A-Z、A-Z和0-9，但是，会对它们进行不区分大小写的比较。\t如果 FF_STR_VOLUME_ID=1 且未定义 FF_VOLUME_STRS，则需要用户定义的卷字符串表，如下所示：\tconst char* VolumeStr[FF_VOLUMES] = ram,flash,sd,usb,...*/#define FF_STR_VOLUME_ID\t0#define FF_VOLUME_STRS RAM,NAND,CF,SD,SD2,USB,USB2,USB3/* 多分区支持。（将一个物理设备分为多个磁盘）\t0：不支持。默认每个设备就是一个磁盘分区。\t1：支持。每个逻辑驱动器号都可以绑定到VolToPart[]中列出的任意物理驱动器和分区。 并且支持 f_fdisk() 函数*/#define FF_MULTI_PARTITION\t0/*\t设置设备扇区的大小范围。（对于SD卡，固定就是512） 如果 FF_MAX_SS FF_MIN_SS。\tFatFs被配置为可变扇区大小模式。\tdisk_ioctl() 函数需要实现 GET_SECTOR_SIZE 命令*/#define FF_MIN_SS 512#define FF_MAX_SS 512/*\t此选项切换对64位LBA的支持。\t0:禁用\t1:启用\t要启用64位LBA，还需要启用exFAT（FF_FS_EXFAT==1）*/#define FF_LBA64 0/*\t在f_mkfs和f_fdisk函数中将GPT切换为分区格式的最小扇区数。\t0x100000000最大值。当FF_LBA64==0时，此选项无效。*/#define FF_MIN_GPT 0x10000000/*\t此选项切换对ATA-TRIM的支持。\t0：禁用\t1：启用\t要启用Trim函数，还应将CTRL_TRIM命令实现到disk_ioctl（）函数。*/#define FF_USE_TRIM 0/*---------------------------------------------------------------------------// System Configurations/---------------------------------------------------------------------------*//*\t此选项切换小缓冲区配置。\t0:正常\t1:微小。\t在微小配置下，文件对象（FIL）的大小收缩为FF_MAX_SS字节。 文件系统对象（FATFS）中的公共扇区缓冲区用于文件数据传输，而不是从文件对象中删除私有扇区缓冲区*/#define FF_FS_TINY 0/*\t此选项切换对exFAT文件系统的支持。\t0：禁用\t1：启用\t要启用exFAT，还需要启用LFN。（FF_USE_LFN=1）*/#define FF_FS_EXFAT 0/*\tFF_FS_NORTC：系统是否有RTC时钟，以支持时间戳功能。（FF_FS_READONLY = 1时，该选项不受影响）\t0：有RTC，支持时间戳。需要添加 get_fattime() 函数。 FF_NORTC_YEAR、FF_NORTC_MDAY、FF_NORTC_MON 不受影响\t1：没有RTC，不支持时间戳。 使用默认的FF_NORTC_YEAR、FF_NORTC_MDAY、FF_NORTC_MON\t*/#define FF_FS_NORTC 0#define FF_NORTC_MON\t1#define FF_NORTC_MDAY\t1#define FF_NORTC_YEAR\t2022/*\t如果您需要知道FAT32卷上的正确可用空间，请设置此选项的位0，\t并且在卷装载后的第一时间执行f_getfree（）函数将强制进行完整的FAT扫描。\t位1控制最后分配的簇号的使用。 bit0=0: Use free cluster count in the FSINFO if available.\tbit0=1: Do not trust free cluster count in the FSINFO.\tbit1=0: Use last allocated cluster number in the FSINFO if available.\tbit1=1: Do not trust last allocated cluster number in the FSINFO.*/#define FF_FS_NOFSINFO\t0/*\t选项 FF_FS_LOCK 切换文件锁定功能以控制重复文件打开和非法操作以打开对象。\t当 FF_FS_READONLY 为1时，此选项必须为0。 0:禁用文件锁定功能。为了避免卷损坏，应用程序应避免非法打开、删除和重命名打开的对象。\t!0:启用文件锁定功能。该值定义在文件锁定控制下可以同时打开的文件/子目录的数量。 请注意，文件锁定控制与重新进入无关。*/#define FF_FS_LOCK 0/*\t选项FF_FS_REENTRANT切换FatFs模块本身的再入（线程安全）。\t请注意，无论此选项如何，对不同卷的文件访问始终是可重入的，\t卷控制函数f_mount（）、f_mkfs（）和f_fdisk（）始终不是可重入函数。\t只有对同一卷的文件/目录访问受此功能控制。 0:禁用重入。FF_FS_TIMEOUT无效。\t1：启用重新进入。 此外，必须将用户提供的同步处理程序ff_mutex_create（）、ff_mutexdelete（） ff_mutex_take（）和ff_mutex_give（）函数添加到项目中。 样品可在ffsystem.c中获得。 FF_FS_TIMEOUT 以 O/S 时间刻度为单位定义超时时间。*/#define FF_FS_REENTRANT\t0#define FF_FS_TIMEOUT\t1000 这里设置了支持长文件名，并且相关内容要申请堆中的内存，因此这里需要增大堆内存的空间。 也可以直接从启动文件处修改 3.3.3 底层适配 diskio.c需要适配的函数如下 第一步：设备编号定义 这里只有一个设备（SD卡），把DEV_MMC编号改为0。（要求从0开始按顺序增加） 其他的可以按顺序编号，当然也可以直接删掉。但是为了以后增加，建议保留。 /* Definitions of physical drive number for each drive */#define DEV_RAM 1\t/* Example: Map Ramdisk to physical drive 0 */#define DEV_MMC 0\t/* Example: Map MMC/SD card to physical drive 1 */#define DEV_USB 2\t/* Example: Map USB MSD to physical drive 2 */ 这里名字其实是可以改的，比如改为（正点原子就是这样的）： #define SD_CARD 0 // SD卡,卷标为0#define EX_FLASH 1 // 外部spi flash,卷标为1 如果改了，下面的适配函数也都一样改就可以了。 第二步：添加头文件 因为需要用到我们前面写好的驱动以及printf调试输出，把头文件添加进来。 #include spi_sdcard.h#include stdio.h 第三步：函数适配 这里直接默认返回OK，没什么问题，其他类型的设备注释掉即可。需要用的话再修改。 DSTATUS disk_status (\tBYTE pdrv /* Physical drive nmuber to identify the drive */)\tDSTATUS stat;\tswitch (pdrv) case DEV_RAM :\t// 还没用到，先注释掉 // result = RAM_disk_status(); // translate the reslut code here return stat;\tcase DEV_MMC : return 0;\t// 默认没什么问题\tcase DEV_USB :\t// 还没用到，先注释掉 // result = USB_disk_status(); // translate the reslut code here return stat; return STA_NOINIT; 初始化调用我们前面写好的驱动 DSTATUS disk_initialize (\tBYTE pdrv /* Physical drive nmuber to identify the drive */)\tDSTATUS stat;\tswitch (pdrv) case DEV_RAM :\t// 还没用到，先注释掉 // result = RAM_disk_initialize(); // translate the reslut code here return stat;\tcase DEV_MMC : if(SD_Init() == 0) // SD_Init()是SD初始化函数，无错误返回0 return 0; else return STA_NOINIT;\tcase DEV_USB :\t// 还没用到，先注释掉 // result = USB_disk_initialize(); // translate the reslut code here return stat; return STA_NOINIT; 读扇区函数，一样的调用前面的驱动 DRESULT disk_read (\tBYTE pdrv, /* Physical drive nmuber to identify the drive */\tBYTE *buff, /* Data buffer to store read data */\tLBA_t sector,\t/* Start sector in LBA */\tUINT count /* Number of sectors to read */)\tDRESULT res;\tswitch (pdrv) case DEV_RAM : // translate the arguments here // result = RAM_disk_read(buff, sector, count); // translate the reslut code here return res;\tcase DEV_MMC : res = (DRESULT) SD_ReadDisk(buff, sector, count); while(res)\t// 读出错 printf(sd read error:%d\\r , res); SD_Init();\t// 重新初始化SD卡 res = (DRESULT) SD_ReadDisk(buff,sector,count); return res;\tcase DEV_USB : // translate the arguments here // result = USB_disk_read(buff, sector, count); // translate the reslut code here return res; return RES_PARERR; 写扇区函数，还是调用写好的驱动 DRESULT disk_write (\tBYTE pdrv, /* Physical drive nmuber to identify the drive */\tconst BYTE *buff,\t/* Data to be written */\tLBA_t sector, /* Start sector in LBA */\tUINT count /* Number of sectors to write */)\tDRESULT res;\tswitch (pdrv) case DEV_RAM : // translate the arguments here // result = RAM_disk_write(buff, sector, count); // translate the reslut code here return res;\tcase DEV_MMC : res = (DRESULT) SD_WriteDisk((uint8_t *)buff, sector, count); while(res)\t// 写出错 printf(sd write error:%d\\r , res); SD_Init();\t// 重新初始化SD卡 res = (DRESULT) SD_WriteDisk((uint8_t *)buff, sector, count); return res;\tcase DEV_USB : // translate the arguments here // result = USB_disk_write(buff, sector, count); // translate the reslut code here return res; return RES_PARERR; 命令函数 DRESULT disk_ioctl (\tBYTE pdrv, /* Physical drive nmuber (0..) */\tBYTE cmd, /* Control code */\tvoid *buff /* Buffer to send/receive control data */)\tDRESULT res;\tswitch (pdrv) case DEV_RAM : // Process of the command for the RAM drive return res;\tcase DEV_MMC : switch(cmd) #if FF_FS_READONLY == 0 case CTRL_SYNC: res = RES_OK; break;#endif#if FF_USE_MKFS == 1 case GET_SECTOR_COUNT: *(DWORD*)buff = SD_GetSectorCount(); res = RES_OK; break; case GET_BLOCK_SIZE: *(WORD*)buff = 8; res = RES_OK; break;#endif#if FF_MAX_SS != FF_MIN_SS case GET_SECTOR_SIZE: *(DWORD*)buff = 512; res = RES_OK; break; #endif default: res = RES_PARERR; break; return res;\tcase DEV_USB : // Process of the command the USB drive return res; return RES_PARERR; 在此文件的最后添加一个获取时间的函数，默认返回0 DWORD get_fattime(void) return 0; 3.3.4 验证 main.c把以下代码放在main函数中执行，如果成功执行，说明没问题。 这里执行 f_res f_mount(fs, “0:”, 1)，标号0就是diskio.c开头定义的标号。 FATFS fs; /* FatFs 文件系统对象 */FRESULT f_res; /* 文件操作结果 */BYTE work[FF_MAX_SS];FIL file; /* 文件对象 */UINT fnum; /* 文件成功读写数量 */BYTE ReadBuffer[1024] = 0; /* 读缓冲区 */BYTE WriteBuffer[] = This is STM32 working with FatFs \\r ;\t/* 写缓冲区 */// 在外部 SD 卡挂载文件系统，文件系统挂载时会对 SD 卡初始化// note:必须先要保证SD卡正常拥有FAT文件系统，如果没有会失败。 f_res = f_mount(fs, 0:, 1);/* 如果没有文件系统就格式化创建创建文件系统 */ if(f_res == FR_NO_FILESYSTEM) printf(The SD card does not yet have a file system and is about to be formatted... \\r ); /* 格式化 */\tf_res = f_mkfs(0:, NULL, work, sizeof(work));\t/* Create a FAT volume */ if(f_res == FR_OK) printf(The SD card successfully formatted the file system\\r ); /* 格式化后，先取消挂载 */ f_res = f_mount(NULL, 0:, 1); /* 重新挂载 */ f_res = f_mount(fs, 0:, 1); else printf(The format failed\\r ); while(1); else if(f_res != FR_OK) printf(mount error : %d \\r , f_res); while(1); else printf(mount sucess!!! \\r ); /*----------------------- 文件系统测试：写测试 -----------------------------*/ /* 打开文件，如果文件不存在则创建它 */ printf(\\r ****** Create and Open new text file objects with write access ****** \\r ); f_res = f_open(file, 0:FatFs STM32cube.txt, FA_CREATE_ALWAYS | FA_WRITE); if(f_res == FR_OK) printf(open file sucess!!! \\r ); /* 将指定存储区内容写入到文件内 */ printf(\\r ****** Write data to the text files ******\\r ); f_res = f_write(file, WriteBuffer, sizeof(WriteBuffer), fnum); if(f_res == FR_OK) printf(write file sucess!!! (%d)\\r , fnum); printf(write Data : %s\\r , WriteBuffer); else printf(write file error : %d\\r , f_res); /* 不再读写，关闭文件 */ f_close(file); else printf(open file error : %d\\r , f_res); /*------------------- 文件系统测试：读测试 ------------------------------------*/ printf(\\r ****** Read data from the text files ******\\r ); f_res = f_open(file, 0:FatFs STM32cube.txt, FA_OPEN_EXISTING | FA_READ); if(f_res == FR_OK) printf(open file sucess!!! \\r ); f_res = f_read(file, ReadBuffer, sizeof(ReadBuffer), fnum); if(f_res == FR_OK) printf(read sucess!!! (%d)\\r , fnum); printf(read Data : %s\\r , ReadBuffer); else printf( read error!!! %d\\r , f_res); else printf(open file error : %d\\r , f_res); /* 不再读写，关闭文件 */ f_close(file); /* 不再使用文件系统，取消挂载文件系统 */ f_mount(NULL, 0:, 1); /* 操作完成，停机 */ 其他 API 的使用参考 FATFS 官网：http://elm-chan.org/fsw/ff/00index_e.html 4. W25Q128 (Q)SPI模式移植这里不同开发板与外部FALSH（W25Q128）的通信方式有一丢丢的区别。 两种流程是一样的，只有驱动部分有一丢丢区别。两个开发板都整一份。 4.1 W25QXX系列芯片W25QXX系列芯片，共有八个引脚，可以使用不同的通信方式。 引脚编号 QSPI通信 备注 SPI通信 备注 1 CS# 片选引脚。低电平表示选中。 CS# 片选引脚。低电平表示选中。 2 IO1 数据线1，QSPI_BK1_IO1 SO SPI数据输出接口 3 IO2 数据线2，QSPI_BK1_IO2 WP# 硬件写保护引脚，输入高电平可以正常写入数据，输入低电平禁止写入。 4 GND 公共地 GND 公共地 5 IO0 数据线0，QSPI_BK1_IO0 SI SPI数据输入接口 6 CLK 时钟线，QSPI_BK1_CLK CLK SPI时钟接口 7 IO3 数据线3，QSPI_BK1_IO3 HOLD 状态保存接口，输入低电平禁止操作芯片，输入高电平可正常操作芯片。 8 VCC 电源接口，2.7-3.6电源 VCC 电源接口，2.7-3.6电源 以W25Q64为例，其容量规划如下： 单位 大小 比例 数量 页 256字节 最小单位 扇区 4K字节（4096字节） 1扇区16个页 2048个 块 64K字节 1块16个扇区 128个 其总容量为 64 * 1024 * 128 8388608字节 8192K字节 8M 字节。 对于W25Q128，其共拥有256个块，总容量就为 16M 字节。 芯片每次最小擦写单位为一个扇区，即4K字节。 4.2 创建工程使用CubeMX创建一个工程。需要配置的项目有： 时钟 程序调试接口 串口（用于观察调试信息） (Q)SPI。这里需要根据不同的通讯方式创建工程。 如果使用QSPI创建工程（潘多拉loT Board开发板），则配置如下： 得到的初始化代码如下： 其中代码生成后需要手动修改的为：hqspi.Init.FlashSize，根据使用的Flash的大小修改。 void MX_QUADSPI_Init(void) hqspi.Instance = QUADSPI; hqspi.Init.ClockPrescaler = 0;\t// QPSI分频比，W25Q128最大频率为104M，这里为80MHz hqspi.Init.FifoThreshold = 4; // FIFO阈值为4个字节 hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;\t// 采样移位半个周期(DDR模式下,必须设置为0) hqspi.Init.FlashSize = POSITION_VAL(0x1000000)-1; // SPI FLASH大小，W25Q128大小为16M字节 hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_4_CYCLE;\t// 片选高电平时间为4个时钟(12.5*4=50ns),即手册里面的tSHSL参数 hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;\t// 模式0 if (HAL_QSPI_Init(hqspi) != HAL_OK) Error_Handler(); 5. 多磁盘移植这里我们直接在第三章的基础上改。 第一步：创建工程根据两种存储介质配置相应的接口。 第二步：添加每种存储介质的驱动、FATFS的源码 第三步：修改配置文件 ffconf.h 相较于上面的配置，需要修改的有 #define FF_VOLUMES 1\t// 有几个存储介质，这里就改为几（1-10） 第四步：修改底层接口 diskio.c 设备定义。有几个就写几个，名字可以自己拟，但是标号要从0开始，这个标号就是挂载时的编号。 如果自拟了名字，那后面的函数中switch (pdrv) 的选项名字要对应的改一下 /* Definitions of physical drive number for each drive */#define DEV_RAM 1\t/* Example: Map Ramdisk to physical drive 0 */#define DEV_MMC 0\t/* Example: Map MMC/SD card to physical drive 1 */#define DEV_USB 2\t/* Example: Map USB MSD to physical drive 2 */ 其他需要配置的接口如下，直接照抄上面，在需要的 case 中添加对应存储介质的实现即可。 DSTATUS disk_status (BYTE pdrv);DSTATUS disk_initialize (BYTE pdrv);DRESULT disk_read (BYTE pdrv, BYTE *buff, LBA_t sector,\tUINT count);DRESULT disk_write (BYTE pdrv, BYTE *buff, LBA_t sector, UINT count);DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void *buff);DWORD get_fattime(void); 第五步：挂载 有几个存储设备，就挂载几个。其余操作和原来的一样。 FATFS fs0, fs1;f_res = f_mount(fs0, 0:, 1);if()\t// 判断是否成功 f_res = f_mount(fs1, 1:, 1);if()\t// 判断是否成功","tags":["Fatfs","SDCard"],"categories":["开源库"]},{"title":"lvgl移植","path":"/2024/10/08/05. 开源库/lvgl移植/","content":"1. LVGL 裸机移植 所用硬件：正点原子潘多拉开发板，SPI 通信、ST7789、1.3英寸、屏幕分辨率为 240*240、不带触摸功能。 软件准备：CubeMX、Keil5。 LVGL 版本：8.2 LVGL 可以在不同的显示屏上移植，移植区别不大，这里无需准备任何例程从头理解移植过程。 如果用的是其他的显示屏，只要有能在裸机下显示的例程，即有显示的驱动即可。 1.1 源码准备首先下载 lvgl 的源码，注意这里选择 8.2版本。 官网在 Github，访问太慢了，就在 Gitee 上随便搜了一下，都一样。 Gitee 地址：https://gitee.com/my_lvgl/lvgl/tree/release%2Fv8.2/ 下载完成之后文件比较多 这里对其进行简化，解压之后，删掉无用的文件，留下以下文件。 然后进一步简化，把 examples 文件夹中无用的代码删掉。仅留下其中的 porting 文件夹。 最后简化后的代码是这样的： demos 文件夹（没动过里面内容） examples 文件夹 porting 文件夹（没动过里面内容） src 文件夹（没动过里面内容） lv_conf.h 文件（lv_conf_template.h 改名来的） lvgl.h 文件 1.2 新建工程使用 cubemx 新建一个空白的工程，需要的配置内容如下： 调试接口、时钟。 配置 spi 接口，用于驱动屏幕（如果是其他接口的屏，按照自己的配置即可）。 配置按键，用于作为输入。 一个定时器，用于给 lvgl 提供时基。 spi 配置如下（根据自己的开发板修改引脚）： 屏幕控制引脚配置如下（根据自己的开发板修改引脚）： 按键配置如下，根据自己的原理图配置上拉还是下拉。 定时器配置如下，记得勾选上中断。（用其他的定时器也行，有中断即可） 中断勾选 配置完成后生成工程即可。 此时工程直接编译不应该有错误，如果有排查之后再进行下一步。 生成工程后，如果自己有裸机显示的程序，可以添加进去试试，即证明软件配置和硬件设备都是好用的。 1.3 添加源码在生成的工程目录下添加如下文件夹 工程目录 Device 文件夹（我添加的） LCD_SPI_ST7789 文件夹（我添加的） lcd_lvgl.c 文件（内容需要自己写，后面提供） lcd_lvgl.h 文件（内容需要自己写，后面提供） Middleware 文件夹（我添加的） LVGL 文件夹（我添加的） GUI 文件夹（我添加的） lvgl 文件夹（我添加的） GUI_APP 文件夹（我添加的） 如下图 然后把我们刚刚裁剪过的 LVGL 源码放进来。其中 工程名\\Middlewares\\LVGL\\GUI\\lvgl目录下放 examples 文件夹 src 文件夹 lv_conf.h 文件 lvgl.h 文件 工程名\\Middlewares\\LVGL\\GUI_APP目录下放 demos 文件夹 给 LCD_SPI_ST7789 提供的驱动文件如下： lcd_lvgl.c 文件（这是从正点原子这个屏幕的驱动文件里摘抄修改出来的，把 lvgl 用不到的部分删掉了） u#include lcd_lvgl.h//lcd控制io初始化static void LCD_GPIO_Init(void) /* 初始化引脚 */ //MX_GPIO_Init();\t// cube生成的已经初始化过了 /* 复位LCD */ LCD_PWR(0); LCD_RST(0);\tLCD_CS(1); HAL_Delay(100); LCD_RST(1); /* 初始化SPI3接口 */ //MX_SPI3_Init(); // cube生成的已经初始化过了//lcd开void LCD_DisplayOn(void) LCD_PWR(1);//lcd关void LCD_DisplayOff(void) LCD_PWR(0);//spi写字节static void LCD_SPI_WriteByte(uint8_t *TxData, uint16_t size)\tLCD_CS(0);\t// 片选选中 HAL_SPI_Transmit(LCD_SPI_Handler, TxData, size, 1000);\tLCD_CS(1);\t// 取消片选//spi写多长数据static void LCD_SPI_Send(uint8_t *data, uint32_t size) uint32_t i; uint32_t delta; delta = size/0xFFFF; for(i = 0; i = delta; i++) if(i == delta) /* 发送最后一帧数据 */ LCD_SPI_WriteByte(data[i*0xFFFF], size%0xFFFF); else /* 超长数据一次发送0xFFFF字节数据 */ LCD_SPI_WriteByte(data[i*0xFFFF], 0xFFFF); //lcd写命令static void LCD_Write_Cmd(uint8_t cmd) LCD_WR(0); LCD_SPI_Send(cmd, 1);//lcd写数据static void LCD_Write_Data(uint8_t dat) LCD_WR(1); LCD_SPI_Send(dat, 1);//lcd设置显示地址static void LCD_Address_Set(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2) /* 指定X方向操作区域 */ LCD_Write_Cmd(0x2a); LCD_Write_Data(x1 8); LCD_Write_Data(x1); LCD_Write_Data(x2 8); LCD_Write_Data(x2); /* 指定Y方向操作区域 */ LCD_Write_Cmd(0x2b); LCD_Write_Data(y1 8); LCD_Write_Data(y1); LCD_Write_Data(y2 8); LCD_Write_Data(y2); /* 发送该命令，LCD开始等待接收显存数据 */ LCD_Write_Cmd(0x2C);//lcd初始化void LCD_Init(void) /* 初始化和LCD通信的引脚 */ LCD_GPIO_Init(); HAL_Delay(120); /* 关闭睡眠模式 */ LCD_Write_Cmd(0x11); HAL_Delay(120); /* 开始设置显存扫描模式，数据格式等 */ LCD_Write_Cmd(0x36); LCD_Write_Data(0x00); /* RGB 5-6-5-bit格式 */ LCD_Write_Cmd(0x3A); LCD_Write_Data(0x65); /* porch 设置 */ LCD_Write_Cmd(0xB2); LCD_Write_Data(0x0C); LCD_Write_Data(0x0C); LCD_Write_Data(0x00); LCD_Write_Data(0x33); LCD_Write_Data(0x33); /* VGH设置 */ LCD_Write_Cmd(0xB7); LCD_Write_Data(0x72); /* VCOM 设置 */ LCD_Write_Cmd(0xBB); LCD_Write_Data(0x3D); /* LCM 设置 */ LCD_Write_Cmd(0xC0); LCD_Write_Data(0x2C); /* VDV and VRH 设置 */ LCD_Write_Cmd(0xC2); LCD_Write_Data(0x01); /* VRH 设置 */ LCD_Write_Cmd(0xC3); LCD_Write_Data(0x19); /* VDV 设置 */ LCD_Write_Cmd(0xC4); LCD_Write_Data(0x20); /* 普通模式下显存速率设置 60Mhz */ LCD_Write_Cmd(0xC6); LCD_Write_Data(0x0F); /* 电源控制 */ LCD_Write_Cmd(0xD0); LCD_Write_Data(0xA4); LCD_Write_Data(0xA1); /* 电压设置 */ LCD_Write_Cmd(0xE0); LCD_Write_Data(0xD0); LCD_Write_Data(0x04); LCD_Write_Data(0x0D); LCD_Write_Data(0x11); LCD_Write_Data(0x13); LCD_Write_Data(0x2B); LCD_Write_Data(0x3F); LCD_Write_Data(0x54); LCD_Write_Data(0x4C); LCD_Write_Data(0x18); LCD_Write_Data(0x0D); LCD_Write_Data(0x0B); LCD_Write_Data(0x1F); LCD_Write_Data(0x23); /* 电压设置 */ LCD_Write_Cmd(0xE1); LCD_Write_Data(0xD0); LCD_Write_Data(0x04); LCD_Write_Data(0x0C); LCD_Write_Data(0x11); LCD_Write_Data(0x13); LCD_Write_Data(0x2C); LCD_Write_Data(0x3F); LCD_Write_Data(0x44); LCD_Write_Data(0x51); LCD_Write_Data(0x2F); LCD_Write_Data(0x1F); LCD_Write_Data(0x1F); LCD_Write_Data(0x20); LCD_Write_Data(0x23); /* 显示开 */ LCD_Write_Cmd(0x21); LCD_Write_Cmd(0x29); /*打开显示*/ LCD_PWR(1);//填充函数，提供给lvglvoid lcd_fill_array(uint16_t x_start, uint16_t y_start, uint16_t x_end, uint16_t y_end, void *pcolor) uint32_t size = 0; size = (x_end - x_start + 1) * (y_end - y_start + 1) * 2; LCD_Address_Set(x_start, y_start, x_end, y_end); LCD_WR(1);\tLCD_SPI_Send(pcolor, size); lcd_lvgl.h 文件 #ifndef __LCD_LVGL_H#define __LCD_LVGL_H#include stdint.h#include spi.h#include gpio.h// SPI驱动LCD屏幕（ST7789）// LCD屏幕分辨率定义#define LCD_Width 240#define LCD_Height 240#define LCD_SPI_Handler hspi3// 引脚定义#define LCD_PWR_PIN GPIO_PIN_7#define LCD_PWR_GPIO_PORT\tGPIOB#define LCD_RST_PIN GPIO_PIN_6#define LCD_RST_GPIO_PORT\tGPIOB#define LCD_WR_PIN GPIO_PIN_4#define LCD_WR_GPIO_PORT\tGPIOB#define LCD_CS_PIN GPIO_PIN_7#define LCD_CS_GPIO_PORT\tGPIOD// LCD_SPI_SDA 对应 PB5// LCD_SPI_SCK 对应 PB3// 控制引脚定义#define LCD_PWR(n)\t(n?\\ HAL_GPIO_WritePin(LCD_PWR_GPIO_PORT, LCD_PWR_PIN, GPIO_PIN_SET):\\ HAL_GPIO_WritePin(LCD_PWR_GPIO_PORT, LCD_PWR_PIN, GPIO_PIN_RESET))#define LCD_WR(n)\t(n?\\ HAL_GPIO_WritePin(LCD_WR_GPIO_PORT, LCD_WR_PIN, GPIO_PIN_SET):\\ HAL_GPIO_WritePin(LCD_WR_GPIO_PORT, LCD_WR_PIN, GPIO_PIN_RESET))#define LCD_RST(n) (n?\\ HAL_GPIO_WritePin(LCD_RST_GPIO_PORT, LCD_RST_PIN, GPIO_PIN_SET):\\ HAL_GPIO_WritePin(LCD_RST_GPIO_PORT, LCD_RST_PIN, GPIO_PIN_RESET))#define LCD_CS(n)\t(n?\\ HAL_GPIO_WritePin(LCD_CS_GPIO_PORT, LCD_CS_PIN, GPIO_PIN_SET):\\ HAL_GPIO_WritePin(LCD_CS_GPIO_PORT, LCD_CS_PIN, GPIO_PIN_RESET))void LCD_Init(void);void LCD_DisplayOn(void);void LCD_DisplayOff(void);void lcd_fill_array(uint16_t x_start, uint16_t y_start, uint16_t x_end, uint16_t y_end, void *pcolor);#endif /* __LCD_LVGL_H */ 1.4 软件配置在 KEIL 中把代码添加进去。 在 keil 中添加如下几个文件夹。 其中， Device：添加 LCD 设备驱动代码，即 lcd_lvgl.c 文件。 Middlewareslvglexampleporting：添加 exampleporting 文件夹下的lv_port_disp_template.c和lv_port_indev_template.c文件（这两个分别是显示接口、触摸等控制接口，还有一个文件系统的接口暂时没用先不添加）。 Middlewareslvglsrccore：添加 srccore 文件夹下的全部 c 文件。 Middlewareslvglsrcdraw：添加 srcdraw 文件夹下除了nxp_pxp、nxp_vglite、sdl和stm32_dma2d文件夹之外的全部 c 文件。 Middlewareslvglsrcextra：添加 srcextra 文件夹下的全部 c 文件。 Middlewareslvglsrcfont：添加 srcfont 文件夹下的全部 c 文件。 Middlewareslvglsrcgpu：添加 src/draw/sdl和src/draw/stm32_dma2d文件夹下的全部 c 文件。 Middlewareslvglsrchal：添加 srchal 文件夹下的全部 c 文件。 Middlewareslvglsrcmisc：添加 srcmisc 文件夹下的全部 c 文件。 Middlewareslvglsrcwidgets：添加 srcwidgets 文件夹下的全部 c 文件。 然后添加头文件路径。 所有的都添加完成之后，直接编译，会有几十个警告，但是不会有错误出现。如果有错误，先排查前面哪一步有问题然后再继续下一步。 1.5 软件适配1.5.1 添加时基在中断函数的文件中可以看到定时器的中断处理函数，在这里添加中断回调函数，处理 lvgl 的时基即可。 记得要在main中开启定时器中断，HAL_TIM_Base_Start_IT(htim7); #include lvgl.h\t//添加在最上方void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) if(htim-Instance == TIM7) lv_tick_inc(1); 1.5.2 显示部分 打开显示适配文件的宏定义，把 0 改为 1。 添加 lcd 显示驱动的头文件，因为下面需要调用里面的函数。 添加屏幕尺寸大小的宏定义。 下图中展示了上面三个步骤。 #include lcd_lvgl.h// 下面用到的 在 lcd.h中有#define MY_DISP_HOR_RES LCD_Width\t//水平分辨率#define MY_DISP_VER_RES LCD_Height //纵向分辨率 lv_port_disp_init函数修改，选择一种缓冲区方式，注释掉另外两种；修改自己的屏幕尺寸。这里使用这种，省内存。 如果想使用第二种，记得把下面缓冲区的名字换一下。 第三种同理，但是多了下面还要打开一个full_flash的定义，并添加一个LV_VER_RES_MAX的宏定义，就是数当然也是越大越好，能直接为LV_DISP_HOR_RES应该是最好了。 显示初始化函数：添加 LCD 初始化函数。显示刷新函数：添加自己的显示接口。 刷新函数中注释掉的部分：LCD_Draw_ColorPoint函数，内容如下。但是我的驱动文件里没有添加。因为速度特别特别慢。 如果想用的话，把下面两个函数放到lcd_lvgl.c中，并在头文件中声明下面的画点函数即可。 static void LCD_Write_HalfWord(const uint16_t da) uint8_t data[2] = 0; data[0] = da 8; data[1] = da; LCD_WR(1); LCD_SPI_Send(data, 2);void LCD_Draw_ColorPoint(uint16_t x, uint16_t y, uint16_t color) LCD_Address_Set(x, y, x, y); LCD_Write_HalfWord(color); 1.5.3 输入部分 跳过这部分不影响输出测试，只是没有交互。 输入支持多种，触摸、鼠标、键盘、编码器、按键。 因为我这里开发板上只有按键，因此这里可以使用键盘、按键，这两种方式稍微有点区别。这里以键盘为例。 打开输入适配文件的宏定义，把 0 改为 1。 添加获取输入的头文件，因为下面需要调用里面的函数。 打开键盘输入需要的函数定义声明。 适配后面的输入函数。留下以下的内容，其他部分注释掉即可。如果使用其他输入，道理是一样的，打开相应部分的注释即可。 void lv_port_indev_init(void) static lv_indev_drv_t indev_drv; /*------------------ * Keypad * -----------------*/ /*Initialize your keypad or keyboard if you have*/ keypad_init(); /*Register a keypad input device*/ lv_indev_drv_init(indev_drv); indev_drv.type = LV_INDEV_TYPE_KEYPAD; indev_drv.read_cb = keypad_read; indev_keypad = lv_indev_drv_register(indev_drv);/*------------------ * Keypad * -----------------*//*Initialize your keypad*/static void keypad_init(void) /*Your code comes here*//*Will be called by the library to read the mouse*/static void keypad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) static uint32_t last_key = 0; /*Get the current x and y coordinates*/// mouse_get_xy(data-point.x, data-point.y); /*Get whether the a key is pressed and save the pressed key*/ uint32_t act_key = keypad_get_key(); if(act_key != 0) data-state = LV_INDEV_STATE_PR; /*Translate the keys to LVGL control characters according to your key definitions*/ switch(act_key) case 2: //下 act_key = LV_KEY_ENTER; break; case 3: //左 act_key = LV_KEY_PREV; break; case 4: //右 act_key = LV_KEY_NEXT; break; last_key = act_key; else data-state = LV_INDEV_STATE_REL; data-key = last_key;/*Get the currently being pressed key. 0 if no key is pressed*/static uint32_t keypad_get_key(void) /*Your code comes here*/\t//按键up\tif(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET) return 1; //按键down\telse if(HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_9) == GPIO_PIN_RESET) return 2;\t//按键left\telse if(HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_8) == GPIO_PIN_RESET) return 3;\t//按键right\telse if(HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_10) == GPIO_PIN_RESET) return 4; else return 0; 注意，这个配置在下面的demo中，大多都不能用，因为还要绑定组。测试这个按钮的话，直接看第3章，实体按钮控制。 1.6 测试代码在 main.c 里添加 #include lvgl.h#include lv_port_disp_template.h//#include lv_port_indev_template.hint main(void) //原有的 HAL_Init(); SystemClock_Config(); MX_GPIO_Init(); MX_SPI3_Init(); MX_USART1_UART_Init(); MX_I2C3_Init(); MX_TIM7_Init(); //自己添加的 HAL_TIM_Base_Start_IT(htim7);\t// 使能定时器中断 lv_init(); lv_port_disp_init(); //\tlv_port_indev_init(); lv_obj_t* switch_obj = lv_switch_create(lv_scr_act()); lv_obj_set_size(switch_obj, 120, 60); lv_obj_align(switch_obj, LV_ALIGN_CENTER, 0, 0); while (1) HAL_Delay(5); lv_timer_handler(); 编译后应该是不能有错误，会有警告可以先不管。运行效果如下： 有此图像产生即表示移植正常。 1.7 案例测试最刚开始的Demo文件夹中有很多已经写好的测试案例。可以试试。 压力测试步骤 将 demos 文件夹复制到 MiddlewaresLVGLGUI_APP 路径下；（前面已完成） 添加头文件路径 ..\\Middlewares\\LVGL\\GUI_APP\\demos ..\\Middlewares\\LVGL\\GUI_APP\\demos\\stress 打开 lv_conf.h 文件，找到宏定义 LV_USE_DEMO_STRESS 将其设置为1。 在 keil 中新建 MiddlewaresLVGLGUI_APP 工程组，添加 demos\\stress 文件夹下的 lv_demo_stress.c 文件 main.c 文件里包含头文件：#include “lv_demo_stress.h” 初始化官方 demo：lv_demo_stress(); 音乐播放器测试步骤（我这里内存不够，会报上千个错误） 将 demos 文件夹复制到 MiddlewaresLVGLGUI_APP 路径下；（前面已完成） 添加头文件路径 ..\\Middlewares\\LVGL\\GUI_APP\\demos ..\\Middlewares\\LVGL\\GUI_APP\\demos\\music 打开 lv_conf.h 文件，找到宏定义 LV_USE_DEMO_MUSIC 将其设置为1。 在 keil 中新建 MiddlewaresLVGLGUI_APP 工程组，添加 demos\\music 文件夹下的全部 c 文件。 main.c 文件里包含头文件：#include “lv_demo_music.h” 初始化官方 demo：lv_demo_music();","tags":["Ui","Lvgl"],"categories":["开源库"]},{"title":"ros2学习笔记","path":"/2024/01/01/04. Linux应用/ros2/","content":"1. 环境准备1.1 Linux 这里使用的ubuntu 20.04.3 镜像名称：ubuntu-20.04.6-desktop-amd64.iso（文件大小：4.05G） 下载地址：http://mirrors.ustc.edu.cn/ubuntu-releases/ 安装方法：参考【正点原子】I.MX6U嵌入式Linux C应用编程指南V1.4。第一章 配置方法：参考【正点原子】I.MX6U嵌入式Linux C应用编程指南V1.4。第四章（按需配置） ubuntu下的ftp服务 # 1 安装服务sudo apt-get install vsftpd# 2 修改配置文件sudo vi /etc/vsftpd.conf# 打开下面两行的注释local_enable=YESwrite_enable=YES# 3 重启服务sudo /etc/init.d/vsftpd restart 这里配置了： ubuntu下的ftp服务 电脑端安装MobaXterm软件 1.2 Ros2 这里使用的是foxy版本。 安装方式1：https://fishros.com/d2lros2/#/ wget http://fishros.com/install -O fishros bash fishros ROS2入门篇 - 动手安装ROS2 - 一键安装ROS2。 安装方式2：手动安装 # 下载密钥sudo apt install curl gnupg2 -ycurl -s https://gitee.com/ohhuo/rosdistro/raw/master/ros.asc | sudo apt-key add -# 导出到系统echo deb [arch=$(dpkg --print-architecture)] https://repo.huaweicloud.com/ros2/ubuntu/ $(lsb_release -cs) main | sudo tee /etc/apt/sources.list.d/ros2.list /dev/null# 更新sudo apt update# 安装sudo apt install ros-foxy-desktop# 安装额外依赖sudo apt install python3-argcomplete -y# 配置环境变量echo source /opt/ros/foxy/setup.bash ~/.bashrc# 添加源source /opt/ros/foxy/setup.bash# 查看结果ros2 卸载方式 sudo apt remove ros-foxy-* sudo apt autoremove 1.3 VScode 下载安装包 地址：https://code.visualstudio.com/ 软件包名称：code_1.85.1-1702462158_amd64.deb 传输安装包到ubuntu 安装（在安装包目录下输入） sudo dpkg -i code_1.85.1-1702462158_amd64.deb 上面的一键安装还可以，也可以自己装。 2. 命令行2.1 案例自带案例 # 格式 #ros2 run package_name executable_name # 启动包下面的节点# 1.启动一只海龟 #ros2 run turtlesim turtlesim_node # 创建一个海龟(shell 1)ros2 run turtlesim turtle_teleop_key\t# 添加一个控制程序(shell 2)# 2. 节点相关 #ros2 node # 查看此命令帮助信息ros2 node list # 查看当前节点列表(shell 3)#结果如下/teleop_turtle/turtlesimros2 node info /teleop_turtle\t# 查看节点信息(最后是节点名)(shell 3)# 3. 话题相关 #ros2 topic # 查看此命令帮助信息ros2 topic list # 查看当前话题列表(shell 3)#结果如下/parameter_events/rosout/turtle1/cmd_vel # turtle1是默认的海龟名字/turtle1/color_sensor/turtle1/pose # 海龟的姿势ros2 topic echo /turtle1/pose\t# ehco:订阅该话题,不断收到位置信息(shell 3)ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist linear:x: 2.0, y: 0.0, z: 0.0, angular:x: 0.0, y: 0.0, z: 1.8publisher: beginning loop # 发布话题控制海龟做圆周运动(shell 3)#停止后，继续下面操作ros2 service call /spawn turtlesim/srv/Spawn x: 2, y: 2, theta: 0.2, name: abc # 创建一只新海龟(shell 3)#停止后，继续下面操作ros2 topic list # 再次查看话题(shell 3)/abc/cmd_vel\t# 多了abc海龟的/abc/color_sensor/abc/pose/parameter_events/rosout/turtle1/cmd_vel/turtle1/color_sensor/turtle1/poseros2 topic pub --rate 1 /abc/cmd_vel geometry_msgs/msg/Twist linear:x: 2.0, y: 0.0, z: 0.0, angular:x: 0.0, y: 0.0, z: 1.8 # 控制abc海龟圆周运动#停止后，继续下面操作# 3. 记录 #ros2 bag # 查看命令帮助信息ros2 bag record /turtle1/cmd_vel\t# 记录turtle1的速度信息# 结束之后会保存到当前shell的目录下ros2 bag play rosbag2_2023_11_02-17_14_36/ # 复现刚刚记录的路径信息（最后是保存的文件夹名称） 2.3 总结# 运行节点(常用)ros2 run package_name executable_name# 查看节点列表(常用)：ros2 node list# 查看节点信息(常用)：ros2 node info node_name 3. 开始编程3.1 简单概念 工作空间：存放项目开发相关文件的文件夹。 功能包：功能源码。ROS软件中的基本单元，包含节点源码、配置文件、数据定义等 节点：工作细胞。执行单元。 话题：节点间传递数据的桥梁。异步通信。发布者订阅者模型。多对多。用于数据传输。 服务：节点间的你问我答。同步通信。客户端服务器模型。一对多。多用逻辑处理。 通信接口：数据传递的标准结构。 参数：机器人系统的全局字典。 动作：完整行为的流程管理 分布式通信：多计算平台的任务分配 DDS：机器人的神经网络 3.2 文件结构 WorkSpace src：代码空间，源代码，功能包 install：安装 build：编译 log：日志 3.3 编译工具（可能）用到的工具，也不知道啥时候用到，反正都装上就行了。 # g++sudo apt install g++# 编译指令g++ hello_world.cpp# makesudo apt install make# 编译指令（在Makefile同级目录）make build# Cmakesudo apt install cmake# 先不用# colcon 功能包构建工具sudo apt-get install python3-colcon-common-extensions# 编译指令colcon build 3.4 创建ROS节点 建立工作空间文件夹 # ros2文件夹存放所有的ros工程（可以不要）haozi@haozi-machine:~/ros2$ pwd/home/haozi/ros2# 创建工作空间haozi@haozi-machine:~/ros2$ mkdir test_ws# test_ws文件夹就是一个工作空间haozi@haozi-machine:~/ros2$ lstest_ws 创建src文件夹 # 进入工作空间haozi@haozi-machine:~/ros2$ cd test_ws# 创建src文件夹haozi@haozi-machine:~/ros2/test_ws$ mkdir srchaozi@haozi-machine:~/ros2/test_ws$ lssrc 创建一个功能包 # 先进入src文件夹haozi@haozi-machine:~/ros2/test_ws$ cd src/# 创建example_cpp功能包，使用ament-cmake作为编译类型，并为其添加rclcpp依赖。haozi@haozi-machine:~/ros2/test_ws/src$ ros2 pkg create example_cpp --build-type ament_cmake --dependencies rclcppgoing to create a new packagepackage name: example_cppdestination directory: /home/haozi/ros2/test_ws/srcpackage format: 3version: 0.0.0description: TODO: Package descriptionmaintainer: [haozi haozi@todo.todo]licenses: [TODO: License declaration]build type: ament_cmakedependencies: [rclcpp]creating folder ./example_cppcreating ./example_cpp/package.xmlcreating source and include foldercreating folder ./example_cpp/srccreating folder ./example_cpp/include/example_cppcreating ./example_cpp/CMakeLists.txt# src文件夹下多出 example_cpp 文件夹haozi@haozi-machine:~/ros2/test_ws/src$ lsexample_cpp pkg create 是创建包的意思 –build-type 用来指定该包的编译类型，一共有三个可选项ament_python、ament_cmake、cmake –dependencies 指的是这个功能包的依赖，这里是ros2的C++客户端接口rclcpp 此时的目录就会变成这个样子 test_ws src example_cpp Cmakelists.txt include example_cpp package.xml src 创建节点 在test_wssrcexample_cppsrc文件夹下创建 node.cpp 文件，方法任意。 haozi@haozi-machine:~/ros2/test_ws/src/example_cpp/src$ pwd/home/haozi/ros2/test_ws/src/example_cpp/srchaozi@haozi-machine:~/ros2/test_ws/src/example_cpp/src$ lsnode.cpp 文件内容如下： #include rclcpp/rclcpp.hppint main(int argc, char **argv) /* 初始化rclcpp */ rclcpp::init(argc, argv); /*产生一个node的节点*/ auto node = std::make_sharedrclcpp::Node(node); // 打印一句自我介绍 RCLCPP_INFO(node-get_logger(), node节点已经启动.); /* 运行节点，并检测退出信号 Ctrl+C*/ rclcpp::spin(node); /* 停止运行 */ rclcpp::shutdown(); return 0; 完成后目录如下： test_ws src example_cpp Cmakelists.txt include example_cpp package.xml src node.cpp 修改CmakeLists 在 CMakeLists.txt 的最后添加如下代码，将其添加为可执行文件，并使用install指令将其安装到install目录。 # 添加可执行目标node, 参数为node.cppadd_executable(node src/node.cpp)ament_target_dependencies(node rclcpp)install(TARGETS node DESTINATION lib/$PROJECT_NAME) 编译节点 # cd回到工作空间目录haozi@haozi-machine:~/ros2/test_ws$ pwd/home/haozi/ros2/test_ws# 执行编译（上面修改的文件一定要点保存之后再编译）haozi@haozi-machine:~/ros2/test_ws$ colcon buildStarting example_cppFinished example_cpp [4.87s] Summary: 1 package finished [8.85s]# 编译完成可以看到多出来几个文件夹haozi@haozi-machine:~/ros2/test_ws$ lsbuild install log src source环境 haozi@haozi-machine:~/ros2/test_ws$ source install/setup.bash 运行节点 haozi@haozi-machine:~/ros2/test_ws$ ros2 run example_cpp node[INFO] [1698995834.649833335] [node]: node节点已经启动. 测试 另开一个窗口，查看现有节点。 haozi@haozi-machine:~/ros2/test_ws$ ros2 node list/node 如果ros2 node list显示不出来，就使用ros2 node list --no-daemon。理由未知。 至此，自己编写代码的流程就结束了。每次修改完成之后，需要重新编译，添加资源。 补充： # 只编译一个包colcon build --packages-select YOUR_PKG_NAME # 允许通过更改src下的部分文件来改变install（重要）（不知道啥意思）# 每次调整 python 脚本时都不必重新build了colcon build --symlink-install 4. 四大通信通信方式：话题、服务、动作、参数 媒介：接口 本章节所有代码都将在一个工作空间下完成 4.1 话题 同一个话题，发布者和订阅者都可以有多个。 一对一、多对一、一对多、多对多，都可以。 4.1.1 自带案例# 运行ros自带的两个案例haozi@haozi-machine:~$ ros2 run demo_nodes_cpp talkerhaozi@haozi-machine:~$ ros2 run demo_nodes_py listener# 查看节点关系图rqt_graph# 话题相关指令ros2 topic -hros2 topic list # 返回系统中当前活动的所有主题的列表ros2 topic list -t\t# 增加消息类型ros2 topic echo /chatter\t# 打印实时话题内容ros2 topic info /chatter\t# 查看主题信息ros2 interface show std_msgs/msg/String\t# 查看消息类型ros2 topic pub /chatter std_msgs/msg/String data: 123\t# 手动发布消息 4.1.2 自定义案例新建一个包：example_topic，在这里面编写话题测试案例 创建话题发布者程序流程 导入相关接口（若有） 编程接口初始化 创建节点并初始化 创建发布者对象 创建并填充话题消息 发布话题消息 销毁节点并关闭接口 创建话题订阅者程序流程 导入相关接口（若有） 编程接口初始化 创建节点并初始化 创建订阅者对象 回调函数处理话题数据 销毁节点并关闭接口 第一步：在包下的src文件夹中新建文件：pub.cpp，在这个文件中编写发布者代码。 #include rclcpp/rclcpp.hpp// 消息类型头文件#include std_msgs/msg/string.hpp#include std_msgs/msg/u_int32.hpp// 定义一个类class TopicPublisher : public rclcpp::Nodeprivate: // 声名定时器指针 rclcpp::TimerBase::SharedPtr timer_; // 声明话题发布者指针 rclcpp::Publisherstd_msgs::msg::String::SharedPtr command_publisher_; // 定时器回调函数 void timer_callback() // 创建消息 std_msgs::msg::String message; message.data = text; // 日志打印 RCLCPP_INFO(this-get_logger(), Publishing: %s, message.data.c_str()); // 发布消息 command_publisher_-publish(message); public: // 构造函数,有一个参数为节点名称 TopicPublisher(std::string name) : Node(name) RCLCPP_INFO(this-get_logger(), 大家好，我是%s., name.c_str()); // 创建发布者（发布话题名称为：sexy_girl） command_publisher_ = this-create_publisherstd_msgs::msg::String(sexy_girl, 10); // 创建定时器，500ms为周期，定时发布消息 timer_ = this-create_wall_timer(std::chrono::milliseconds(500), std::bind(TopicPublisher::timer_callback, this)); ;int main(int argc, char **argv) rclcpp::init(argc, argv); /*产生一个节点*/ auto node = std::make_sharedTopicPublisher(pub); /* 运行节点，并检测退出信号*/ rclcpp::spin(node); rclcpp::shutdown(); return 0; 第二步：在包下的src文件夹中新建文件：sub.cpp，在这个文件中编写订阅者代码。 #include rclcpp/rclcpp.hpp// 消息类型头文件#include std_msgs/msg/string.hpp#include std_msgs/msg/u_int32.hppusing std::placeholders::_1;using std::placeholders::_2;// 定义一个类class TopicSublisher : public rclcpp::Nodeprivate: // 声明一个订阅者（成员变量）,用于订阅小说 rclcpp::Subscriptionstd_msgs::msg::String::SharedPtr sub_novel; // 声明一个发布者（成员变量）,用于给钱 rclcpp::Publisherstd_msgs::msg::UInt32::SharedPtr pub_money; // 收到话题数据的回调函数 void topic_callback(const std_msgs::msg::String::SharedPtr msg) // 新建一张人民币 std_msgs::msg::UInt32 money; money.data = 10; // 发送人民币 pub_money-publish(money); RCLCPP_INFO(this-get_logger(), 朕已阅：%s，打赏：%d 元稿费, msg-data.c_str(), money.data); ;public: // 构造函数,有一个参数为节点名称 TopicSublisher(std::string name) : Node(name) // 打印一句自我介绍 RCLCPP_INFO(this-get_logger(), 大家好，我是%s., name.c_str()); // 创建一个订阅者来订阅小说，通过名字sexy_girl sub_novel = this-create_subscriptionstd_msgs::msg::String(sexy_girl, 10, std::bind(TopicSublisher::topic_callback, this, _1)); // 创建发布者 pub_money = this-create_publisherstd_msgs::msg::UInt32(sexy_girl_money, 10); ;int main(int argc, char **argv) rclcpp::init(argc, argv); /*产生一个节点*/ auto node = std::make_sharedTopicSublisher(sub); /* 运行节点，并检测退出信号*/ rclcpp::spin(node); rclcpp::shutdown(); return 0; 第三步：添加CMakeLists.txt配置。 # add by user. 让编译器编译sub.cpp这个文件add_executable(sub src/sub.cpp)ament_target_dependencies(sub rclcpp)# add by user. 让编译器编译pub.cpp这个文件add_executable(pub src/pub.cpp)ament_target_dependencies(pub rclcpp)# add by user. 需要手动将编译好的文件安装到 install/example_cpp/lib/example_cpp 下install(TARGETS sub pub DESTINATION lib/$PROJECT_NAME) 编译运行即可。 4.2 接口三种接口形式 话题接口格式：xxx.msg int64 num 服务接口格式：xxx.srv int64 aint64 b---int64 sum 动作接口格式：xxx.action int32 order---int32[] sequence---int32[] partial_sequence 数据类型 基本类型，9类，每个后面都可以加[]将其变为数组。 boolbytecharfloat32, float64int8, uint8int16, uint16int32, uint32int64, uint64string 扩展类型，上述类型的套娃。 接口常用命令 # 查看当前环境下接口列表ros2 interface list# 查看所有接口包ros2 interface packages# 查看某一个包下所有接口ros2 interface package std_msgs# 查看某一个接口详细内容ros2 interface show std_msgs/msg/String# 输出某一个接口所有属性ros2 interface proto sensor_msgs/msg/Image 4.2.1 自定义消息接口新建一个包：example_interface，在这里面编写自定义消息测试案例 第一步：在包下新建一个文件夹（不是src目录下，和src是同级目录）：msg 第二步：在msg文件夹下新建一个消息文件：Novel.msg（首字母必须大写），内容如下 # 直接使用ROS2原始的数据类型string content# 图像消息，调用sensor_msgs下的Image类型sensor_msgs/Image image 第三步：添加CMakeLists.txt配置。 # add by user.查找sensor_msgs库find_package(sensor_msgs REQUIRED)find_package(rosidl_default_generators REQUIRED)# add by user.添加消息文件和依赖rosidl_generate_interfaces($PROJECT_NAME msg/Novel.msg DEPENDENCIES sensor_msgs ) 第四步：添加package.xml配置。 build_dependsensor_msgs/build_dependbuild_dependrosidl_default_generators/build_dependexec_dependrosidl_default_runtime/exec_dependmember_of_grouprosidl_interface_packages/member_of_group 编译后，验证。 haozi@computer:~/ros_place/study$ source install/setup.bash haozi@computer:~/ros_place/study$ ros2 interface package example_interfaceexample_interface/msg/Novelhaozi@computer:~/ros_place/study$ ros2 interface show example_interface/msg/Novel# 直接使用ROS2原始的数据类型string content# 图像消息，调用sensor_msgs下的Image类型sensor_msgs/Image imagehaozi@computer:~/ros_place/study$ ros2 interface proto example_interface/msg/Novelcontent: image: header: stamp: sec: 0 nanosec: 0 frame_id: height: 0 width: 0 encoding: is_bigendian: 0 step: 0 data: [] 4.2.2 自定义服务接口还在包：example_interface，下进行 创建服务自定义接口，步骤如下（4.3小节后面用）： 新建srv文件夹，并在文件夹下新建xxx.srv 在xxx.srv下编写服务接口内容并保存 在CmakeLists.txt添加依赖和srv文件目录 在package.xml中添加xxx.srv所需的依赖 编译功能包即可生成python与c++头文件 还在上面这个包里添加 第一步：在包下新建一个文件夹：srv 第二步：在srv文件夹下新建一个服务接口文件：BorrowMoney.srv（首字母必须大写），内容如下 # 输入参数string nameuint32 money---# bool successuint32 money 第三步：添加CMakeLists.txt配置（比上面多添加了一行）。 # add by user.查找sensor_msgs库find_package(sensor_msgs REQUIRED)find_package(rosidl_default_generators REQUIRED)# add by user.添加消息文件和依赖rosidl_generate_interfaces($PROJECT_NAME #---msg--- msg/Novel.msg #---srv--- srv/BorrowMoney.srv DEPENDENCIES sensor_msgs ) 第四步：添加package.xml配置，前面添加过了这里就不需要了。 编译后，验证 haozi@computer:~/ros_place/study$ source install/setup.bash haozi@computer:~/ros_place/study$ ros2 interface package example_interfaceexample_interface/msg/Novelexample_interface/srv/BorrowMoneyhaozi@computer:~/ros_place/study$ ros2 interface show example_interface/srv/BorrowMoney# 输入参数string nameuint32 money---# 返回参数bool successuint32 moneyhaozi@computer:~/ros_place/study$ ros2 interface proto example_interface/srv/BorrowMoney name: money: 0 同理，再添加一个服务接口：SellNovel.srv uint32 money---string[] novels CMakeLists.txt（比上面又多了一行） rosidl_generate_interfaces($PROJECT_NAME #---msg--- msg/Novel.msg #---srv--- srv/BorrowMoney.srv srv/SellNovel.srv DEPENDENCIES sensor_msgs ) 同样，编译即可。 4.3 服务4.3.1 自带案例# 运行自带的加法器服务haozi@haozi-machine:~$ ros2 run examples_rclpy_minimal_service service# 手动调用服务ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts a: 5,b: 10# 查看服务列表haozi@haozi-machine:~$ ros2 service list# 查看服务接口类型haozi@haozi-machine:~$ ros2 service type /add_two_ints# 查找使用某一接口的服务haozi@haozi-machine:~$ ros2 service find example_interfaces/srv/AddTwoInts 创建服务服务端的程序流程 导入相关接口（若有） 编程接口初始化 创建节点并初始化 创建客户端对象 创建并发送请求数据 等待服务器端应答数据 销毁节点并关闭接口 创建服务客户端的程序流程 导入相关接口（若有） 编程接口初始化 创建节点并初始化 创建客户端对象 创建并发送请求数据 等待服务器端应答数据 销毁节点并关闭接口 4.3.2 自定义服务端新建一个包：example_service，在这里面编写服务端测试案例 程序步骤： 导入服务接口 创建服务端回调函数 声明并创建服务端 编写回调函数逻辑处理请求 第一步：package.xml，等会需要用到这个接口 dependexample_interface/depend 第二步：CMakeLists.txt # find dependenciesfind_package(ament_cmake REQUIRED)find_package(rclcpp REQUIRED)# add by user.自定义接口find_package(example_interface REQUIRED)# add by user.add_executable(serv src/serv.cpp)ament_target_dependencies(serv rclcpp example_interface)# add by user. 需要手动将编译好的文件安装到 install/example_cpp/lib/example_cpp 下install(TARGETS serv DESTINATION lib/$PROJECT_NAME) 第三步：在包下的src文件夹中新建文件：serv.cpp，在这个文件中编写服务代码。 #include rclcpp/rclcpp.hpp// 消息类型头文件#include std_msgs/msg/string.hpp#include std_msgs/msg/u_int32.hpp// 自定义消息类型头文件#include example_interface/srv/sell_novel.hpp// 队列#include queueusing std::placeholders::_1;using std::placeholders::_2;/* 创建一个类节点，名字叫做Serv,继承自Node.*/class Serv : public rclcpp::Nodepublic: // 构造函数 Serv() : Node(wang2) // 打印一句自我介绍 RCLCPP_INFO(this-get_logger(), 大家好，我是单身汉王二.); // 创建一个订阅者来订阅李四写的小说，通过名字sexy_girl sub_ = this-create_subscriptionstd_msgs::msg::String(sexy_girl, 10, std::bind(Serv::topic_callback, this, _1)); // 创建发布者 pub_ = this-create_publisherstd_msgs::msg::UInt32(sexy_girl_money, 10); // 实例化回调组 callback_group_service_ = this-create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive); // 实例化卖二手书的服务 server_ = this-create_serviceexample_interface::srv::SellNovel(sell_novel, std::bind(Serv::sell_book_callback, this, _1, _2), rmw_qos_profile_services_default, callback_group_service_); private: // 声明一个服务回调组 rclcpp::CallbackGroup::SharedPtr callback_group_service_; // 声明一个订阅者（成员变量） rclcpp::Subscriptionstd_msgs::msg::String::SharedPtr sub_; // 声明一个发布者（成员变量） rclcpp::Publisherstd_msgs::msg::UInt32::SharedPtr pub_; // 创建一个小说章节队列 std::queuestd::string novels_queue; // 声明一个服务端 rclcpp::Serviceexample_interface::srv::SellNovel::SharedPtr server_; // 收到话题数据的回调函数 void topic_callback(const std_msgs::msg::String::SharedPtr msg) // 新建一张人民币 std_msgs::msg::UInt32 money; money.data = 10; // 发送人民币给李四 pub_-publish(money); RCLCPP_INFO(this-get_logger(), 王二：我收到了：%s ，并给了李四：%d 元的稿费, msg-data.c_str(), money.data); // 将小说放入novels_queue中 novels_queue.push(msg-data); ; // 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据 void sell_book_callback(const example_interface::srv::SellNovel::Request::SharedPtr request, const example_interface::srv::SellNovel::Response::SharedPtr response) RCLCPP_INFO(this-get_logger(), 收到一个买书请求，一共给了%d钱, request-money); unsigned int novelsNum = request-money * 1; // 应给小说数量，一块钱一章 // 判断当前书库里书的数量是否满足张三要买的数量，不够则进入等待函数 if (novels_queue.size() novelsNum) RCLCPP_INFO(this-get_logger(), 当前艳娘传奇章节存量为%d：不能满足需求,开始等待, novels_queue.size()); // 设置rate周期为1s，代表1s检查一次 rclcpp::Rate loop_rate(1); // 当书库里小说数量小于请求数量时一直循环 while (novels_queue.size() novelsNum) // 判断系统是否还在运行 if (!rclcpp::ok()) RCLCPP_ERROR(this-get_logger(), 程序被终止了); return; // 打印一下当前的章节数量和缺少的数量 RCLCPP_INFO(this-get_logger(), 等待中，目前已有%d章，还差%d章, novels_queue.size(), novelsNum - novels_queue.size()); // rate.sleep()让整个循环1s运行一次 loop_rate.sleep(); // 章节数量满足需求了 RCLCPP_INFO(this-get_logger(), 当前艳娘传奇章节存量为%d：已经满足需求, novels_queue.size()); // 一本本把书取出来，放进请求响应对象response中 for (unsigned int i = 0; i novelsNum; i++) response-novels.push_back(novels_queue.front()); novels_queue.pop(); ;int main(int argc, char **argv) rclcpp::init(argc, argv); /*产生一个Wang2的节点*/ auto node = std::make_sharedServ(); /* 运行节点，并检测退出信号*/ rclcpp::executors::MultiThreadedExecutor exector; exector.add_node(node); exector.spin(); rclcpp::shutdown(); return 0; 编译运行即可。 4.3.3 自定义客户端新建一个包：example_client，在这里面编写客户端测试案例 程序步骤： 导入服务接口 创建请求结果接收回调函数 声明并创建客户端 编写结果接收逻辑 调用客户端发送请求 第一步：package.xml，等会需要用到这个接口 dependexample_interface/depend 第二步：CMakeLists.txt # find dependenciesfind_package(ament_cmake REQUIRED)find_package(rclcpp REQUIRED)# add by user.自定义接口find_package(example_interface REQUIRED)# add by user.添加可执行文件add_executable(clie src/clie.cpp)# add by user.ament_target_dependencies(clie rclcpp example_interface)install(TARGETS clie DESTINATION lib/$PROJECT_NAME) 第三步：在包下的src文件夹中新建文件：clie.cpp，在这个文件中编写服务代码。 #include rclcpp/rclcpp.hpp#include example_interface/srv/sell_novel.hppusing std::placeholders::_1;using std::placeholders::_2;/* 创建一个类节点，名字叫做Clie,继承自Node.*/class Clie : public rclcpp::Nodepublic: Clie() : Node(wang2) // 打印一句自我介绍 RCLCPP_INFO(this-get_logger(), 大家好，我是得了穷病的张三.); client_ = this-create_clientexample_interface::srv::SellNovel(sell_novel); void buy_novel() RCLCPP_INFO(this-get_logger(), 买小说去喽); while (!client_-wait_for_service(std::chrono::seconds(1))) if (!rclcpp::ok()) RCLCPP_ERROR(this-get_logger(), 等待服务的过程中被打断...); return; RCLCPP_INFO(this-get_logger(), 等待服务端上线中); // 构造请求的钱 auto request = std::make_sharedexample_interface::srv::SellNovel_Request(); // 先来五块钱的看看好不好看 request-money = 5; // 发送异步请求，然后等待返回，返回时调用回调函数 client_-async_send_request(request, std::bind(Clie::novels_callback, this, _1)); ; // 创建接收到小说的回调函数 void novels_callback(rclcpp::Clientexample_interface::srv::SellNovel::SharedFuture response) auto result = response.get(); RCLCPP_INFO(this-get_logger(), 收到%d章的小说，现在开始按章节开读, result-novels.size()); for (std::string novel : result-novels) RCLCPP_INFO(this-get_logger(), %s, novel.c_str()); RCLCPP_INFO(this-get_logger(), 小说读完了，好刺激，写的真不错，好期待下面的章节呀！); private: // 创建一个客户端 rclcpp::Clientexample_interface::srv::SellNovel::SharedPtr client_;;int main(int argc, char **argv) rclcpp::init(argc, argv); /*产生一个Wang2的节点*/ auto node = std::make_sharedClie(); node-buy_novel(); /* 运行节点，并检测退出信号*/ rclcpp::spin(node); rclcpp::shutdown(); return 0; 编译运行即可。 把客户端、服务端、话题发布者同时运行起来即可看到效果。 4.4 参数参数：由键值对组成。 键：字符串 值： bool 和 bool[]，布尔类型用来表示开关，比如我们可以控制雷达控制节点，开始扫描和停止扫描。 int64 和 int64[]，整形表示一个数字，含义可以自己来定义 float64 和 float64[]，浮点型，可以表示小数类型的参数值 string 和 string[]，字符串，可以用来表示雷达控制节点中真实雷达的ip地址 byte[]，字节数组，这个可以用来表示图片，点云数据等信息 # 查看参数列表ros2 param list# 查看参数描述信息ros2 param describe node_name param_name# 查看键对应的值ros2 param get node_name param_name# 设置键的值ros2 param set node_name parameter_name value# 给节点的参数保存一份快照（在当前目录下，yaml格式）ros2 param dump node_name# 恢复节点参数ros2 param load node_name file_name# 如：ros2 param load /turtlesim ./turtlesim.yaml# 直接使用参数文件启动ros2 run package_name executable_name --ros-args --params-file file_name# 如：ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml 4.5 动作（暂未用到） Action的三大组成部分目标、反馈和结果。 目标：即Action客户端告诉服务端要做什么，服务端针对该目标要有响应。解决了不能确认服务端接收并处理目标问题 反馈：即Action服务端告诉客户端此时做的进度如何（类似与工作汇报）。解决执行过程中没有反馈问题 结果：即Action服务端最终告诉客户端其执行结果，结果最后返回，用于表示任务最终执行情况。 Action是由话题和服务共同构建出来的（一个Action 三个服务+两个话题） 三个服务分别是：1、目标传递服务。2、结果传递服务。3、取消执行服务 两个话题：1、反馈话题（服务发布，客户端订阅） 2、状态话题（服务端发布，客户端订阅） # 继续运行小乌龟ros2 run turtlesim turtlesim_noderos2 run turtlesim turtle_teleop_key# 该命令用于获取目前系统中的action列表。ros2 action list/turtle1/rotate_absolute# 顺便查看Action使用的接口类型ros2 action list -t/turtle1/rotate_absolute [turtlesim/action/RotateAbsolute]# 查看接口定义ros2 interface show turtlesim/action/RotateAbsolute# 查看Action信息（action客户端和服务段的数量以及名字）ros2 action info /turtle1/rotate_absolute # 发送请求到服务端ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute theta: 1.6# 发送请求到服务端，并查看反馈 5. ament_cmake一个功能包的构建信息包含在 CMakeLists.txt：描述了如何构建此功能包 package.xml：包含该功能包的依赖信息，它可以帮助编译工具colcon确定多个功能包编译的顺序 5.1 CmakeLists.txtROS2的构建系统叫做ament_cmake，它是基于CMake改进而来的。接下来介绍一下ament_cmake常用的一些命令： 找一个比较全的，自己的包找找一样的命令即可。 # 指定cmake的最低版本(3.5)cmake_minimum_required(VERSION 3.5)# 功能包的名字project(nav2_costmap_2d)# 查找ament_cmake包find_package(ament_cmake REQUIRED)# 查找依赖构建此功能包所需要的依赖（ROS2自带的）find_package(rclcpp REQUIRED)find_package(geometry_msgs REQUIRED)find_package(laser_geometry REQUIRED)find_package(map_msgs REQUIRED)find_package(message_filters REQUIRED)find_package(nav2_common REQUIRED)find_package(nav2_msgs REQUIRED)find_package(nav2_util)find_package(nav2_voxel_grid REQUIRED)find_package(nav_msgs REQUIRED)find_package(pluginlib REQUIRED)find_package(rclcpp REQUIRED)find_package(rclcpp_lifecycle REQUIRED)find_package(rmw REQUIRED)find_package(sensor_msgs REQUIRED)find_package(std_msgs REQUIRED)find_package(std_srvs REQUIRED)find_package(tf2_geometry_msgs REQUIRED)find_package(tf2 REQUIRED)find_package(tf2_ros REQUIRED)find_package(tf2_sensor_msgs REQUIRED)find_package(visualization_msgs REQUIRED)find_package(angles REQUIRED)# 查找依赖构建此功能包所需要的依赖（非ROS2自带的）find_package(Eigen3 REQUIRED)include_directories( include $EIGEN3_INCLUDE_DIRS)# 使用add_library构建库add_library(nav2_costmap_2d_core SHARED src/array_parser.cpp src/costmap_2d.cpp src/layer.cpp src/layered_costmap.cpp src/costmap_2d_ros.cpp src/costmap_2d_publisher.cpp src/costmap_math.cpp src/footprint.cpp src/costmap_layer.cpp src/observation_buffer.cpp src/clear_costmap_service.cpp src/footprint_collision_checker.cpp plugins/costmap_filters/costmap_filter.cpp)# 设置变量dependencies，这里主要添加的是ROS2功能包set(dependencies geometry_msgs laser_geometry map_msgs message_filters nav2_msgs nav2_util nav2_voxel_grid nav_msgs pluginlib rclcpp rclcpp_lifecycle sensor_msgs std_msgs std_srvs tf2 tf2_geometry_msgs tf2_ros tf2_sensor_msgs visualization_msgs angles)# 通过ament_target_dependencies添加ROS2功能包依赖，它将依赖的库、头文件以及自身依赖添加到目标中# 即nav2_costmap_2d_core是依赖$dependencies的（前面定义了变量）ament_target_dependencies(nav2_costmap_2d_core $dependencies)# 通过add_executable构建可执行文件，同时也需要使用ament_target_dependencies添加相关依赖# 构建nav2_costmap_2d_markers可执行文件，参数为：src/costmap_2d_markers.cppadd_executable(nav2_costmap_2d_markers src/costmap_2d_markers.cpp)target_link_libraries(nav2_costmap_2d_markers nav2_costmap_2d_core)# nav2_costmap_2d_markers是依赖$dependencies的（前面定义了变量）ament_target_dependencies(nav2_costmap_2d_markers $dependencies)add_executable(nav2_costmap_2d_cloud src/costmap_2d_cloud.cpp)target_link_libraries(nav2_costmap_2d_cloud nav2_costmap_2d_core)add_executable(nav2_costmap_2d src/costmap_2d_node.cpp)ament_target_dependencies(nav2_costmap_2d $dependencies)target_link_libraries(nav2_costmap_2d nav2_costmap_2d_core layers filters)# 安装库install(TARGETS nav2_costmap_2d_core layers filters nav2_costmap_2d_client ARCHIVE DESTINATION lib LIBRARY DESTINATION lib RUNTIME DESTINATION bin)# 安装可执行文件，注意这里的可执行文件路径为： lib/$PROJECT_NAME而不是bininstall(TARGETS nav2_costmap_2d nav2_costmap_2d_markers nav2_costmap_2d_cloud RUNTIME DESTINATION lib/$PROJECT_NAME)# 导出头文件install(DIRECTORY include/ DESTINATION include/)# 导出launch和参数文件install( DIRECTORY launch params DESTINATION share/$PROJECT_NAME)# 通过ament_export_include_directories导出该功能包的头文件，以便其他功能包依赖此功能包时，能够找到对应的头文件ament_export_include_directories(include)# 通过ament_export_libraries导出该功能包构建的库，以便其他功能包能够顺利链接到ament_export_libraries(layers filters nav2_costmap_2d_core nav2_costmap_2d_client)# 通过ament_export_dependencies导出此功能包所有的ROS相关的依赖，依赖其他功能包依赖此功能包时，不必再通过find_package重复添加这些依赖ament_export_dependencies($dependencies) 5.2 package.xml!-- 编译的工具依赖 --buildtool_dependament_cmake/buildtool_depend!-- 依赖的ROS2功能包 --dependgeometry_msgs/dependdependlaser_geometry/dependdependmap_msgs/dependdependmessage_filters/dependdependnav2_msgs/dependdependnav2_util/dependdependnav2_voxel_grid/dependdependnav_msgs/dependdependpluginlib/dependdependrclcpp/dependdependrclcpp_lifecycle/dependdependsensor_msgs/dependdependstd_msgs/dependdependstd_srvs/dependdependtf2/dependdependtf2_geometry_msgs/dependdependtf2_ros/dependdependtf2_sensor_msgs/dependdependvisualization_msgs/dependdependangles/depend!-- 导出依赖 --export build_typeament_cmake/build_type/export 6. 工具6.1 Launch补充：安装配套支持 #首先切换到工作空间下的src目录下，然后执行下面操作sudo apt install python3-pip # python包管理工具sudo pip3 install rosdepc # 安装ros依赖工具sudo resdepc init rosdepc update # 更新#切回工作空间目录下，然后执行下面操作rosdepc install -i --from-path src --rosdistro foxy -y # 自动添加依赖#如果报如下错误，是缺少依赖（最后括号里面的）ERROR: the following packages/stacks could not have their rosdep keys resolvedto system dependencies:learning_urdf: Cannot locate rosdep definition for [joint_state_publisher_gui]learning_tf: Cannot locate rosdep definition for [tf_transformations]#解决办法：缺啥安装啥，如第一个（ros-foxy-依赖名字）udo apt-get install ros-foxy-joint_state_publisher_gui#如果报错就把_换成-#所有的都安装完了之后，重新执行rosdepc install -i --from-path src --rosdistro foxy -y # 自动添加依赖sudo apt install python3-colcon-ros # 安装编译器colcon build\t# 编译当前工程指令#编译完成之后，工作空间就有了#build、install、log文件夹#src（原来就有）文件夹#配置环境变量#在install文件夹中有 local_setup.sh文件source install/local_setup.sh#添加环境变量#在用户home文件夹，ctrl + H 显示隐藏文件#找到 .bashrc 文件，在文件末尾添加 （最后有个空格！）source ~/ROS2_Sapce/0_dev_ws/install/local_setup.sh 功能包 ros2 pkg create --build-type build-typepackage_name#创建功能包cd ~/dev_ws/srcros2 pkg create --build-type ament_cmake learning_pkg_c\t# c++ros2 pkg create --build-type ament_python learning_pkg_python # python#编译功能包cd ~/dev_ws/srccolcon buildsource install/local_setup.bash","tags":["ROS","ROS2"],"categories":["Linux应用"]},{"title":"CanOpen","path":"/2023/07/01/07. 通信协议/canopen/","content":"1. CAN协议 和串口、I2C、SPI、485、232等通讯协议一样，CAN也是种传送数据的方式。 1.1 物理接线 CAN通信需要两根线，CAN_H、CAN_L，两根线采用双绞线的方式缠绕。 每个通讯节点的CAN_H接在一起，CAN_L接在一起。 两端接两个120欧的电阻。 1.2 信号传输 线上的电位采用差分信号进行判别，抗干扰能力强。 电平判断 CAN_H - CAN_L 0.5V 时候为隐性的，逻辑信号表现为”逻辑1”- 高电平。 CAN_H - CAN_L 0.9V 时候为显性的，逻辑信号表现为”逻辑0”- 低电平。 CAN总线在电平传输上，具有仲裁判断逻辑，优先级为：显性（低电平）隐形（高电平）！ 1.3 协议规定CAN规定了5种不同的数据帧（发送一次数据就是一帧数据，类似于串口发送一个字节数据？）。 数据帧（重要）：向接受单元传送数据用的。 遥控帧：向远端节点请求数据用的。 错误帧：当检测出错误是向其他单元通知错误。 过载帧：接收单元通知其未做好准备。 帧间隔：用于将数据帧和遥控真与前面的分离开。 主要掌握数据帧，遥控帧基本上已经不用了。其他的先知道即可。 对于数据帧和遥控帧，帧结构都由以下7个段组成。 该结构有两种格式：标准格式和扩展格式。可以看出，两种格式的区别仅在于仲裁段和控制段不同。 每个段都有自己的格式，用户需要关注的段为：仲裁段、数据段。更具体的说是，仲裁段的 ID和数据段。 仲裁段有一套仲裁机制，当总线上的各个节点同时发送设备时，根据ID优先级判断哪个节点的信息有效。ID 越小，优先级越高。 更具体的仲裁机制还需要根据不同的段做出不同的反应，比如退出竞争、产生错误等。这里就不详细说了，有兴趣的可以再去详细了解。 数据段中是每次要发送的数据，其长度为 0-8 个字节。 作为写应用的，我们只需要关注这两部分即可。 比如 RT-Thread 中的 CAN 发送函数（来源）。需要我们注意的有ID、格式、帧类型、数据、长度。 struct rt_can_msg msg = 0;msg.id = 0x78; /* ID 为 0x78 */msg.ide = RT_CAN_STDID; /* 标准格式 */msg.rtr = RT_CAN_DTR; /* 数据帧 */msg.len = 8; /* 数据长度为 8 *//* 待发送的 8 字节数据 */msg.data[0] = 0x00;msg.data[1] = 0x11;msg.data[2] = 0x22;msg.data[3] = 0x33;msg.data[4] = 0x44;msg.data[5] = 0x55;msg.data[6] = 0x66;msg.data[7] = 0x77;/* 发送一帧 CAN 数据 */size = rt_device_write(can_dev, 0, msg, sizeof(msg)); 而相关的内容，API 都已经封装好了，就不用我们管了。 struct rt_can_msg rt_uint32_t id : 29; rt_uint32_t ide : 1; rt_uint32_t rtr : 1; rt_uint32_t rsv : 1; rt_uint32_t len : 8; rt_uint32_t priv : 8; rt_int32_t hdr : 8; rt_uint32_t reserved : 8; rt_uint8_t data[8];;typedef struct rt_can_msg *rt_can_msg_t; 接收也是一样的封装好了，我们只需要取出我们需要的 ID 和数据即可。 /* 从 CAN 读取一帧数据 */rt_device_read(can_dev, 0, rxmsg, sizeof(rxmsg));/* 打印数据 ID 及内容 */rt_kprintf(ID:%x, rxmsg.id);for (i = 0; i 8; i++) rt_kprintf(%2x, rxmsg.data[i]); 至此，CAN 的使用需要了解的应该就够了。 如果想了解的更详细，别人的文章，上面有水印的图就是他的。知乎文章 2. CANopen概念从上面可以看出，CAN 总线确定了一种数据传输的物理和数据方式。即，用什么设备传输数据、怎么传输数据、格式是什么。 但是，在我们写应用的时候，数据传输时每个人对于 ID 或者数据都有自己的规定，不统一。即，在这个层面上缺乏一个统一的标准去规定不同ID和数据的含义是什么。 因此，CANopen做的就是这个工作。 2.1 通信特点CANopen规定的报文特点： 报文传输采用 CAN 标准帧格式。即 11bit 的 ID 域，以尽量减小传输时间； 网络控制报文均采用数据最小字节数。比如心跳报文，只有1个字节数据； 实时更新的过程数据无需接收方报文应答。即采用生产消费模型，降低总线负载； 需要接收方确认的配置参数一般都是采用快速单字传输。即1个报文最多传送1个32字节的参数变量，避免了分帧引起的实时性降低。 规定上述特点的原因是，CAN通信具有可以突发发送的实时性优势，但是多个节点下，突发具有较大的冲突可能性。因此，上述特点可以尽可能保证实时性。 CANopen 协议通常分为用户应用层、对象字典以及通信三个部分。 用户应用层：用户根据实际的需求编写的应用对象。 对象字典：最核心的部分，描述了应用对象和 CANopen 报文之间的关系。 通信：很重要的部分，定义了 CANopen 协议通信规则以及与CAN控制器驱动之间对应关系，掌握这部分才能让我们写自己的应用对象。 前面我们说了，CAN通信中，我们需要关注的就是CAN-ID和DATA。 在CANopen中也是一样的，我们需要知道这两部分是怎么设置的，分别有什么含义。 2.2 对象字典(OD)CANopen 对象字典（OD: Object Dictionary）是 CANopen 协议最为核心的概念。 对象字典就是一个有序的对象组，描述了对应 CANopen 节点的所有参数，包括通讯数据的存放位置也列入其索引，这个表变成可以传递形式就叫做EDS文件（电子数据文档 Electronic Data Sheet）。 其中，每个对象采用一个 16 位的索引值来寻址，这个索引值通常被称为索引，其范围在0x0000到0xFFFF之间。为了避免数据大量时无索引可分配，所以在某些索引下也定义了一个8 位的索引值，这个索引值通常被称为子索引，其范围是0x00到0xFF之间。每个索引内具体的参数，最大用32位的变量来表示，四个字节。 如下图是某遵循 CANopen 协议的电机的 EDS 文件。 EDS 文件是每个节点都有的，采用字典的形式保存了该节点的参数等信息。其他节点可以通过索引等信息访问或者修改这些信息。 理解： 对于某个设备而言，预定义了各个节点通信需要收发的信息都有什么，表现形式上就是如上图的一个表格。每一行就是一个对象，每个对象中存放的是什么内容可以自定（有些条目是固定的）。CANopen的收发就是在收发这些对象。 2.3 数据传输(PDO、SDO)2.3.1 对象分类说数据传输之前先说两种数据收发模型： 生产消费模型：生产者向外发送数据，不指定对象，消费者消费数据。即，生产者并不会得到回复。 服务器客户端模型：客户端向服务器发送数据请求，服务器回复请求的数据。即，客户端会得到数据回复。其中，从服务器读取的动作是上传，向服务器写入的动作是下载（可以看出该动作是相对于服务器而言的）。 在 CANopen 中配置信息或应用信息的传输是通过两种对象进行传输的：过程数据对象 PDO（Process data object）、服务数据对象 SDO（Service data object），其中： PDO：属于过程数据，即单向传输，无需接收节点回应 CAN 报文来确认，即，生产消费模型。 SDO：属于服务数据，有指定被接收节点的地址（Node-ID），并且需要指定的接收节点回应 CAN 报文来确认已经接，如果超时没有确认，则发送节点将会重新发送原报文。即服务器客户端模型。 即，把上面的那些对象分为两类，PDO、SDO，第一类表示发过去无需回复。第二类表示发送过去之后需要接收方进行回复的对象。 对于 PDO 对象：由于需要区分每个 CANopen 节点的输入和输出，所以 PDO 分为 TPDO（发送PDO）和 RPDO（接收PDO），发送和接收是以 CANopen 从站节点为参考（如果CAN主站就相反）。TPDO 和 RPDO 分别有4个数据对象，每种数据对象就是1条CAN报文封装，这些都是数据收发的容器。 TPDO1（发送PDO）：从站主动传输TXPDO数据给主站，从站发送。 RPDO1（接收PDO）：主站主动传输RxPDO数据给从站，从站接收。 TPDO2 RPDO2 TPDO3 RPDO3 TPDO4 RPDO5 可以看到这个RT是站在从站的角度看的。 另外，不同类别对象的索引，是有规定的，不是随便定的。 2.3.2 对象编号CANopen 预定义了强制性的缺省标识符（CAN-ID）分配表，该分配表是基于11 位CAN-ID 的标准帧格式。将其划分为4 位的功能码（Function-ID）和7 位的节点号（Node-ID）。 从这张图中，要搞清楚一个概念。 节点号：一个网络中的每个节点都有一个自己的编号，用 7bit 表示，即，一个网络中最多能有127个通讯节点（0不行）。 通信对象编号（COB-ID）：在 CANopen 中就是 CAN-ID，可以看出，节点号被包含在 COB-ID 中。 3. 数据通信前面提到，不管是CAN还是CANopen需要我们关注的都是CAN-ID和DATA。 3.1 服务数据对象SDO特性：SDO 主要用于 CANopen 主站对从节点的参数配置。服务确认是SDO的最大的特点，为每个消息都生成一个应答，确保数据传输的准确性。 在收发 SDO 对象时比较简单固定。一般在 CANopen 网络中，只有 NMT 主机能发起 SDO 通讯，进行节点参数配置或者关键性参数的传递。当然从节点也可以对其他从节点发起SDO通讯。 NMT主机后面会介绍，这里只需要知道，主机（主动方）可以发起SDO通讯就行了。 3.1.1 ID设置 发送方（客户端）：发送 CAN-ID 为600h + Node-ID的报文，其中 Node-ID 为接收方（服务器）的节点地址，数据长度均为8字节； 接收方（服务器）：成功接收后，回应 CAN-ID 为580h + Node-ID的报文。这里的 Node-ID 也是是接收方（刚刚的发送方）的节点地址，数据长度均为8字节。 如下图中的最后两行，为 CANopen 预定义报文的 SDO 报文中的 ID 分类。 3.1.2 数据设置在发送数据时分为两类，快速SDO协议、普通SDO协议。 快速SDO协议（常用） 最常用最常见的 SDO 协议是快速 SDO，快速，就是1次来回就搞定。前提是读取和写入的值不能大于 32 位。如图所示，为快速 SDO 协议的示意图。命令中直接包含了要读写的索引、子索引、数据。可谓直接命中。 通过快速 SDO，可以直接对 CANopen 节点的对象字典中的值进行读取和修改，所以在做参数配置之外，也经常作为关键性数据传输之用。比如 CANopen 控制机器人的电机转动角度时，就使用 SDO 来传输，保证可靠。 举个例子，保利时电机将电机设置为转矩模式。 需要发送的数据为： ID：0x00 00 06 02，其中0x2是要发送给（接收方）的节点号。（可以对照3.1.1小节的图） DATA：0x2F 60 60 00 04 00 00 00，其中0x2F为命令符，0x60 60为索引，0x00为子索引，0x04 00 00 00为要发送的数据。 接收到的回复为： ID：0x00 00 05 82，其中0x2表示是谁给出的回复。（参考2.3小节最后） DATA：0x60 60 60 00 00 00 00 00，其中0x60表示成功，0x60 60为索引，0x00为子索引，0x00 00 00 00为回复的数据。 这就是一个发送SDO对象的案例。这里更改的对象为：索引为0x60 60，子索引为0x00，对象含义为电机的运行模式。 普通SDO协议（了解） 当需要传输的值超过 32 位时，就不能使用快速 SDO 传输。必须使用普通 SDO 进行分帧传输。在应用中较少用到。普通 SDO 协议难点在于分包逻辑与 CS 命令符的变化。依然难以记忆。当然普通 SDO 的 CAN 帧 ID 与快速 SDO 相同，依然发送方（客户端）发送的报文CAN-ID为600h + Node-ID，接收方（服务器）成功接收后，回应CAN-ID为580h + Node-ID的报文。 下载协议download protocol 上传协议upload protocol 3.2 过程数据对象PDOPDO 属于过程数据，用来传输实时数据，即单向传输，无需接收节点回应 CAN 报文来确认，属于“生产消费”模型 PDO。数据长度被限制为1~8 字节。最多只要1帧就可以把一条信息或者一个变量传递结束。 但是PDO的收发不只是简单的设置ID和DATA的问题，这个相对来说有点麻烦。 3.2.1 ID设置 发送方：根据自己属于哪一类对象 PDO 对象决定自己的 ID。比如，发送 CAN-ID 为180h + Node-ID的报文，其中 Node-ID 为发送方（自己）的节点地址，用于告诉是谁发送出去的。数据长度 1 - 8 字节。 如下图中的前面 8 行，为 CANopen 预定义报文的 PDO 报文中的 ID 分类。 当然，如果某个节点需要传递的资源特别多，则有出现例如 TPDO5 之类的数据对象，而它们的 CAN-ID 定义就需要打破预定义的规则，比如我们可以定义Node-ID为1的节点中 TPDO5 是 182h，这里的 PDO 的 COB-ID 中的低 7 位不再是表示 Node-ID。其实所有的 PDO 的 COB-ID 与 Node-ID 无必然规则上的联系。 也举个例子，保利时电机驱动器接通后，会一直循环上报编码器位置。 上位机接收到的数据为： ID：0x01 82，其中0x2是驱动器自己的节点号。（0x01 80 可以对照到上图中的TPDO1）。 DATA：0x2F 60 60 00，为编码器的读数。 这就是一个上位机接收PDO对象的案例。这里主要是为了看这个ID，数据先不用在意，等会看后面。 3.2.2 传输方式PDO的两种传输方式：同步传输和异步传输。如图所示，1、2为异步传输，3、4为同步传输。 上面的例子中，就是用的第一种异步传输的方式。 3.2.3 数据设置PDO 的通信数据中，定义了该设备所使用的 COB-ID、传输类型、定时周期等。 其中，RPDO通讯参数位于对象字典索引的 1400h to 15FFh，TPDO通讯参数位于对象字典索引的 1800h to 19FFh。 前面说过，不同类别对象的索引，是有规定的，不是随便定的。这里就看到了。 每条索引代表一个PDO的通信参数集，其中的子索引分别指向具体的各种参数。如表所示。 Number of entries 参数条目数量：即本索引中有几条参数； COB-ID：即这个PDO发出或者接收的对应CAN帧ID； 发送类型：即这个PDO发送或者接收的传输形式，通常使用循环同步和异步 制造商特定事件较多； Inhibit time生产禁止约束时间(110ms)：约束PDO发送的最小间隔，避免导致总线负载剧烈增加，比如数字量输入过快，导致状态改变发送的TPDO频繁发送，总线负载加大，所以需要一个约束时间来进行“滤波”，这个时间单位为0.1ms； Event timer事件定时器触发的时间(单位ms)：定时发送的PDO，它的定时时间，如果这个时间为0，则这个PDO为事件改变发送。 SYNC start value同步起始值：同步传输的PDO，收到诺干个同步包后，才进行发送，这个同步起始值就是同步包数量。比如设置为2，即收到2个同步包后才进行发送。 3.2.4 PDO映射参数（难）PDO 对象并不是和 SDO 一样直接看着表使用ID + DATA发送出去的。 PDO 所携带的实时数据类型和内容是由设备对象字典中所规定的该 PDO 映射结构决定。 PDO映射参数，包含了一个对象字典中的对象列表，这些对象映射到相应的PDO，其中包括数据的长度（单位，位），对于生产者和消费者都必须要知道这个映射参数，才能够正确的解释PDO内容。就是将通信参数、应用数据和具体CAN报文中数据联系起来。 RPDO 通讯参数 1400h to 15FFh，映射参数 1600h to 17FFh，数据存放为 2000h 之后厂商自定义区域； TPDO 通讯参数 1800h to 19FFh，映射参数 1A00h to 1BFFh，数据存放为 2000h 之后厂商自定义区域。 有点懵逼哈，整个例子，看下图。 解释一下这张图： 第一个表：从 Index 索引可以看出这是个 TPDO 对象。子索引和对应的对象内容，定义了该对象的ID、发送类型等。 第二个表：从 Index 索引可以看出，这是上面那个 TPDO 对象的映射对象。 子索引 01h 的内容为 0x2000 01 08，表示索引为 0x1800 的 TPDO 对象的前 8 位值为：索引为2000h、子索引为 0x01 的对象的值。 子索引 02h 的内容为 0x2003 03 10，表示索引为 0x1800 的 TPDO 对象的接着 16 位值为：索引为2003h、子索引为 0x03 的对象的值。（注意，低位在前） 子索引 03h 的内容为 0x2003 01 08，表示索引为 0x1800 的 TPDO 对象的接着 8 位值为：索引为2003h、子索引为 0x01 的对象的值。 第三个表，从 Index 可以看出，这里是厂商自定义区域。 第四个表，我们实际发送的内容 ID：0x181。（从第一个表看） DATA：就是按照上面映射得到的值。 另外，前面说对象的索引不是能随便定义的。 分配对象：索引为0x1cxx 映射对象：索引为0x16xx、0x1Axx 应用对象：索引为0x6xxx、0x7xxx 比如，3.1小节的案例中，发送的对象的索引为0x6060，就是一个应用对象。这里的映射对象的索引也是确定的。 3.2.5 设置步骤PDO报文用来传输有实时性要求的过程数据，传输类型可以是事件类型、同步传输、周期传输。PDO报文基于生产者消费者模式，所以使用之前需要先配置好生产者和消费者，这些在映射参数（1600h+n）和通信参数（1400h+n）里面完成。具体分以下三步完成。注：n 为设备地址。 接收型 RPDO 在索引1400h + n，子索引 01 确定的变量里写入COB-ID(4字节) 在索引1400h + n，子索引 02 里面写入传输类型t（1字节）t 1–240，表示设备每收到 t 个同步报文发送一次 PDO；t 253，表示每收到一个远程（RTR 1）PDO 请求后方可发送；t 254，表示事件触发传输模式（制造商特定事件）；t 255，事件触发传输模式（设备子协议CiA 401特定事件），即利用设备自身内部的定时器，定时发送一条 PDO 报文。 在索引1600h + n下面定义映射关系，子索引 00：定义其后面的总子索引数目，在该例子中为2； 在索引1600h + n下面定义映射关系，子索引 01：写入第一个变量的映射地址，按以下格式写： 索引（2字节）- 子索引（1字节）- 数据类型（1字节）。例如将1号通道的模拟量值定义为映射变量，它的索引为6401h，子索引为01，数据类型为2字节16位，代号为10h，连起来即64010110h； 在索引1600h + n下面定义映射关系，子索引 02：这里定义 1-8 通道的数字量输入（索引6000h：01）为映射变量，故其内容为60000108h。至此已完成配置。 发送型 PDO 在索引1800h + n，子索引 01 写入 COB-ID； 在其对应子索引 02 写入传输类型，同 RPDO； 在索引1A00h + n配置映射，具体同 RPDO。 4. 补充这也是很关键的部分，但是为了防止影响理解上面的PDO、SDO，后说这部分。 4.1 NMT网络管理在 CAN 通讯中，所有节点通信地位平等，运行时允许自行发送报文。 但，CANopen 网络为了稳定可靠可控。在一个通讯网络中需要设置： 一个网络管理主机NMT-Master（Network Management-Master）。一般是 CANopen 网络中具备监控的 PLC 或者 PC。也称为 CANopen 主站。 剩下的一个或多个为从机NMT-slaves。 NMT主机和NMT从机之间通讯的报文就称为NMT网络管理报文。管理报文负责层管理、网络管理和ID分配服务。例如，初始化、配置和网络管理（其中包括节点保护）。 另外，为了协调各个节点的同步、心跳、时间、错误提示等通讯控制，CANopen还定义了一系列特殊协议（Special protocols）报文。 上图中，绿色底纹的常用。 每个CANopen从节点的 CANopen 协议栈中，必须具备 NMT 管理的相应代码。这是节点具备 CANopen 协议的最基本的要素。 4.2 NMT节点状态NMT管理涉及到一个CANopen节点从上电开始的6钟状态，包括： 初始化（Initializing）：节点上电后对功能部件包括 CAN 控制器进行初始化； 应用层复位(Application Reset）：节点中的应用程序复位(开始），比如开关量输出模拟量输出模拟量输出的初始值； 通讯复位（Communication reset）：节点的 CANopen 通讯复位（开始），从这个时刻，此节点就可以进行 CANopen 通讯了； 预操作状态（Pre-operational）：节点的 CANopen 通讯处于操作就绪状态，此时此节点不能进行 PDO 通信，而可以进行 SDO 进行参数配置和 NMT 网络管理的操作； 操作状态（operational）：节点收到 NMT 主机发来的启动命令后，CANopen 通讯被激活，PDO 通信启动后，按照对象字典里面规定的规则进行传输，同样 SDO 也可以对节点进行数据传输和参数修改； 停止状态（Stopped）：节点收到 NMT 主机发来的停止命令后，节点的 PDO 通信被停止，但 SDO 和 NMT 网络管理依然可以对节点进行操作； 除了初始化状态，NMT 主机通过 NMT 命令可以让网络中任意一个的 CANopen 节点进行其他5种状态的切换。当然 CANopen 节点也可以程序自动完成这些状态的切换。 4.3 NMT节点报文 节点上线报文：任何一个 CANopen 从站上线后，为了提示主站它已经加入网络（便于热插拔），或者避免与其他从站 Node-ID 冲突。这个从站必须发出节点上线报文（boot-up），节点上线报文的ID为 700h + Node-ID，数据为1个字节0。生产者为 CANopen 从站。 简单来说，一个从节点上线需要先发送个报文，告诉主机我上线了。 心跳报文：为了监控 CANopen 节点是否在线与目前的节点状态。从站需要定时发送状态报文（心跳报文）。ID与节点上线报文相同为700h + Node-ID，数据为1个字节，代表节点目前的状态，04h为停止状态，05h为操作状态，7Fh为预操作状。 CANopen 从站按其对象字典中 1017h 中填写的心跳生产时间（ms）进行心跳报文的发送，而 CANopen 主站（NMT主站）则会按其 1016h 中填写的心跳消费时间进行检查，假设超过诺干次心跳消费时间没有收到从站的心跳报文，则认为从站已经离线或者损坏。 节点守护：在早期 CANopen 应用中，可以通过轮询模式监视从站状态的节点守护模式，它与心跳报文模式二者不能并存。通过节点守护，MNT主机可以检查每个节点的当前状态。很少用了。 NMT节点状态切换命令：NMT网络管理中，最核心的就是NMT节点状态切换命令，这是NMT主站所进行网络管理的“命令”报文。 CAN-ID 均为 000h，具备最高的 CAN 优先级。数据为2个字节： 第1个字节代表命令类型： 01h 为启动命令（让节点进入操作状态）； 02h 为停止命令（让节点进入停止状态）； 80h 为进入预操作状态（让节点进入预操作状态）； 81h 为复位节点应用层（让节点的应用恢复初始状态，比如列车门都恢复打开状态）； 82h 为复位节点通讯（让节点的 CAN 和 CANopen 通讯重新初始化，一般用于总线收到干扰，导致节点总线错误被动，或者总线关闭时）。 第二个字节代表被控制的节点 Node-ID，如果要对整个网络所有节点同时进行控制，则这个数值为0即可。 另外还有 同步协议（Syncprotocol） 时间戳协议（Time-stamp protocol）：CAN-ID 为 100h，数据长度为 6，数据为当前时刻与1984年1月1日0时的时间差。 紧急报文协议（Emergency protocol）：其 CAN-ID 存储在 1014h 的索引中，一般会定义为0x080 + Node-ID，数据包含8个字节。","tags":["Can","CanOpen"],"categories":["通信协议"]},{"title":"Ymodem","path":"/2023/01/01/07. 通信协议/ymodem/","content":"1. 交互流程 这里是以BootLoader为目的写的。 很多Shell工具都有自带的Xmodem、Ymodem传输文件的功能。这里以SecureCRT 9.2软件为例进行分析。不同的软件实际上可能有些许差异。 至此，流程结束。 2. STM32示例这里已经将Ymodem协议接收部分已经封装好了。 头文件 /* * ymodem.h * * Created on: 2024年9月23日 * Author: ZhangJinhao */#ifndef PROTOCOL_YMODEM_H_#define PROTOCOL_YMODEM_H_#include stdint.h/* 此协议流程参考：SecureCRT 9.2, Ymodem协议，其他上位机未经过测试 */// 一包数据格式为：帧命令 + 索引 + 索引反码 + 数据(128/1024) + CRC16校验码// 帧命令#define YMODEM_SOH (0x01) // 128字节数据命令#define YMODEM_STX (0x02) // 1024字节数据命令#define YMODEM_EOT (0x04) // 发送结束命令#define YMODEM_ACK (0x06) // 接收正确应答命令#define YMODEM_NAK (0x15) // 接收错误应答命令#define YMODEM_CA (0x18) // 取消传输#define YMODEM_C (0x43) // 开始发送命令#define YMODEM_ABORT1 (0x41) /* A == 0x41, abort by user */#define YMODEM_ABORT2 (0x61) /* a == 0x61, abort by user */// 长度定义#define YMODEM_PACKET_HEADER_LEN (3) // 包头长度(命令+索引+索引反码)#define YMODEM_PACKET_SIZE (128) // Ymodem包长度#define YMODEM_PACKET_1K_SIZE (1024) // Ymodem-1K包长度#define YMODEM_PACKET_TRAILER_LEN (2) // 包尾长度(CRC16)#define YMODEM_PACKET_OVERHEAD (YMODEM_PACKET_HEADER_LEN + YMODEM_PACKET_TRAILER_LEN) // 除去数据外，另外的长度// 一包数据中，索引和索引反码所处的位置#define YMODEM_PACKET_SEQNO_INDEX (1)#define YMODEM_PACKET_SEQNO_COMP_INDEX (2)// 文件信息帧中文件长度#define YMODEM_FILE_NAME_LENGTH (80) // 文件名长度#define YMODEM_FILE_SIZE_LENGTH (16) // 文件大小长度// 超时时间定义#define NAK_TIMEOUT (5000) // 5秒typedef struct _ymodem uint8_t file_name[128]; // 需要接收的文件名 uint32_t file_size; // 需要接收的文件大小（单位：字节） uint8_t buf[YMODEM_PACKET_1K_SIZE + YMODEM_PACKET_OVERHEAD]; // 最大：帧命令 + 索引 + 索引反码 + 数据(128/1024) + CRC16校验码 = 1029字节 uint8_t pack_cnt; // 下一包需要接收的索引号（0-FF之间循环） uint8_t info_done; // 收到文件信息 uint8_t file_done; // 收到了文件数据 uint8_t null_done; // 收到空文件信息 uint32_t app_addr; // app程序的起始地址 uint32_t app_size; // app程序占用空间大小 uint32_t flash_cnt; // 已经写入到flash的字节数 ymodem_t;typedef ymodem_t *ymodem_ptr;int32_t ymodem_receive(void);#endif /* PROTOCOL_YMODEM_H_ */ 源文件 #include ymodem.h#include stdlib.h#include iap.h#include usart.h// ============================================ 以下函数需要用户做适配 ============================================ //ymodem_t ymodem = .file_name = 0, .file_size = 0, .buf = 0, .pack_cnt = 0, .info_done = 0, .file_done = 0, .null_done = 0, .app_addr = 0x08004000, // APP起始地址 .app_size = 0x3C000, // APP空间大小 .flash_cnt = 0,;// 发送一个字符static uint8_t ymodem_send_byte(uint8_t byte) HAL_UART_Transmit(huart1, byte, 1, 0xFF); return 0;// 接收一个字符，成功返回0，失败返回1static uint8_t ymodem_recv_byte(uint8_t *data, uint32_t timeout) HAL_UART_Receive(huart1, data, 1, timeout); return 0;// ymodem写flash函数，将接收到的数据写到flash中static uint8_t ymodem_flash_write(uint32_t addr, uint8_t *data, uint32_t len)\tstm32_flash_write(addr, data, len); return 0;// ymodem擦除app函数，擦除app区域flashstatic uint8_t ymodem_flash_erase(uint32_t addr, uint32_t len) stm32_flash_erase(addr, len); // 调试信息输出static uint8_t ymodem_printf(const char *format, ...) return 0;// ============================================ 以上函数需要用户做适配 ============================================ //// CRC校验函数static uint16_t CRC16_Xmodem(uint8_t *data, uint32_t len) uint8_t i; uint16_t crc = 0x0000; while (len--) crc ^= (*data++ 8); for (i = 0; i 8; i++) if (crc 0x8000) crc = (crc 1) ^ 0x1021; else crc = crc 1; return crc;// ymodem 接收一个包的数据// return:// -1: 接收失败（未收到 或 超时 或 错误命令 或 校验失败）// 0：正常成功（收到完整数据length=128/1024 或 收到结束帧length=0 或 发送方要求停止length=-1）// 1：主机要求取消传输static int8_t ymodem_recv_packet(uint8_t *data, uint32_t *length, uint32_t timeout) uint16_t i, packet_size, crc; uint8_t c; *length = 0; // 接收第一个字符 if (ymodem_recv_byte(c, timeout) != 0) return -1; // 判断命令类型 switch (c) case YMODEM_SOH: packet_size = YMODEM_PACKET_SIZE; // 128byte break; case YMODEM_STX: packet_size = YMODEM_PACKET_1K_SIZE; // 1024byte break; case YMODEM_EOT: return 0; case YMODEM_CA: if ((ymodem_recv_byte(c, timeout) == 0) (c == YMODEM_CA)) *length = -1; return 0; else return -1; case YMODEM_ABORT1: case YMODEM_ABORT2: return 1; default: return -1; // 如果命令正确，继续接收够一包数据 // 第一个字节 *data = c; // 剩下的字节 for (i = 1; i (packet_size + YMODEM_PACKET_OVERHEAD); i++) if (ymodem_recv_byte(data + i, timeout) != 0) return -1; // 校验索引和索引反码是否配对 if (data[YMODEM_PACKET_SEQNO_INDEX] != ((data[YMODEM_PACKET_SEQNO_COMP_INDEX] ^ 0xff) 0xff)) return -1; // 校验CRC校验码是否正确(仅计算数据区域) crc = CRC16_Xmodem(data[YMODEM_PACKET_HEADER_LEN], packet_size); if (((crc 8) != data[YMODEM_PACKET_HEADER_LEN + packet_size]) || ((crc 0x00FF) != data[YMODEM_PACKET_HEADER_LEN + packet_size + 1])) return -1; // 记录本包中有效数据长度 *length = packet_size; return 0;// 阻塞式接收，一直到接收完成后返回。// return:// 1: 发送方要求停止// 0: 接收成功int32_t ymodem_receive(void) uint32_t packet_length = 0; // 擦除flash ymodem_flash_erase(ymodem.app_addr, ymodem.app_size); // 发送字符C,开始接收 ymodem_send_byte(YMODEM_C); while (1) // 先清空缓冲区，重新收 memset(ymodem.buf, 0, YMODEM_PACKET_1K_SIZE + YMODEM_PACKET_OVERHEAD); // 接收一包数据 switch (ymodem_recv_packet(ymodem.buf, packet_length, NAK_TIMEOUT)) // 成功接收到一包数据 case 0: // 根据收到的数据长度判断收到的是什么命令 switch (packet_length) // 发送方要求停止 case -1: ymodem_send_byte(YMODEM_ACK); return 1; // 收到文件结束帧 case 0: ymodem_send_byte(YMODEM_ACK); ymodem_send_byte(YMODEM_C); ymodem.file_done = 1; ymodem.pack_cnt = 0; break; // 收到了正常的一包数据 default: // 判断索引是否正确 if (ymodem.buf[YMODEM_PACKET_SEQNO_INDEX] != ymodem.pack_cnt) ymodem_printf(index err, need_cnt=%x, real_cnt=%x \\r , ymodem.pack_cnt, ymodem.buf[YMODEM_PACKET_SEQNO_INDEX]); // 索引不对，发送错误应答，重新接收本包数据 ymodem_send_byte(YMODEM_NAK); else // 索引正确 // 第一包数据 和 文件数据结束之后的第一包数据 是文件信息 if ((ymodem.info_done == 0) || (ymodem.file_done == 1)) // 非空文件名，是第一包数据 if (ymodem.buf[YMODEM_PACKET_HEADER_LEN] != 0x00) // 解析文件名： uint8_t file_name_len = 0; for (uint8_t i = YMODEM_PACKET_HEADER_LEN; i YMODEM_FILE_NAME_LENGTH; i++) if (ymodem.buf[i] == 0x00) file_name_len = i - 3; memcpy(ymodem.file_name, (ymodem.buf[3]), file_name_len); ymodem.file_name[file_name_len] = \\0; ymodem_printf(file name = %s \\r , ymodem.file_name); break; // 解析文件字节数： for (uint8_t i = YMODEM_PACKET_HEADER_LEN + file_name_len + 1; i YMODEM_PACKET_HEADER_LEN + file_name_len + 1 + YMODEM_FILE_SIZE_LENGTH; i++) // 遇到分隔符、非法字符 if ((ymodem.buf[i] == 0x20) || (ymodem.buf[i] 0) || (ymodem.buf[i] 9)) // 打印一下信息 ymodem_printf(file size = %d byte.\\r , ymodem.file_size); break; else ymodem.file_size = ymodem.file_size * 10 + (ymodem.buf[i] - 0); // 解析成功 ymodem.info_done = 1; ymodem.pack_cnt = 1; // 发送应答开始接收数据 ymodem_send_byte(YMODEM_ACK); ymodem_send_byte(YMODEM_C); // 空文件名是最后一帧数据 else ymodem_send_byte(YMODEM_ACK); // TODO:延时半秒 ymodem_send_byte(YMODEM_ACK); ymodem.null_done = 1; break; // 文件数据 else // 将数据写入到flash ymodem_flash_write(ymodem.app_addr + ymodem.flash_cnt, (ymodem.buf[YMODEM_PACKET_HEADER_LEN]), packet_length); // 记录已经写入到flash中的字节数 ymodem.flash_cnt = ymodem.flash_cnt + packet_length; // 记录下一包应该收到的索引 if (ymodem.pack_cnt == 0xFF) ymodem.pack_cnt = 0; else ymodem.pack_cnt++; // 发送应答，接收下一帧数据 ymodem_send_byte(YMODEM_ACK); break; // 主机要求取消传输 case 1: ymodem_send_byte(YMODEM_CA); ymodem_send_byte(YMODEM_CA); return 1; // 接收失败（校验失败、接收超时、命令不对） default: // 如果是在等待文件信息 if (ymodem.info_done == 0) // 重新发送C ymodem_send_byte(YMODEM_C); // 如果是接收数据过程出错 if ((ymodem.info_done == 1) (ymodem.file_done == 0)) // 发送错误应答，重新接收数据 ymodem_send_byte(YMODEM_NAK); // 如果是等待空文件信息出错 if (ymodem.file_done == 1) // 重新发送C ymodem_send_byte(YMODEM_C); break; // 判断接收流程是否全部结束 if (ymodem.null_done == 1) ymodem_printf(recv over, need size=%d, real size=%d \\r , ymodem.file_size, ymodem.flash_cnt); return 0; 其中： 头文件可以完全不用动； 源文件用户适配部分需要根据不同的单片机和接口进行修改。 使用案例 void main() // init while(1) // 如果需要进行OTA if(need_updata) // 接收app程序 ymodem_receive(); // 跳转到app区域 jump_to_app();","tags":["Uart","Ymodem"],"categories":["通信协议"]},{"title":"Modbus","path":"/2023/01/01/07. 通信协议/modbus/","content":"1. 简介特点 免费 简单 接口：Modbus协议只是一种规约，属于应用层的协议，因此不仅可以应用在串口（485232422），也可以在以太网、光纤、蓝牙、无线上传输。 2. Modbus 思路2.1 存储区分类我们想要制定一个协议，我们首先要明确，协议的目的是为了数据传输。 把数据分类： 布尔数据（线圈，即只有开断的概念，也就是值只有01） 非布尔数据（寄存器，即各种不同的数据，一般为16位） 这些数据按照输入还是输出，还可以继续分类。 输入意味着该存储区里的值必须由外部设备接入，是只读的。 输出表示输出结果给外部设备，是可读可写的。 因此，进一步分类之后得到： 序号 读写 存储类型 存储区名称 1 只读 线圈 输入线圈 2 读写 线圈 输出线圈 3 只读 寄存器 输入寄存器 4 读写 寄存器 保持寄存器 2.2 存储区代号Modbus 用数字给这些存储区取了一个代号，就有了下面的存储区代号的规定： 序号 读写 存储类型 存储区名称 存储区代号 1 只读 线圈 输入线圈 1区 2 读写 线圈 输出线圈 0区 3 只读 寄存器 输入寄存器 3区 4 读写 寄存器 保持寄存器 4区 2.3 存储区范围Modbus 规定，每个存储区的最大范围是 65536。那么，访问一个数据，我们需要知道它在哪个存储区、它在这个存储区的索引是什么。 这里我们按照绝对地址、相对地址的概念来理解： 我们把： 存储区编号 + 地址索引 理解为绝对地址。 后面的地址索引 理解为相对地址。 那么对于 Modbus：绝对地址 区号 + 相对地址 存储区名称 存储区代号 绝对地址范围 相对地址范围 输入线圈 1区 100001 - 165536 0 - 65535 输出线圈 0区 000001 - 065536 0 - 65535 输入寄存器 3区 300001 - 365536 0 - 65535 保持寄存器 4区 400001 - 465535 0 - 65535 以保持型寄存器为例，可以看到，第一个绝对地址是400001，这个地方不是400000，这个是由 Modbus 规约决定的，其它存储区也是类似。 但在实际使用中，我们一般用不了这么多地址，一般情况下，10000 以内就已经足够我们使用了，因此，为了方便起见，我们有一种短的地址模型，如下： 存储区名称 存储区代号 绝对地址范围 相对地址范围 输入线圈 1区 10001 - 19999 0 - 9998 输出线圈 0区 00001 - 09999 0 - 9998 输入寄存器 3区 30001 - 39999 0 - 9998 保持寄存器 4区 40001 - 49999 0 - 9998 2.4 功能码我们的初衷是，传输数据，即读取或者写入数据。 我们根据数据的类型已经分好区域了，只需对其读写就好了。那么，我们怎么表示我们是要读还是写呢？这个动作就是功能码。好了，继续分类。 数据（存储区）有四种，读写这个动作是两种，但是有两种数据是只读的，没有写动作。因此一共有六种行为。 行为序号 行为 1 读取输入线圈 2 读取输出线圈 3 读取输入寄存器 4 读取保持寄存器 5 写入输出线圈 6 写入保持寄存器 但是，Modbus 规约将写入输出线圈和写入保持寄存器这 2 种行为，又进一步做了细分，包括写入单个和写入多个，因此原来的 6 种行为就变成了 8 种行为，同时给每种行为设置一个代号，就形成了下表所示的功能码列表： 功能码 功能说明 0x01 读取输出线圈 0x02 读取输入线圈 0x03 读取保持寄存器 0x04 读取输入寄存器 0x05 写入单个线圈 0x06 写入单个寄存器 0x0F 写入多个线圈 0x10 写入多个寄存器 Modbus 规约中的功能码其实不止这 8 个，还有一些功能码是用于诊断或异常码，但是一般很少使用，这 8 种功能码是最主要的核心功能码。 2.5 协议分类Modbus 严格来说，是一个标准化的规约，而不是一个具体协议。我们常说的设备A和设备B之间通过 Modbus 协议来通信，这句话其实是不严谨的。 Modbus 规约上有三种不同的协议： ModbusRtu ModbusAscii ModbusTcp 一般来说，ModbusRtu 和 ModbusAscii 是运行在串口上的协议，ModbusTcp 是运行是以太网上的协议，但是这并非绝对的，我们也可以将 ModbusRtu、ModbusAscii 运行在以太网或光纤上使用，同样的，在串口网络里，我们也可以使用 ModbusTcp 的协议，因为协议只是一种规范，并不限制通信介质。 2.6 报文格式 ModbusRtu 的报文格式如下（经常需要自己实现）： 第一部分：从站地址，占1个字节 第二部分：功能码，占1个字节 第三部分：数据部分，每个数据2字节（高字节在前） 第四部分：校验部分，CRC校验，占2个字节（校验前面的所有数据，结果低字节在前） ModbusAscii 的报文格式如下： 第一部分：开始字符（:） 第二部分：从站地址，占2个字节 第三部分：功能码，占2个字节 第四部分：数据部分，占N个字节 第五部分：校验部分，LRC校验，占2个字节 第六部分：结束字符（CR LF） ModbusTcp 的报文格式如下： 第一部分：事务处理标识符，占2个字节 第二部分：协议标识符，占2个字节 第三部分：长度，占2个字节 第四部分：单元标识符，占1个字节 第五部分：功能码，占1个字节 第六部分：数据部分，占N个字节 3. 协议补充前面 Modbus 协议建立的过程中，没有丝毫提及通信应该用几根线、用什么样的线。 可以看出，跟串口、IIC、SPI、CAN之类的协议不同，这里定义的只是一种消息结构。而不管你是用哪种方式通信的。 3.1 主从模式前面可以看出，数据收发需要一个节点（主节点）主动向另一个节点（从节点）发起请求，然后从节点进行回复。这种数据收发模式叫单播模式。 也可以，主节点向所有从节点发送请求，从节点无需发送应答，只需要执行相应的动作就可以了。这种模式叫广播模式。 一个网络中可以有一个主节点、一个或多个从节点。 3.2 ADU、PDU每次 Modbus 发送的报文为：地址域 + 功能码 + 数据 + 差错校验 地址域：要发送给的从节点（0 广播地址，1-247 从节点地址，248-255 保留地址）。 功能码：要执行的动作。前面表格里说过了。 数据域：要发送的数据。 校验码：校验。 其中： ADU（应用数据单元） 地址域 + 功能码 + 数据 + 差错校验 PDU（协议数据单元） 功能码 + 数据 另外，ADU 的最大长度为：256 字节。 而 PDU 的最大长度要看使用的通信方式。 如果使用RS232、RS485通信 ADU 地址域（1字节）+ PDU（）+ CRC（2字节） 256字节。 即 PDU 最大为 253 字节。 如果使用以太网口通信，其是再TCPIP协议中又封装了一层 modbus 协议。 ADU MBAP（7字节）+ PDU（） 256字节。 即 PDU 最大为 249 字节。 4. 手写代码实现实际使用中，在linux编程中，如果使用modbus，基本上都可以直接使用现成的库。 而如果使用单片机进行通信，一般用的最多的是ModbusRtu，因为串口（485）是比较经济的通信方式，同时为了方便，大多都是对寄存器数据的操作。 这里需要自己可以实现此种通信方式，主要需要实现以下接口（从发送和接收方都需要会实现）： 写单个寄存器 读多个寄存器 读寄存器命令： 字节0：从机地址 字节1：命令，读为0x04 字节2-3：要读的寄存器地址，高字节在前 字节4-5：要读的寄存器个数 字节6-7：CRC校验码（低字节在前） 响应读寄存器命令： 字节0：从机地址 字节1：功能码，还是04（原样回复） 字节2：数据长度（一个寄存器16位，则长度为 寄存器个数*2） 字节3-4：寄存器1数据 字节5-6：寄存器2数据 … 最后两个字节数据：CRC 写寄存器命令： 字节0：从机地址 字节1：命令，写为0x06 字节2-3：要写的寄存器地址，高字节在前 字节4-5：要写的寄存器值，高字节在前 字节6-7：CRC校验码（低字节在前） 响写寄存器命令： 字节0：从机地址 字节1：命令，写为0x06 字节2-3：写的寄存器地址，高字节在前 字节4-5：写的寄存器值，高字节在前 字节6-7：CRC校验码（低字节在前） 4.1 发送方（读 或 写的一方）#include mlcp.h#include mlcp_def.h // modbus地址定义#include string.h // 内存比较函数#include Tool.h // 日志输出接口#include serial.h // 串口接口// ==================================================== modbus操作接口 ==================================================== //typedef enum _MODBUS_STATUS MODBUS_OK = 0x01, MODBUS_SEND_FAILED = 0x01, MODBUS_RECV_TIMEOUT = 0x02, MODBUS_ADDR_ERROR = 0x03, MODBUS_CRC_ERROR = 0x04, MODBUS_STATUS;// 计算modbus校验码static uint16_t modbus_crc16(uint8_t *data, uint8_t len) uint16_t crc = 0xffff; for (uint8_t num = 0; num len; num++) crc = (*data++) ^ crc; for (uint8_t x = 0; x 8; x++) if (crc 0x0001) crc = crc 1; crc = crc ^ 0xA001; else crc = crc 1; return crc;// 读寄存器操作// reg_addr: 要读的寄存器地址。reg_num: 要读的寄存器数量。reg_data: 读到的寄存器值static MODBUS_STATUS modbus_read_reg(uint16_t reg_addr, uint16_t reg_num, uint16_t *reg_data) // 先清空缓冲区中的数据 uint8_t temp_tx_buf[1]; while (SerialReceive(MLCP_UART_PORT, temp_tx_buf, 1) 0) // 发送读寄存器命令 uint8_t tx_message[8] = 0; tx_message[0] = DEFAULT_MLCP_ADDR; // 下位机地址 tx_message[1] = 0x03; // 读数据 tx_message[2] = (reg_addr 8) 0xFF; // 寄存器地址（高位） tx_message[3] = (reg_addr 0) 0xFF; // 寄存器地址（低位） tx_message[4] = (reg_num 8) 0xFF; // 寄存器个数（高位） tx_message[5] = (reg_num 0) 0xFF; // 寄存器个数（低位） uint16_t crc16_tx = modbus_crc16(tx_message, 6); tx_message[6] = (crc16_tx 0) 0xFF; // CRC校验码（低位） tx_message[7] = (crc16_tx 8) 0xFF; // CRC校验码（高位） // 发送数据 if (0 != SerialSend(MLCP_UART_PORT, tx_message, 8)) return MODBUS_SEND_FAILED; // 等待返回数据（返回的数据会存到缓冲区中） task_delay(30); // 从缓冲区中接收返回的数据，数据长度 = 设备地址1 + 功能码1 + 数据长度1 + 返回数据reg_num*2 + CRC校验2 = 5 + reg_num * 2 uint16_t recv_data_len = 5 + reg_num * 2; uint8_t rx_message[100] = 0; // 串口缓冲区也就这么大，最大支持47个寄存器 if (recv_data_len != SerialReceive(MLCP_UART_PORT, rx_message, recv_data_len)) return MODBUS_RECV_TIMEOUT; if ((rx_message[0] == DEFAULT_MLCP_ADDR) // 从机地址正确 (rx_message[1] == 0x03) // 功能码正确 (rx_message[2] == (reg_num * 2))) // 数据长度正确 // 计算CRC uint16_t crc_rx = modbus_crc16(rx_message, reg_num * 2 + 3); uint8_t crc_rx_h = crc_rx 8; uint8_t crc_rx_l = crc_rx 0xFF; if ((rx_message[reg_num * 2 + 3] == crc_rx_l) (rx_message[reg_num * 2 + 3 + 1] == crc_rx_h)) // 数据，高字节在前 uint8_t i = 0; while (i reg_num) reg_data[i] = ((rx_message[3 + i * 2] 8) | (rx_message[3 + i * 2 + 1])); i++; return MODBUS_OK; else return MODBUS_CRC_ERROR; return MODBUS_ADDR_ERROR;// 写寄存器操作// reg_addr: 要写的寄存器地址。reg_data: 要写入到寄存器的值static MODBUS_STATUS modbus_write_reg(uint16_t reg_addr, uint16_t reg_data) // 先清空缓冲区中的数据 uint8_t temp_tx_buf[1]; while (SerialReceive(MLCP_UART_PORT, temp_tx_buf, 1) 0) // 发送写寄存器命令 uint8_t tx_message[8] = 0; tx_message[0] = DEFAULT_MLCP_ADDR; // 下位机地址 tx_message[1] = 0x06; // 写数据 tx_message[2] = (reg_addr 8) 0xFF; // 寄存器地址（高位） tx_message[3] = (reg_addr 0) 0xFF; // 寄存器地址（低位） tx_message[4] = (reg_data 8) 0xFF; // 待写入寄存器的值（高位） tx_message[5] = (reg_data 0) 0xFF; // 待写入寄存器的值（低位） uint16_t crc16_tx = modbus_crc16(tx_message, 6); tx_message[6] = (crc16_tx 0) 0xFF; // CRC校验码（低位） tx_message[7] = (crc16_tx 8) 0xFF; // CRC校验码（高位） // 发送数据 if (0 != SerialSend(MLCP_UART_PORT, tx_message, 8)) return MODBUS_SEND_FAILED; // 等待返回数据（返回的数据会存到缓冲区中） task_delay(30); // 从缓冲区中接收返回的数据，数据长度 = 设备地址1 + 功能码1 + 数据长度1 + 返回数据reg_num*2 + CRC校验2 = 5 + reg_num * 2 uint8_t rx_message[10] = 0; if (8 != SerialReceive(MLCP_UART_PORT, rx_message, 8)) return MODBUS_RECV_TIMEOUT; // 写数据时，发送的数据和返回的数据相同 if (0 == memcmp(tx_message, rx_message, 8)) return MODBUS_OK; return MODBUS_ADDR_ERROR;// ==================================================== app应用读取接口 ==================================================== //mlcp_data_t mlcp;static void mlcp_read_version(void) MODBUS_STATUS status; uint16_t table[1]; status = modbus_read_reg(SOFTWARE_VERSION_REGISTER, 1, table); if (MODBUS_OK == status) mlcp.version = table[0]; Log_DebugOut([MLCP] mlcp version is %d \\r , mlcp.version); else Log_DebugOut([MLCP] mlcp read version failed, status = %d \\r , status); mlcp.err_count++; static void mlcp_read_status(void) MODBUS_STATUS status; uint16_t table[33]; status = modbus_read_reg(WORKING_MODE_REGISTER, 33, table); if (MODBUS_OK == status) mlcp.now_work_mode = (MLCP_MODE)table[0]; // 当前工作状态 mlcp.error_info = table[1]; // 故障信息 mlcp.warnning_info = table[2]; // 预警信息 mlcp.temp_in = (float)table[3] / 10 - 40; // 进液温度 mlcp.temp_out = (float)table[4] / 10 - 40; // 出液温度 mlcp.temp_env = (float)table[6] / 10 - 40; // 环境温度 mlcp.press_in = table[20]; // 进液压力 mlcp.press_out = table[21]; // 出液压力 mlcp.fan1_speed = table[23]; // 风机1转速 mlcp.fan2_speed = table[24]; // 风机2转速 mlcp.fan3_speed = table[25]; // 风机3转速 mlcp.fan4_speed = table[26]; // 风机4转速 mlcp.fan5_speed = table[27]; // 风机5转速 mlcp.fan6_speed = table[28]; // 风机6转速 mlcp.fan7_speed = table[29]; // 风机7转速 mlcp.io_input_status = table[32]; // IO输入状态 mlcp.err_count = 0; else Log_DebugOut([MLCP] mlcp read status failed, status = %d \\r , status); mlcp.err_count++; static void mlcp_write_mode(void) // 如果目标模式和实际模式不一致 if (mlcp.now_work_mode != mlcp.need_work_mode) MLCP_MODE set_mode = SHUTDOWN_MODE; // 如果当前没有故障 if (mlcp.error_info == 0) set_mode = (uint16_t)(mlcp.need_work_mode); // 写 if (MODBUS_OK != modbus_write_reg(WORK_MODE_REGISTER, set_mode)) mlcp.err_count++; // 风机转速 if (MODBUS_OK != modbus_write_reg(FAND_SPEED_CTRL_REGISTER, mlcp.need_fan_speed)) mlcp.err_count++; static void mlcp_offline_recovery() // 大概断开十几秒 if (mlcp.err_count = 50) // 防止溢出 mlcp.err_count = 50; SerialClose(MLCP_UART_PORT); task_delay(5); SerialOpen(MLCP_UART_PORT, 115200); mlcp.now_work_mode = ERROR_MODE; // modbus读取任务void mlcp_task_func(void *arg) // 打开串口 while (1) if (0 == SerialOpen(MLCP_UART_PORT, 115200)) Log_DebugOut([MLCP] mlcp open uart%d success! \\r , MLCP_UART_PORT); break; else Log_DebugOut([MLCP] mlcp open uart%d failed! \\r , MLCP_UART_PORT); task_delay(1000); // 获取版本信息 mlcp_read_version(); for (;;) task_delay(200); mlcp_read_status(); task_delay(200); mlcp_write_mode(); task_delay(200); mlcp_offline_recovery(); void mlcp_init(void) memset(mlcp, 0, sizeof(mlcp)); struct task_struct *mlcp_task = NULL; mlcp_task = task_create(mlcp_task_func, mlcp_task, (uint16_t)4096, NULL, (unsigned long)5); if (mlcp_task != NULL) Log_DebugOut([MLCP] Creat mlcp_task success! \\r ); else Log_DebugOut([MLCP] Creat mlcp_task faild %08x ! \\r , (uint32_t)mlcp_task); // 设置当前工作模式uint8_t mlcp_set_work_status(MLCP_MODE mode) if ((mode == SHUTDOWN_MODE) || (mode == WORKING_MODE)) mlcp.need_work_mode = mode; return 0; return 1;// 获取当前工作模式MLCP_MODE mlcp_get_work_status(void) return mlcp.now_work_mode;// 设置风机转速uint8_t mlcp_set_fan_speed(uint8_t speed) if (speed = 100) mlcp.need_fan_speed = speed; return 0; return 1; 4.2 接收方（创建寄存器被读或写的一方）/* * upper_modbus_task.c * * Created on: 2024年9月9日 * Author: ZhangJinhao *//* 功能码 */#define READ_REGISTER 0x03 // 读寄存器#define WRITE_REGISTER 0x06 // 读寄存器#define ERROR_BACK 0x80 // 读寄存器(0x80+异常码)// 计算modbus校验码static uint16_t modbus_crc16(uint8_t *data, uint8_t len)\tuint16_t crc = 0xffff;\tfor (uint8_t num = 0; num len; num++) crc = (*data++) ^ crc; // 把数据与16位的CRC寄存器的低8位相异或，结果存放于CRC寄存器 for (uint8_t x = 0; x 8; x++) // 判断最低位为：“1” if (crc 0x0001) crc = crc 1; // 先右移 crc = crc ^ 0xA001; // 再与0xA001异或 else // 判断最低位为：“0” crc = crc 1; return crc;// crc校验,0成功，1失败static uint8_t modbus_crc_check(uint8_t *data)\tuint16_t result = 0;\tuint8_t crc_h, crc_l;\tresult = modbus_crc16(data, 6);\tcrc_h = (uint8_t)(result 8);\tcrc_l = (uint8_t)(result 0xFF);\tif (crc_l == data[6] crc_h == data[7]) return 0; else return 1;\t// 上位机读数据，板卡回复void upper_modbus_read_register(upper_uart_ptr dev, uint8_t *data)\tuint16_t register_addr = 0;\tuint16_t register_len = 0;\tuint8_t respond_data[400] = 0;\t// 存储回应回去的数据\t// 解析命令\tregister_addr = (data[2] 8) | data[3];\t// 目标寄存器地址\tregister_len = (data[4] 8) | data[5];\t// 想要读取的寄存器个数\t// 拼接回应数据\trespond_data[0] = data[0]; //从机ID\trespond_data[1] = data[1]; //功能码\trespond_data[2] = (uint8_t)(register_len * 2); // 获取总的字节数\tfor(uint16_t i = 0; i = register_len; i++) // 读取的寄存器的值 uint16_t temp_addr = register_addr + i; uint16_t temp_data = 0; uint8_t data_h = 0, data_l = 0; // 根据地址，填需要回复的数据 switch(temp_addr) /* part 1 */ case MODUBLE_ADDR_REGISTER: // 从机地址信息 temp_data = upper_uart.board_addr; break; case SOFTWARE_VERSION_REGISTER: // 软件版本信息 temp_data = SOFT_WARE_VERSION; break; default: temp_data = 0; break; // 计算高低位 data_h = temp_data 8; data_l = temp_data 0x00FF; // 赋值 respond_data[3 + 2 * i] = data_h; respond_data[3 + 2 * i + 1] = data_l; // 计算crc\tuint16_t crc_temp = modbus_crc16(respond_data, respond_data[2] + 3);\trespond_data[respond_data[2] + 3] = crc_temp 0xFF;\trespond_data[respond_data[2] + 3 + 1] = crc_temp 8;\t// 发送回应\tupper_uart_send(dev, respond_data, respond_data[2] + 3 + 2);// 上位机发送写命令，板卡处理void upper_modbus_write_register(upper_uart_ptr dev, uint8_t *data)\tuint16_t register_addr = 0;\tuint16_t register_data = 0;\t// 回应上位机的写命令（原样发回去）\tupper_uart_send(dev, data, 8);\t// 解析命令\tregister_addr = (data[2] 8) | data[3];\t// 目标寄存器地址\tregister_data = (data[4] 8) | data[5];\t// 待写入寄存器的值 // 根据地址执行动作\tif(register_addr == WORK_MODE_REGISTER) else if(register_addr == MOTOR_SPEED_CTRL_REGISTER) /* * */void upper_modbus_task(void)\tuint8_t temp_recv_data[8] = 0;\tmemset(temp_recv_data, 0, 8);\t// modbus数据格式,最少八个字节\t// 设备地址(1)、功能码(1)、寄存器地址(2,高字节在前)、寄存器个数(2,高字节在前)、CRC校验(2,低字节在前)\t// modbus返回数据格式\t// 设备地址(1)、功能码(1)、返回数据长度(1)、返回数据(N)、CRC校验(2,低字节在前)\t// 如果当前缓冲区数据够一帧modbus\tif(upper_uart_buf_len(upper_uart) = 8) // 获取一个字节数据 if(upper_uart_recv(upper_uart, (temp_recv_data[0])) == 1) // 判断是否是modbus数据头(本设备ID或广播ID) if((temp_recv_data[0] == upper_uart.board_addr) || (temp_recv_data[0] == 0xFF)) // uart_port_printf(debug_uart, temp_recv_data[0]=%d, addr=%d \\r , temp_recv_data[0], upper_uart.board_addr); // 获取紧邻的7个字节 for(uint8_t i = 1; i 8; i++) upper_uart_recv(upper_uart, (temp_recv_data[i])); // CRC校验 if(modbus_crc_check(temp_recv_data) == 0) // 上位机要读数据，这里需要返回 if(temp_recv_data[1] == 0x03) upper_modbus_read_register(upper_uart, temp_recv_data); // 上位机要写数据，这里需要处理 else if(temp_recv_data[1] == 0x06) upper_modbus_write_register(upper_uart, temp_recv_data); else // 清空缓冲区的数据 防止循环报错 // return; 5. 测试软件模拟 Modbus 协议有电脑即可，无需任何硬件。用于查看协议报文格式。 Modbus Slave Modbus Poll Configure Virtual Serial Port Driver 三个软件都是傻瓜式操作，安装即可。 在弹出激活码的时候，把压缩包中的激活码填进去即可。 6. 测试步骤6.1 添加虚拟串口打开 VSPD 软件，添加虚拟串口。 添加完成之后，就可以看到添加的串口了，可以认为这是两个连接在一起的串口。 6.2 设置主机打开 ModBus Poll 软件，点击Setup - Read/Write Definition， 设置要通讯的参数，然后点击OK。 然后点击Connection - Connect 连接上之后，左上角会显示连接超时，正常，毕竟从机还没连接呢。 6.3 设置从机打开 ModBus Slave 软件，点击Setup - Slave Definition， 设置要通讯的参数，注意从机地址要和刚刚主机设置的一样，然后点击OK。 然后点击Connection - Connect 6.4 传输数据双击从机寄存器的格子，往里面填入任意值，可以看到主机这边会读取到。 主机上面的 Tx2271，是发送了2271次；Err241，是失败了241次。 6.5 RTU报文解析在主机端，点击Display communication traffic可看到主机发送出去和接收到的回复报文。 发送报文：Tx：01 03 00 00 00 04 44 09 01：从机地址 03：功能码 00 00：寄存器地址 00 04：读取数据个数，4个 44 09：CRC校验 接收报文：Rx：01 03 08 00 01 00 08 00 10 00 14 65 1C 01：从机地址 03：功能码 08：返回的字节数（16进制），8个字节。 00 01：第一个数据，1 00 08：第二个数据，8 00 10：第三个数据，16 00 14：第四个数据，20 65 1C：CRC校验 可以看到，就是 ModbusRtu 的报文格式（在第二步中，我们设置的就是 RTU ）。 6.6 TCP报文解析如果我们不用串口，而使用TCP进行连接。 在主机端，连接时选择如下： 在从机端，连接时选择如下： 此时，数据通讯的报文如下： 发送报文：Tx：04 44 00 00 00 06 01 03 9C 4A 00 04 04 44：事务标识符，可以解释为报文的序列号，由于我们测试使用的Modbus Poll客户端是一直发送数据，所以每发送一次数据标识符就加一。服务器接收时会把这个数据原封返回。 00 00：Modbus TCP协议 00 06：后面有 6 字节长度的数据 01：单元标识符，相当于设备的地址。01 03：功能码 9C 4A：寄存器地址，从这里开始读数据 00 04：读取数据个数，4个 接收报文：Rx：04 44 00 00 00 0B 01 03 08 00 01 00 08 00 10 00 14 04 44：事务标识符，可以解释为报文的序列号，由于我们测试使用的Modbus Poll客户端是一直发送数据，所以每发送一次数据标识符就加一。服务器接收时会把这个数据原封返回。 00 00：Modbus TCP协议 00 0B：后面有 11 字节长度的数据 01：单元标识符，相当于设备的地址。01 03：功能码 08：返回的字节数（16进制），8个字节 00 01：第一个数据，1 00 08：第二个数据，8 00 10：第三个数据，16 00 14：第四个数据，20 MBAP（报文头） 事务标识符 + 协议表示 + 长度 + 单元表示符 PDU（帧结构） 功能码 + 数据 补充，如果读的功能码为01，即读线圈。 请求：00 01 00 00 00 06 01 01 00 02 00 04（客户端） 00 01：事务标识符 00 00：Modbus TCP协议 00 06：后面有00 06个字节数据 01：单元标识符 01：功能码（读线圈） 00 02：开始读的数据的地址。从00 02开始读数据。 00 04：读00 04个数据。 回应：00 01 00 00 00 04 01 01 01 0E（服务器） 00 01：事务标识符 00 00：Modbus TCP协议 00 04：后面有00 04个字节数据 01：单元标识符 01：功能码 01：后面有01个字节的数据 0E：表示所读地址的线圈全是2的位置是0，其余是1。说明：线圈是只有00和01两种格式，所以图中从2的位置开始读到的4位数据是：1110（二进制），转化为十六进制就是0E。","tags":["Uart","Modbus"],"categories":["通信协议"]},{"title":"rtthread_nano移植","path":"/2020/10/01/03. RTOS/rtthread_nano/","content":"使用的开发板：RTT正点原子的潘多拉loT Board开发板。主控：STM32L475VET6 软件：CubeMX 6.7.0、Keil 5.38、Nano 3.1.5 第一部分：工程版本及移植移植的方式有好多种（任选一种） 基于 Keil MDK 的移植；（最常用的工具） 基于 CubeMX 的移植；（最常用的工具） 基于官方软件 RT-Thread Studio；（自动创建工程，比较方便） 1. 使用 Keil MDK 移植一共需要两步： 创建一份裸机代码； 在 Keil 软件中安装 RT-Thread Nano Pack； 在源工程中添加 RT-Thread Nano 源代码； 适配工作，主要从 中断、时钟、内存这几个方面进行适配，实现移植； 添加LED闪烁例程进行验证； 裁剪内核，通过配置文件 rtconfig.h 实现对系统的裁剪。 裸机代码获取： 这里可以直接使用 CubeMX 生成一份，配置上时钟、调试接口、LED的IO口之后，直接点击生成即可。下面的案例就是使用这种方式生成的。 也可以按照正点原子的教程，从固件包里面新建一个。 这两种方法在工程目录上有一点点差距，内容差不多，移植的时候找到对应的地方就可以了。 1.1 Nano Pack 安装RT-Thread Master 的源码可以从 https://github.com/RT-Thread/rt-thread 下载。 Nano就是从里面扣出来的，去掉了一些组件和各种开发板的BSP，保留了OS的核心功能，但足够我们使用。 方式一：手动下载安装RT-Thread 官方将抠出来的 Nano 作为一个Package放在了KEIL网站：http://www.keil.com/dd2/pack/ 打开这条连接，然后拉到下面找到RealThread即可下载。 下载完成之后，直接双击安装即可，路径会自动选择Keil的安装路径。 安装完成之后，在：E:\\Keil5 MDK\\PACK\\RealThread\\RT-Thread\\3.1.5 路径(Keil的安装路径)下，即可看到下载的源码。 方式二：在Keil中安装 打开Keil，点击包安装图标，点击右侧的 Pack，展开 Generic，可以找到 RealThread::RT-Thread； 点击 Action 栏对应的 Install ，就可以在线安装 Nano Pack 了。 另外，如果需要安装其他版本，则需要展开 RealThread::RT-Thread，进行选择。 图中 Remove 代表已经安装了。 1.2 Nano 版本移植在 Manage Rum-Time Environment 里 “Software Component” 栏找到 RTOS，Variant 栏选择 RT-Thread，然后勾选 kernel，点击 “OK” 就添加 RT-Thread 内核到工程了。 然后在左侧工程栏就可以看到相关代码了。 其中的文件包含： Cortex-M 芯片内核移植代码 context_rvds.scpuport.c Kernel 文件 clock.ccomponents.cdevice.cidle.cipc.cirq.ckservice.cmem.cmempool.cobject.cscheduler.cthread.ctimer.c 配置文件 board.crtconfig.h 如果不想使用CMSIS添加源码，也可以直接把下载的源码复制到工程中，对照着上面的文件名添加进去即可。注意可能同一个文件所处的位置略微有些差异，其余的部分都是一样的。 在工程文件夹的 Middlewares 文件夹中创建一个 RT-Thread 文件夹。 MiddlewaresRT-Thread bsp _template board.c rtconfig.h components device（都要保留，后续可能用到） device.c finsh（都要保留，第四章用到） 文件都保留 include（都要保留） libcpu arm cortex-m4 context_rvds.S cpuport.c src（都要保留） 剩下的没提到的都删掉。 然后在 Keil MDK 内添加文件和头文件即可。后续学习内核的时候，这里用的就是这种方式移植的内核（因为与RTT无关的冗余文件少）。 1.3 适配工作1.3.1 中断与异常处理 RT-Thread 会接管异常处理函数 HardFault_Handler() 和悬挂处理函数 PendSV_Handler()，这两个函数已由 RT-Thread 实现，所以需要删除工程里中断服务例程文件中的这两个函数，避免在编译时产生重复定义。如果此时对工程进行编译，没有出现函数重复定义的错误，则不用做修改。 在stm32l4xx_it.c文件中找到上述两个函数，直接注释掉即可（也可以在使用CubeMX生成代码的时候，直接不生成这部分中断代码）。 1.3.2 系统时钟配置 在 board.c 中实现 系统时钟配置（为 MCU、外设提供工作时钟）与 os tick 的配置 （为操作系统提供心跳 节拍）。 在board.c文件中修改如下函数，以完成系统初始化和 OS Tick 的配置。 #include main.hextern void SystemClock_Config(void); // 此函数默认是在main.c中，此处声明一下/* cortex-m 架构使用 SysTick_Handler() */void SysTick_Handler() rt_interrupt_enter(); /* 进入中断时必须调用 */ rt_tick_increase(); /* RT-Thread 系统时钟计数 */ rt_interrupt_leave(); /* 退出中断时必须调用 *//** * This function will initial your board. */void rt_hw_board_init(void) /* * TODO 1: OS Tick Configuration * Enable the hardware timer and call the rt_os_tick_callback function * periodically with the frequency RT_TICK_PER_SECOND. */ /* 1、系统、时钟初始化 */ HAL_Init(); // 初始化 HAL 库 SystemClock_Config(); // 配置系统时钟 SystemCoreClockUpdate(); // 对系统时钟进行更新 /* 2、OS Tick 频率配置，RT_TICK_PER_SECOND = 1000 表示 1ms 触发一次中断 */ SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND); /* Call components board initial (use INIT_BOARD_EXPORT()) */#ifdef RT_USING_COMPONENTS_INIT rt_components_board_init();#endif#if defined(RT_USING_USER_MAIN) defined(RT_USING_HEAP) rt_system_heap_init(rt_heap_begin_get(), rt_heap_end_get());#endif 另外，SysTick_Handler()函数在裸机工程中应该也有，也需要去stm32l4xx_it.c文件中注释掉。 1.3.3 内存堆初始化 系统内存堆的初始化在 board.c 中的 rt_hw_board_init() 函数中完成 内存堆功能是否使用取决于宏 RT_USING_HEAP 是否开启（位于rtconfig.h中） 开启系统 heap 将可以使用动态内存功能，如使用 rt_malloc、rt_free 以及各种系统动态创建对象的 API。 若需要使用系统内存堆功能，则打开 RT_USING_HEAP 宏定义即可，此时内存堆初始化函数 rt_system_heap_init() 将被调用。 如果需要使用动态创建线程等对象，则需要配置。 1.4 LED闪烁在main.c中添加如下代码（注意：LED引脚初始化的代码在源代码中已经配置过了） #include rtthread.h\t// 线程相关int main(void) MX_GPIO_Init(); while (1) HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_9, GPIO_PIN_RESET); rt_thread_mdelay(500); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_9, GPIO_PIN_SET); rt_thread_mdelay(500); 注意 这里使用的延时函数是由RTT提供的，此函数引起系统调度，切换到其他线程运行。 这里的main函数中不再执行初始化动作，RTT系统启动时已经做好了。 至此，将工程编译并下载，即可看到LED闪烁了。 1.5 裁剪内核如果对内核的部分功能用不着，可以对其进行裁剪。 裁剪是通过rtconfig.h文件进行配置的。具体参照[内核裁剪](#5. 内核配置及裁剪) 先保持默认的，能用就行，后面分析阶段再说。 2. 使用 CubeMX 移植其实和使用 Keil MDK 移植的步骤基本一样，只是添加源代码的过程不一样。 在 CubeMX 软件中安装 RT-Thread Nano pack 安装包； 在 CubeMX 配置界面添加 RT-Thread Nano 源码，然后生成工程； 适配工作，主要从 中断、时钟、内存这几个方面进行适配，实现移植； 添加LED闪烁例程进行验证； 裁剪，通过配置文件 rtconfig.h 实现对系统的裁剪。 2.1 Nano Pack 安装 在 CubeMX 中选择完芯片后，点击 Software Packs - Manage Software Packs； 在弹出的界面下方，点击 From Url 后，弹出新的界面； 在弹出的界面下方。点击 New； 在弹出的输入框中输入：https://www.rt-thread.org/download/cube/RealThread.RT-Thread.pdsc 然后点击 Check，等待检查通过后安装即可。 2.2 Nano 版本移植点击 Softwares Packages-Select Components，进入组件配置界面，选择 RealThread， 然后根据需求选择 RT-Thread 组件，然后点击 OK 按钮。 然后在左侧栏对组件和参数进行配置。 RT-Thread Nano 软件包中包含 kernel, shell 和 device 三个部分，仅选择 kernel 表示只使用 RT-Thread 内核，工程中会添加内核代码；选择 kernel 与 shell 表示在使用 RT-Thread Nano 的基础上使用 FinSH Shell 组件，工程中会添加内核代码与 FinSH 组件的代码，FinSH 的移植详见 《在 RT-Thread Nano 上添加控制台与 FinSH》。再选择 device 表示使用 rt-thread 的 device 框架，用户基于此框架编写外设驱动并注册后，就可以使用 device 统一接口操作外设。 剩下的按照需要的功能进行配置即可（记得把串口加上，否则后面board.c中的串口初始化会报错，如果用不到串口可以不用配置，把其中串口初始化报错的部分注释掉就行，后面还会有用）。 2.3 适配工作2.3.1 中断与异常处理RT-Thread 操作系统重定义 HardFault_Handler、PendSV_Handler、SysTick_Handler 中断函数，为了避免重复定义的问题，在生成工程之前，需要在中断配置中，代码生成的选项中，取消选择三个中断函数（对应注释选项是 Hard fault interrupt, Pendable request, Time base :System tick timer），最后点击生成代码，具体操作如下图 所示： 和使用 Keil MDK 不同的是，这里直接不让生成就好了，而不是生成了重新注释。 当然，使用 Keil MDK 创建源工程的时候，也可以不生成，就不用再注释了。 2.3.2 系统时钟配置使用 CubeMX的话，生成的代码其实已经配置好了。 可以对比 1.3.2 小节的代码看一看。 2.3.3 内存堆初始化同 1.3.3 小节。 这里注意，生成的工程目录中有个：RT-Thread 文件夹。里面只有一个rtconfig.h文件。 但是生成的工程中，没有包含这个文件夹，所以会发现根本找不到配置文件。 因此需要在工程中对其进行添加，并添加头文件路径（如果有就算了），如下图所示。 2.4 LED闪烁在main.c文件的while中添加如下代码（注意：LED引脚初始化的代码在源代码中已经配置过了） while (1) HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_9, GPIO_PIN_RESET); rt_thread_mdelay(500); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_9, GPIO_PIN_SET); rt_thread_mdelay(500); main函数中的HAL_Init()、SystemClock_Config();在我们配置系统时钟（2.3.2小节）时已经初始化过了，因此在main函数中其实不用初始化了，可以选择注释掉，但是每次生成工程都还要重新注释。 注意 这里使用的延时函数是由RTT提供的，此函数引起系统调度，切换到其他线程运行。 这里的main函数中不再执行初始化动作，RTT系统启动时已经做好了。 至此，将工程编译并下载，即可看到LED闪烁了。 2.5 裁剪内核如果对内核的部分功能用不着，可以对其进行裁剪。 裁剪是通过rtconfig.h文件进行配置的。具体参照[内核裁剪](#5. 内核配置及裁剪) 先保持默认的，能用就行，后面分析阶段再说。 3. 使用 RT-Thread Studio 创建直接创建 nano 工程即可。 4. 移植 FinSH这里移植 FinSH 主要有两种目的。 基础功能：实现打印，用来向控制台对接的终端输出打印信息。 移植 FinSH 组件：命令输入，用以在控制台输入命令调试系统。 如果只需要第一个功能，则只需要实现两个函数，串口初始化和系统输出函数，即可完成 UART 控制台打印功能。 如果还需要第二个功能，则在上述基础上还需要添加 FinSH 组件源码，并再对接一个系统输入函数即可实现。 4.1 打印功能如果使用的是 CubeMX 移植的代码，其实已经在board.c中默认配置好了（2.2小节的最后一段话有提到），如下图所示。 只需要确认这里使用的串口是不是自己实际对应的串口即可。 而如果使用的是 Keil 配置的 Nano，则如下图所示给预留了位置。 把上面的抄过来就好了 #ifdef RT_USING_CONSOLEstatic UART_HandleTypeDef UartHandle;static int uart_init(void) /* TODO: Please modify the UART port number according to your needs */ UartHandle.Instance = USART1; UartHandle.Init.BaudRate = 115200; UartHandle.Init.WordLength = UART_WORDLENGTH_8B; UartHandle.Init.StopBits = UART_STOPBITS_1; UartHandle.Init.Parity = UART_PARITY_NONE; UartHandle.Init.Mode = UART_MODE_TX_RX; UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE; UartHandle.Init.OverSampling = UART_OVERSAMPLING_16; if (HAL_UART_Init(UartHandle) != HAL_OK) while (1); return 0;INIT_BOARD_EXPORT(uart_init);void rt_hw_console_output(const char *str) rt_size_t i = 0, size = 0; char a = \\r; __HAL_UNLOCK(UartHandle); size = rt_strlen(str); for (i = 0; i size; i++) if (*(str + i) == ) HAL_UART_Transmit(UartHandle, (uint8_t *)a, 1, 1); HAL_UART_Transmit(UartHandle, (uint8_t *)(str + i), 1, 1); #endif 初始化函数uart_init()的执行，是利用的INIT_BOARD_EXPORT(uart_init);语句。 可以查看官网对自动初始化机制的介绍。 然后，在main函数中添加使用到打印函数rt_kprintf()的语句。 // 这里放到了 mian 函数中的 while 之前rt_uint32_t count = 0;for (count = 0; count 10 ; count++) rt_kprintf(count: %d , count); rt_thread_mdelay(500); 编译并下载至开发板，打开串口调试工具并复位开发板，即可看到串口输出。 4.2 移植 FinSH 组件如果需要移植 FinSH 组件，在完成打印功能之后，还需要： 在工程中添加 FinSH 源码。 实现函数对接。 添加 FinSH 源码的方式和 添加 Nano 的方式一样，只需要把 shell 也勾选上即可。 如果使用 CubeMX 添加 FinSH 源码，重新生成工程后，会在工程目录多出如下几个文件。 然后，在rtconfig.h中打开**#include “finsh_config.h”**。 注意：在finsh_port.c文件中，#error Please uncomment the line #include “finsh_config.h” in the rtconfig.h 这一行需要注释掉。 而在board.c中可以看到，相关函数已经默认写好了。 但是，这里的 DR 会报错，因为有些芯片这个寄存器的名字为DR，有的为RDR。这里将 DR 改为 RDR 即可。 而如果使用的是 Keil MDK 添加的源码。则会在工程目录多出几个文件。 同样的，添加之后，需要在rtconfig.h文件中打开**#include “finsh_config.h”**。 然后finsh_port.c文件中可以看到上面的接口，也是一样的，用这种方式的话，把上面的抄过来就好了。 这个是 RT-Thread 官网给的示例，直接抄上面的也行 #ifdef RT_USING_FINSHchar rt_hw_console_getchar(void) int ch = -1; if (__HAL_UART_GET_FLAG(UartHandle, UART_FLAG_RXNE) != RESET) ch = UartHandle.Instance-RDR 0xff; else if(__HAL_UART_GET_FLAG(UartHandle, UART_FLAG_ORE) != RESET) __HAL_UART_CLEAR_OREFLAG(UartHandle); rt_thread_mdelay(10); return ch;#endif 可以发现，其实两种方法做的事情是一样的，最后除了rt_hw_console_getchar函数的位置不同，其他的基本都一样。 然后就可以测试了。使用串口助手。 不勾选发送新行，输入h，点击发送 不勾选发送新行，输入e，点击发送 不勾选发送新行，输入l，点击发送 不勾选发送新行，输入p，点击发送 什么也不输，勾选发送新行，点击发送。 显然，这种查询的方式很沙雕。 4.3 更改中断方式这种查询的方式显然很不对，因此进一步将其更改为中断方式。 官网有所有需要添加的代码，按照自己的习惯放到某个位置就好。 /* 第一部分：ringbuffer 实现部分 */#include rtthread.h#include string.h#define rt_ringbuffer_space_len(rb) ((rb)-buffer_size - rt_ringbuffer_data_len(rb))struct rt_ringbuffer rt_uint8_t *buffer_ptr; rt_uint16_t read_mirror : 1; rt_uint16_t read_index : 15; rt_uint16_t write_mirror : 1; rt_uint16_t write_index : 15; rt_int16_t buffer_size;;enum rt_ringbuffer_state RT_RINGBUFFER_EMPTY, RT_RINGBUFFER_FULL, /* half full is neither full nor empty */ RT_RINGBUFFER_HALFFULL,;rt_inline enum rt_ringbuffer_state rt_ringbuffer_status(struct rt_ringbuffer *rb) if (rb-read_index == rb-write_index) if (rb-read_mirror == rb-write_mirror) return RT_RINGBUFFER_EMPTY; else return RT_RINGBUFFER_FULL; return RT_RINGBUFFER_HALFFULL;/** * get the size of data in rb */rt_size_t rt_ringbuffer_data_len(struct rt_ringbuffer *rb) switch (rt_ringbuffer_status(rb)) case RT_RINGBUFFER_EMPTY: return 0; case RT_RINGBUFFER_FULL: return rb-buffer_size; case RT_RINGBUFFER_HALFFULL: default: if (rb-write_index rb-read_index) return rb-write_index - rb-read_index; else return rb-buffer_size - (rb-read_index - rb-write_index); ;void rt_ringbuffer_init(struct rt_ringbuffer *rb, rt_uint8_t *pool, rt_int16_t size) RT_ASSERT(rb != RT_NULL); RT_ASSERT(size 0); /* initialize read and write index */ rb-read_mirror = rb-read_index = 0; rb-write_mirror = rb-write_index = 0; /* set buffer pool and size */ rb-buffer_ptr = pool; rb-buffer_size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);/** * put a character into ring buffer */rt_size_t rt_ringbuffer_putchar(struct rt_ringbuffer *rb, const rt_uint8_t ch) RT_ASSERT(rb != RT_NULL); /* whether has enough space */ if (!rt_ringbuffer_space_len(rb)) return 0; rb-buffer_ptr[rb-write_index] = ch; /* flip mirror */ if (rb-write_index == rb-buffer_size-1) rb-write_mirror = ~rb-write_mirror; rb-write_index = 0; else rb-write_index++; return 1;/** * get a character from a ringbuffer */rt_size_t rt_ringbuffer_getchar(struct rt_ringbuffer *rb, rt_uint8_t *ch) RT_ASSERT(rb != RT_NULL); /* ringbuffer is empty */ if (!rt_ringbuffer_data_len(rb)) return 0; /* put character */ *ch = rb-buffer_ptr[rb-read_index]; if (rb-read_index == rb-buffer_size-1) rb-read_mirror = ~rb-read_mirror; rb-read_index = 0; else rb-read_index++; return 1;/* 第二部分：finsh 移植对接部分 */#define UART_RX_BUF_LEN 16rt_uint8_t uart_rx_buf[UART_RX_BUF_LEN] = 0;struct rt_ringbuffer uart_rxcb; /* 定义一个 ringbuffer cb */static UART_HandleTypeDef UartHandle;static struct rt_semaphore shell_rx_sem; /* 定义一个静态信号量 *//* 初始化串口，中断方式 */static int uart_init(void) /* 初始化串口接收 ringbuffer */ rt_ringbuffer_init(uart_rxcb, uart_rx_buf, UART_RX_BUF_LEN); /* 初始化串口接收数据的信号量 */ rt_sem_init((shell_rx_sem), shell_rx, 0, 0); /* 初始化串口参数，如波特率、停止位等等（cubemx生成的） */ UartHandle.Instance = USART1; UartHandle.Init.BaudRate = 115200; UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE; UartHandle.Init.Mode = UART_MODE_TX_RX; UartHandle.Init.OverSampling = UART_OVERSAMPLING_16; UartHandle.Init.WordLength = UART_WORDLENGTH_8B; UartHandle.Init.StopBits = UART_STOPBITS_1; UartHandle.Init.Parity = UART_PARITY_NONE; /* 初始化串口引脚等 */ if (HAL_UART_Init(UartHandle) != HAL_OK) while (1); /* 中断配置 */\tHAL_NVIC_SetPriority(USART1_IRQn, 1, 1); // 设置优先级\tHAL_NVIC_EnableIRQ(USART1_IRQn); // 开启中断\t__HAL_UART_ENABLE_IT(UartHandle, UART_IT_RXNE);\t// 使能中断 return 0;INIT_BOARD_EXPORT(uart_init);/* 移植控制台，实现控制台输出, 对接 rt_hw_console_output */void rt_hw_console_output(const char *str) rt_size_t i = 0, size = 0; char a = \\r; __HAL_UNLOCK(UartHandle); size = rt_strlen(str); for (i = 0; i size; i++) if (*(str + i) == ) HAL_UART_Transmit(UartHandle, (uint8_t *)a, 1, 1); HAL_UART_Transmit(UartHandle, (uint8_t *)(str + i), 1, 1); /* 移植 FinSH，实现命令行交互, 需要添加 FinSH 源码，然后再对接 rt_hw_console_getchar *//* 中断方式 */char rt_hw_console_getchar(void) char ch = 0; /* 从 ringbuffer 中拿出数据 */ while (rt_ringbuffer_getchar(uart_rxcb, (rt_uint8_t *)ch) != 1) rt_sem_take(shell_rx_sem, RT_WAITING_FOREVER); return ch;/* uart 中断 */void USART1_IRQHandler(void) int ch = -1; /* enter interrupt */ rt_interrupt_enter(); // 在中断中一定要调用这对函数，进入中断 if ((__HAL_UART_GET_FLAG((UartHandle), UART_FLAG_RXNE) != RESET) (__HAL_UART_GET_IT_SOURCE((UartHandle), UART_IT_RXNE) != RESET)) while (1) ch = -1; if (__HAL_UART_GET_FLAG((UartHandle), UART_FLAG_RXNE) != RESET) ch = UartHandle.Instance-RDR 0xff; if (ch == -1) break; /* 读取到数据，将数据存入 ringbuffer */ rt_ringbuffer_putchar(uart_rxcb, ch); rt_sem_release(shell_rx_sem); /* leave interrupt */ rt_interrupt_leave(); // 在中断中一定要调用这对函数，离开中断 之后，再次测试时，直接输入 help 并发送即可有同样的效果。 CubeMX 生成的中断处理函数中的回调函数可以屏蔽掉。 5. 内核配置及裁剪rtconfig.c文件内容如下 /* RT-Thread config file */#ifndef __RTTHREAD_CFG_H__#define __RTTHREAD_CFG_H__/* ********************** 基础部分 *************************//* 设置系统最大优先级，可设置范围 8 到 256，默认值 32 */#define RT_THREAD_PRIORITY_MAX 32/* 设置 RT-Thread 操作系统节拍，表示多少 tick 每秒 *//* 时钟节拍率越快，系统的额外开销就越大。常用值为 100 或 1000。 */#define RT_TICK_PER_SECOND 1000/* 字节对齐时设定对齐的字节个数，默认 4，常使用 ALIGN(RT_ALIGN_SIZE) 进行字节对齐 */#define RT_ALIGN_SIZE 4/* 设置对象名称的最大长度，默认 8 个字符，一般无需修改 */#define RT_NAME_MAX 8/* 设置使用组件自动初始化功能，默认需要使用，开启该宏则可以使用自动初始化功能 */#define RT_USING_COMPONENTS_INIT/* 开启 RT_USING_USER_MAIN 宏，则打开 user_main 功能，默认需要开启，这样才能调用 RT-Thread 的启动代码 *//* main 线程的栈大小可修改 */#define RT_USING_USER_MAIN#define RT_MAIN_THREAD_STACK_SIZE 1024/* ********************** 内核调试部分 *************************//* 定义 RT_DEBUG 宏则开启 debug 模式。若开启系统调试，则在实现打印之后可以打印系统 LOG 日志。请在代码开发与调试过程中打开该项，帮助调试定位问题，在代码发布时关闭该项 *///#define RT_DEBUG // 关闭 debug#define RT_DEBUG_INIT 0 // 启用组件初始化调试配置，设置为 1 则会打印自动初始化的函数名称//#define RT_USING_OVERFLOW_CHECK\t// 关闭栈溢出检查/* ********************** 钩子函数部分 *************************//* 设置是否使用钩子函数，默认关闭 *///#define RT_USING_HOOK // 是否 开启系统钩子功能//#define RT_USING_IDLE_HOOK\t// 是否 开启空闲线程钩子功能/* ********************** 软件定时器部分 *************************//* 设置是否启用软件定时器，以及相关参数的配置，默认关闭 *///#define RT_USING_TIMER_SOFT // 是否 开启软件定时器功能#define RT_TIMER_THREAD_PRIO 4 // 设置软件定时器线程的优先级，默认为 4#define RT_TIMER_THREAD_STACK_SIZE 512\t// 设置软件定时器线程的栈大小，默认为 512 字节/* ********************** IPC 部分 *************************//* 系统支持的 IPC 有：信号量、互斥量、事件集、邮箱、消息队列。通过定义相应的宏打开或关闭该 IPC 的使用 */#define RT_USING_SEMAPHORE // 设置是否使用 信号量，默认打开//#define RT_USING_MUTEX // 设置是否使用 互斥量//#define RT_USING_EVENT // 设置是否使用 事件集//#define RT_USING_MAILBOX // 设置是否使用 邮箱//#define RT_USING_MESSAGEQUEUE\t// 设置是否使用 消息队列/* ********************** 内存部分 *************************//* RT-Thread 内存管理包含：内存池、内存堆、小内存算法。通过开启相应的宏定义使用相应的功能 */#define RT_USING_HEAP // 是否使用 内存堆#define RT_USING_SMALL_MEM // 是否使用 小内存管理//#define RT_USING_TINY_SIZE\t// 是否使用 小体积的算法，牵扯到 rt_memset、rt_memcpy 所产生的体积/* ********************** FinSH 部分 *************************/#define RT_USING_CONSOLE // 开启控制台功能，失能该宏则关闭控制台，不能实现打印#define RT_CONSOLEBUF_SIZE 128 // 控制台缓冲大小（1-1024）/* 当系统加入 FinSH 组件源码后，需要在 rtconfig.h 中开启以下项。参考 finsh_config.h 中内容。若未加入 FinSH 组件源码，请勿开启此项。 */#include finsh_config.h/* ********************** device 部分 *************************//* 当系统中加入 device 框架源码时，则需要在 rtconfig.h 中开启以下项。若未加入 device 源码，请勿开启此项 *///#define RT_USING_DEVICE#endif finsh_config.h内容如下 /* FinSH config file */#ifndef __MSH_CFG_H__#define __MSH_CFG_H__/* 打开 FinSH 组件 */#define RT_USING_FINSH/* 使用 MSH 模式 */#define FINSH_USING_MSH#define FINSH_USING_MSH_ONLY/* tshell 线程的优先级与线程栈大小 */#define FINSH_THREAD_PRIORITY 21 // 请检查系统最大优先级的值，该值必须在系统支持的优先级范围之内#define FINSH_THREAD_STACK_SIZE 1024/* 使用符号表，使用命令描述 */#define FINSH_USING_SYMTAB#define FINSH_USING_DESCRIPTION#endif","tags":["RTOS","RT-Thread"],"categories":["RTOS"]},{"title":"rtthread使用","path":"/2020/09/01/03. RTOS/rtthread_standard/","content":"开发平台：RT-Thread Studio 开发板：潘多拉 STM32L475VET6、战舰板 STM32F103ZET6 RTThread版本：4.0.3 芯片包版本：0.1.9（F1、F4、L4的都是） 一. 创建工程及时钟1.1 创建工程文件 - 新建 - RT-Thread 项目。 创建工程后，直接编译，无报错和警告 如果这个时候直接编译不通过的，在包管理器中降低芯片包的版本，不要用最新的，最新的更多会适配高版本的rtthread，比如为了适配4.1.1而新发的芯片包。（L4芯片的就有这个问题） 下载至开发板 打开串口助手可以看到内容输出。 1.2 时钟分析根据提示，默认使用的是内部时钟，如果需要修改，请修改drv_clk.c文件。 分析一下，根据启动文件，可以梳理一下启动过程。 从这里启动 然后在 rt-thread - src - components.c 文件中能看到包含int entry(void)在内的所有初始化函数。 从int entry(void);函数中进入rtthread_startup();函数，再从中进入rt_hw_board_init();函数，再从中进入hw_board_init(BSP_CLOCK_SOURCE, BSP_CLOCK_SOURCE_FREQ_MHZ, BSP_CLOCK_SYSTEM_FREQ_MHZ);函数。 这里面传入的参数是定义在 board.h 文件中的，默认如下： ————————– CLOCK CONFIG BEGIN ————————– #define BSP_CLOCK_SOURCE (“HSI”)#define BSP_CLOCK_SOURCE_FREQ_MHZ ((int32_t)0)#define BSP_CLOCK_SYSTEM_FREQ_MHZ ((int32_t)80) ————————– CLOCK CONFIG END ————————– 但是，继续往下翻下去，发现传入的这几个参数根本没用。 再从中进去clk_init(clock_src, clock_src_freq, clock_target_freq);函数。这个函数就定义在drv_clk.c文件中。 该函数又调用了system_clock_config(target_freq);函数，该函数内容如下，这里的时钟配置为默认使用的内部高速时钟。 可以看出，最后这里是时钟初始化的地方。需要修改时钟只需要修改此函数即可。 可以看出，board.h中的那几个宏定义在传参的过程中，最后也没传过来。（即 没用） 1.3 时钟配置最简单的配置时钟的方法还是，使用cubemx生成一个。 从左侧打开cubemx窗口，然后配置上调试接口、时钟树、串口，然后选择makefile，直接生成工程，其他的都没有改动。生成完毕之后，然后关闭cubemx界面（后续都是关闭界面之后才生效，就不再写了），在左边可以看到cubemx文件夹。 注意： 串口的配置，打开就行，具体的参数可以不用管其实。 如果没看到这个文件夹，就鼠标在工程栏选中工程，然后右键刷新一下。 生成完成之后还会有提示有个文件被重命名了。 如果没弹出来，注意cubemx界面是否关掉了。一定要关掉才可以。 点击cubemx的时候，有时候会不小心点到多次，打开了两个cubemx界面，都要关掉才行。 因为cubemx根据你的配置重新生成了一份配置文件，所以原有的那一份就给你换了个名字做备份。而且后续每次使用cubemx生成代码后，该文件中的宏定义会自动打开，就不用手动打开了。 为什么在上面的配置中需要勾选串口，是因为，默认的配置文件中是打开了串口的定义的，但是使用cubemx重新生成的话，不勾选串口，生成的配置文件中不会自动添加使用串口的宏定义。 另外，再次打开上面提到的drv_clk.c文件查看clk_init函数。 可以发现使用cubemx生成之后，这个函数被自动更改了，提示我们这个函数现在使用的是cubemx生成的内容了。而且此时跟随SystemClock_Config();函数定义的位置，可以发现，它会跳到cubemx生成的那个main.c文件中的时钟初始化部分，即调用的是新生成的时钟初始化函数。 而且，在cubemx生成的main.c文件中的main函数中，在定义的前面自动加了**__WEAK**标识。 然后，点击编译，应该也是可以通过的，无错误无警告。 如果有串口相关错误：检查cubemx是否打开了串口一的配置（SHELL默认用的串口一，但是实际上随便勾选一个串口，让cubemx把串口的头文件打开就行了，具体的引脚初始化函数其实没用到） 二. 设备框架使用以下并不一定是按照从简单到麻烦的顺序来的。 2.1 PIN设备pin设备默认是开启的，直接使用即可。 2.1.1 LED闪烁在工程中新建一个文件夹，在文件夹中新建一个.c文件，添加以下内容。 编译下载后，在Shell窗口输入led_thread_test命令，可以看到两个LED闪烁。 /* * 程序清单：这是一个 pin 设备使用例程 * 例程导出了 led_thread_test 命令到控制终端 * 命令调用格式：led_thread_test * 程序功能：运行后两个led闪烁，闪烁时间间隔分别为1s和2s*/#include rtdevice.h#include drv_common.h#include rtthread.h// 线程函数体需要传入的参数typedef struct rt_uint32_t flash_ms; rt_uint8_t led_index;Parameter_struct;// 线程相关参数#define THREAD_PRIORITY 25#define THREAD_STACK_SIZE 512#define THREAD_TIMESLICE 5// LED引脚定义#define LED0_PIN GET_PIN(B, 5)#define LED1_PIN GET_PIN(E, 5)// LED编号#define LED0 0#define LED1 1// 定义LED0的参数结构体Parameter_struct Parameter0_struct = .flash_ms = 1000, .led_index = LED0,;// 定义LED1的参数结构体Parameter_struct Parameter1_struct = .flash_ms = 2000, .led_index = LED1,;/* led_test：动态创建线程 * 1. 定义一个 线程结构体指针 这里命名为：led_thread * 2. 编写一个 线程函数体 这里命名为：led_thread_entry * 3. 调用 rt_thread_create 创建一个线程 * 4. 调用 rt_thread_startup 启动线程 */static rt_thread_t led_thread = NULL;/** * @brief LED闪烁线程函数体 * * @param flash_ms 闪烁间隔时间，单位毫秒 * @param led_index led编号，0/1 * * @return none * * @note static防止和其他文件中的重名；此线程不会终止。 */static void led_thread_entry (void *parameter) // 接收传过来的参数 Parameter_struct *in_parameter = (Parameter_struct *)parameter; // rt_kprintf(in_flash_ms = %d, in_led_index = %d , in_parameter-flash_ms, in_parameter-led_index); // 反转使用 rt_uint32_t count = 0; while(1) // 判断LED编号 switch(in_parameter-led_index) case LED0: rt_kprintf(led0 flash ); rt_pin_write(LED0_PIN, count % 2); break; case LED1: rt_kprintf(led1 flash ); rt_pin_write(LED1_PIN, count % 2); break; default: rt_kprintf(please enter the correct LED index.(0/1) ); count++; rt_thread_mdelay(in_parameter-flash_ms); static int led_thread_test(void) // LED模式初始化 rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LED1_PIN, PIN_MODE_OUTPUT); rt_pin_write(LED0_PIN, 1); rt_pin_write(LED1_PIN, 1); /* led0：动态创建线程 start */ if(Parameter0_struct.flash_ms != 0) led_thread = rt_thread_create(led0_th, // name led_thread_entry, // 函数体入口 (void*)Parameter0_struct, // 函数体 参数 THREAD_STACK_SIZE, // 分配内存大小 THREAD_PRIORITY, // 优先级 THREAD_TIMESLICE); // 时间片大小 /* 如果获得线程控制块，启动这个线程 */ if (led_thread != RT_NULL) rt_thread_startup(led_thread); // 启动线程 else // 输出错误码 rt_kprintf(led0 flash thread is failed...the error code is %ld \\r , led_thread-error); /* led0：over */ led_thread = RT_NULL; /* led1：动态创建线程 start */ if(Parameter1_struct.flash_ms != 0) led_thread = rt_thread_create(led1_th, // name led_thread_entry, // 函数体入口 (void*)Parameter1_struct, // 函数体 参数 THREAD_STACK_SIZE, // 分配内存大小 THREAD_PRIORITY, // 优先级 THREAD_TIMESLICE); // 时间片大小 /* 如果获得线程控制块，启动这个线程 */ if (led_thread != RT_NULL) rt_thread_startup(led_thread); // 启动线程 else // 输出错误码 rt_kprintf(led1 flash thread is failed...the error code is %ld \\r , led_thread-error); /* led1：over */ return RT_EOK;MSH_CMD_EXPORT(led_thread_test, led thread test); 2.1.2 按键中断在工程中新建一个文件夹，在文件夹中新建一个.c文件，添加以下内容。 编译下载后，在Shell窗口输入key_irq_test命令，然后按下按键，对应LED亮起。 /* * 程序清单：这是一个 PIN 设备绑定中断使用例程 * 例程导出了 key_irq_test 命令到控制终端 * 命令调用格式：key_irq_test * 程序功能：通过按键控制led亮灭*/#include rtthread.h#include rtdevice.h#include drv_common.h// KEY引脚定义#define KEY0_PIN GET_PIN(E, 4) // RIGHT#define KEY2_PIN GET_PIN(E, 2) // LEFT// LED引脚定义#define LED0_PIN GET_PIN(B, 5)#define LED1_PIN GET_PIN(E, 5)void led0_on(void *args) rt_kprintf(led0 on, led1 off! ); rt_pin_write(LED0_PIN, PIN_LOW); rt_pin_write(LED1_PIN, PIN_HIGH);void led1_on(void *args) rt_kprintf(led0 off, led1 on! ); rt_pin_write(LED0_PIN, PIN_HIGH); rt_pin_write(LED1_PIN, PIN_LOW);static void key_irq_test(void) /* LED引脚为输出模式 */ rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT); rt_pin_mode(LED1_PIN, PIN_MODE_OUTPUT); /* 默认高电平 */ rt_pin_write(LED0_PIN, PIN_HIGH); rt_pin_write(LED1_PIN, PIN_HIGH); /* 按键0引脚为输入模式 */ rt_pin_mode(KEY0_PIN, PIN_MODE_INPUT_PULLUP); /* 绑定中断，下降沿模式，回调函数名为led0_on */ rt_pin_attach_irq(KEY0_PIN, PIN_IRQ_MODE_FALLING, led0_on, RT_NULL); /* 使能中断 */ rt_pin_irq_enable(KEY0_PIN, PIN_IRQ_ENABLE); /* 按键2引脚为输入模式 */ rt_pin_mode(KEY2_PIN, PIN_MODE_INPUT_PULLUP); /* 绑定中断，下降沿模式，回调函数名为led1_on */ rt_pin_attach_irq(KEY2_PIN, PIN_IRQ_MODE_FALLING, led1_on, RT_NULL); /* 使能中断 */ rt_pin_irq_enable(KEY2_PIN, PIN_IRQ_ENABLE);/* 导出到 msh 命令列表中 */MSH_CMD_EXPORT(key_irq_test, key irq test); 2.2 串口设备目标：串口二接收串口助手发来的数据，并且将数据重新发送出去。 此设备的开启步骤在board.h中是有描述的。 第一步：在 RT-Thread Settings 中 - 组件 - 设备驱动程序 - 使用UART设备驱动程序 - 使能串口DMA模式，勾选上。 使用UART设备驱动程序 默认是打开的，因为串口一用于SHELL窗口了。这里只要把下面的DMA点开即可。 第二步：在 board.h 中，添加如下宏定义。 // 新增 串口2 设备#define BSP_USING_UART2#define BSP_UART2_TX_PIN PA2#define BSP_UART2_RX_PIN PA3// 串口2 使用接收DMA#define BSP_UART2_RX_USING_DMA 此时如果直接编译，然后在Shell窗口输入list_device命令，就已经能看到uart2设备了。 第三步：编写测试代码 /* * 程序清单：这是一个串口设备 DMA 接收使用例程 * 例程导出了 uart2_dma_test 命令到控制终端 * 命令调用格式：uart2_dma_test * 程序功能：运行后通过串口输出字符串usart2 test is running!，之后，串口会将接收到的数据重新发送出去。 * 此功能需要做出的适配如下：1. 在board.h串口部分添加如下宏定义 * #define BSP_USING_UART2 * #define BSP_UART2_TX_PIN PA2 * #define BSP_UART2_RX_PIN PA3 * #define BSP_UART2_RX_USING_DMA * 2.在rt-thread settings-组件-设备驱动程序-串口中打开DMA设置*/#include rtthread.h// 串口接收消息结构struct rx_msg rt_device_t dev; rt_size_t size;;// 串口设备名称#define TEST_UART_NAME uart2// 串口设备句柄static rt_device_t usart_serial;// 消息队列控制块static struct rt_messagequeue usart_rx_mq;/* 接收数据回调函数 */// 若串口以 DMA 接收模式打开，当 DMA 完成一批数据的接收后会调用此回调函数。// dev 是设备句柄// size 是缓冲区中接收到的数据长度static rt_err_t uart_input(rt_device_t dev, rt_size_t size) struct rx_msg msg; rt_err_t result; // 把接收消息的对象 和 消息的大小放到msg结构体 msg.dev = dev; msg.size = size; // 把包装好的msg发送到消息队列 result = rt_mq_send(usart_rx_mq, msg, sizeof(msg)); // 如果放满了输出提示信息 if ( result == -RT_EFULL) /* 消息队列满 */ rt_kprintf(message queue full！ ); return result;// 串口线程函数体static void serial_thread_entry(void *parameter) struct rx_msg msg; rt_err_t result; rt_uint32_t rx_length; static char rx_buffer[RT_SERIAL_RB_BUFSZ + 1]; // 循环接收消息 while (1) // 将msg中的内容清零 rt_memset(msg, 0, sizeof(msg)); /* 从消息队列中读取消息 放到msg中，采用一直等待的方式 */ result = rt_mq_recv(usart_rx_mq, msg, sizeof(msg), RT_WAITING_FOREVER); if (result == RT_EOK) /* 从串口读取 msg.size个字节的数据，并放到rx_buffer中 */ rx_length = rt_device_read(msg.dev, 0, rx_buffer, msg.size); // 最后补 \\0 rx_buffer[rx_length] = \\0; /* 通过串口设备 serial 输出读取到的消息 */ rt_device_write(usart_serial, 0, rx_buffer, rx_length); /* 打印数据 */ rt_kprintf(%s , rx_buffer); static int uart2_dma_test(void) rt_err_t ret = RT_EOK; static char msg_pool[256]; char str[] = usart2 test is running!\\r ; // 步骤1 通过串口名字找到串口句柄, 名称定义在最上边。 usart_serial = rt_device_find(TEST_UART_NAME); if (!usart_serial) // 未找到输出提示 rt_kprintf(TEST_UART_NAME); rt_kprintf(not find! ); return RT_ERROR; // 步骤2 设置串口初始化参数 这里跳过 // 步骤3 以DMA接收及轮询发送方式打开串口设备 rt_device_open(usart_serial, RT_DEVICE_FLAG_DMA_RX); // 步骤4 设置串口接收回调函数 // 3.1 初始化消息队列（回调函数中需要使用） rt_mq_init(usart_rx_mq, usart_rx_mq, msg_pool, /* 存放消息的缓冲区 */ sizeof(struct rx_msg), /* 一条消息的最大长度 */ sizeof(msg_pool), /* 存放消息的缓冲区大小 */ RT_IPC_FLAG_FIFO); /* 如果有多个线程等待，按照先来先得到的方法分配消息 */ // 3.2 设置接收回调函数 rt_device_set_rx_indicate(usart_serial, uart_input); // 步骤4 创建并启动 串口线程 // 发送开始了的提示信息 rt_device_write(usart_serial, 0, str, (sizeof(str) - 1)); // 创建 serial 线程 rt_thread_t thread = rt_thread_create(serial, serial_thread_entry, RT_NULL, 1024, 25, 10); // 创建成功则启动线程 if (thread != RT_NULL) rt_thread_startup(thread); else ret = RT_ERROR; return ret;/* 导出到 msh 命令列表中 */MSH_CMD_EXPORT(uart2_dma_test, uart2 device dma test); 编译运行后，在SHELL窗口（串口一）输入uart2_dma_test命令，然后在串口二中发送信息，串口二会将收到的信息重新发送。 如果想要使用串口一，需要做出的改动如下： board.c中的宏定义 #define BSP_USING_UART1#define BSP_UART1_TX_PIN PA9#define BSP_UART1_RX_PIN PA10#define BSP_UART1_RX_USING_DMA 在 RT-Thread Settings 中 - 组件 - shell命令中，将其关闭。 将上述程序中的#define TEST_UART_NAME uart2，2 改为 1。 其余的函数名、命令名改不改都行，不影响运行，要能分辨就行。 关于串口发送DMA 经测试，在部分芯片包中貌似不支持发送DMA。（理由未知） 在潘多拉STM32L475VET6中，增加#define BSP_UART2_TX_USING_DMA宏定义会报错。 而在电子料架板卡STM32F407VET6中，增加#define BSP_UART2_TX_USING_DMA宏定义就可以正常编译通过。 2.3 CAN（需要改驱动）目标：使用CAN接口发送和接收数据。 此设备的开启步骤在board.h中没有相关描述。但是有BUG。 硬件配置 硬件设备：CANelyst-Ⅱ，设备的CAN_L与开发板的L连接，设备的CAN_H与开发板的H连接。 软件：USB_CAN TOOL，切记切记要安装驱动，否则会一直显示未找到设备。 可以先按照软件上方目录 - 设备操作 - USBCAN测试工具中的操作指引，将硬件两个端口连起来，测试硬件是否正常运行，然后在搞软件。 常见问题： 设备一直未找到（无法连接）。打开电脑设备管理器看CAN设备是否正常识别，如果未识别，说明没安装驱动。安装驱动方法参考：软件上方目录 - 帮助 - 帮助文档 - 2. USB驱动安装与卸载说明书.pdf 程序 第一步：在 RT-Thread Settings 中 - 组件 - 设备驱动程序 - CAN设备驱动程序，勾选上 - 使能CAN硬件过滤器，也先勾选上。 硬件过滤器：作用未知，等了解了过来写上。 第二步：添加驱动程序。在RT-Thread Studio 软件的安装目录下：D:\\RT-ThreadStudio\\repo\\Extract\\RT-Thread_Source_Code\\RT-Thread\\4.0.3\\bsp\\stm32\\libraries\\HAL_Drivers\\ 找到drv_can.c放到我们工程的drivers文件夹，找到drv_can.h文件放到我们工程的drivers\\include文件夹。 第三步：添加以下宏定义到board.h文件中，这里使用 CAN1 进行测试。注意：下面这部分宏定义都是自己添加的，默认是没有关于CAN接口的宏定义的。 /*-------------------------- CAN CONFIG BEGIN --------------------------*/#define BSP_USING_CAN#define BSP_USING_CAN1/*#define BSP_USING_CAN2*//*-------------------------- CAN CONFIG END --------------------------*/ 第四步：从左侧窗口打开cubemx，勾选上CAN接口，引脚是对的就可以，参数配置可以不用管。然后关闭cubemx界面，生成代码后刷新左侧目录界面。即可在cubemx文件夹中的stm32f1xx_hal_msp.c文件中看到CAN的引脚初始化代码。 此时如果直接编译，然后在Shell窗口输入list_device命令，就已经能看到can1设备了。 第五步：编写测试代码，程序运行后，打开CAN-USB软件并连接设备，波特率设置1000k，然后在Shell窗口输入can_test命令，即可从CAN-USB软件中看到开发板发送的消息。也可以使用CAN-USB软件发送消息，在Shell窗口可看到接收的消息。 /* * 程序清单：这是一个 CAN 设备使用例程 * 例程导出了 can_test 命令到控制终端 * 命令调用格式：can_test can1 * 命令解释：命令第二个参数是要使用的 CAN 设备名称，为空则使用默认的 CAN 设备 * 程序功能：通过 CAN 设备发送一帧，并创建一个线程接收数据然后打印输出。*/#include rtthread.h#include rtdevice.h#define CAN_DEV_NAME can1 /* CAN 设备名称 */static struct rt_semaphore rx_sem; /* 用于接收消息的信号量 */static rt_device_t can_dev; /* CAN 设备句柄 *//* 接收数据回调函数 */static rt_err_t can_rx_call(rt_device_t dev, rt_size_t size) /* CAN 接收到数据后产生中断，调用此回调函数，然后发送接收信号量 */ rt_sem_release(rx_sem); return RT_EOK;static void can_rx_thread(void *parameter) int i; rt_err_t res; struct rt_can_msg rxmsg = 0; /* 设置接收回调函数 */ rt_device_set_rx_indicate(can_dev, can_rx_call);#ifdef RT_CAN_USING_HDR struct rt_can_filter_item items[5] = RT_CAN_FILTER_ITEM_INIT(0x100, 0, 0, 0, 0x700, RT_NULL, RT_NULL), /* std,match ID:0x100~0x1ff，hdr 为 - 1，设置默认过滤表 */ RT_CAN_FILTER_ITEM_INIT(0x300, 0, 0, 0, 0x700, RT_NULL, RT_NULL), /* std,match ID:0x300~0x3ff，hdr 为 - 1 */ RT_CAN_FILTER_ITEM_INIT(0x211, 0, 0, 0, 0x7ff, RT_NULL, RT_NULL), /* std,match ID:0x211，hdr 为 - 1 */ RT_CAN_FILTER_STD_INIT(0x486, RT_NULL, RT_NULL), /* std,match ID:0x486，hdr 为 - 1 */ 0x555, 0, 0, 0, 0x7ff, 7, /* std,match ID:0x555，hdr 为 7，指定设置 7 号过滤表 */ ; struct rt_can_filter_config cfg = 5, 1, items; /* 一共有 5 个过滤表 */ /* 设置硬件过滤表 */ res = rt_device_control(can_dev, RT_CAN_CMD_SET_FILTER, cfg); RT_ASSERT(res == RT_EOK);#endif while (1) /* hdr 值为 - 1，表示直接从 uselist 链表读取数据 */ rxmsg.hdr = -1; /* 阻塞等待接收信号量 */ rt_sem_take(rx_sem, RT_WAITING_FOREVER); /* 从 CAN 读取一帧数据 */ rt_device_read(can_dev, 0, rxmsg, sizeof(rxmsg)); /* 打印数据 ID 及内容 */ rt_kprintf(ID:%x, rxmsg.id); for (i = 0; i 8; i++) rt_kprintf(%2x, rxmsg.data[i]); rt_kprintf( ); int can_test(int argc, char *argv[]) struct rt_can_msg msg = 0; rt_err_t res; rt_size_t size; rt_thread_t thread; char can_name[RT_NAME_MAX]; if (argc == 2) rt_strncpy(can_name, argv[1], RT_NAME_MAX); else rt_strncpy(can_name, CAN_DEV_NAME, RT_NAME_MAX); /* 查找 CAN 设备 */ can_dev = rt_device_find(can_name); if (!can_dev) rt_kprintf(find %s failed! , can_name); return RT_ERROR; /* 初始化 CAN 接收信号量 */ rt_sem_init(rx_sem, rx_sem, 0, RT_IPC_FLAG_FIFO); /* 以中断接收及中断发送方式打开 CAN 设备 */ res = rt_device_open(can_dev, RT_DEVICE_FLAG_INT_TX | RT_DEVICE_FLAG_INT_RX); RT_ASSERT(res == RT_EOK); /* 创建数据接收线程 */ thread = rt_thread_create(can_rx, can_rx_thread, RT_NULL, 1024, 25, 10); if (thread != RT_NULL) rt_thread_startup(thread); else rt_kprintf(create can_rx thread failed! ); msg.id = 0x78; /* ID 为 0x78 */ msg.ide = RT_CAN_STDID; /* 标准格式 */ msg.rtr = RT_CAN_DTR; /* 数据帧 */ msg.len = 8; /* 数据长度为 8 */ /* 待发送的 8 字节数据 */ msg.data[0] = 0x00; msg.data[1] = 0x11; msg.data[2] = 0x22; msg.data[3] = 0x33; msg.data[4] = 0x44; msg.data[5] = 0x55; msg.data[6] = 0x66; msg.data[7] = 0x77; /* 发送一帧 CAN 数据 */ size = rt_device_write(can_dev, 0, msg, sizeof(msg)); if (size == 0) rt_kprintf(can dev write data failed! ); // 更改后再发送十次 for(rt_uint8_t send_ind = 0; send_ind 10; send_ind++) rt_thread_mdelay(1000); msg.data[0] = msg.data[0] + 0x01; msg.data[1] = msg.data[1] + 0x01; msg.data[2] = msg.data[2] + 0x01; msg.data[3] = msg.data[3] + 0x01; msg.data[4] = msg.data[4] + 0x01; msg.data[5] = msg.data[5] + 0x01; msg.data[6] = msg.data[6] + 0x01; msg.data[7] = msg.data[7] + 0x01; /* 发送一帧 CAN 数据 */ size = rt_device_write(can_dev, 0, msg, sizeof(msg)); if (size == 0) rt_kprintf(can dev write data failed! ); return res;/* 导出到 msh 命令列表中 */MSH_CMD_EXPORT(can_test, can device sample); 另外：上述程序使用F1的开发板没有出现问题，但是使用其他板卡（F407VET6）上一直发送失败。 问题和解决办法如下：https://club.rt-thread.org/ask/article/5cedb728813e6fd8.html 但是相比于上面文章，多更改了关于波特率表的设置，自己测试一下波特率250和500k的需不需要改。 修改后的CAN驱动文件在文件夹中附上了。 2.4 ADC目标：串口打印ADC的值。 此设备的开启步骤在board.h中是有描述的。 第一步：在 RT-Thread Settings 中 - 组件 - 设备驱动程序 - 使用ADC设备驱动程序，勾选上。 第二步：在board.h中打开#define BSP_USING_ADC1宏定义。 这里测试使用的引脚为PA1（ADC1的通道1）。 第三步：从左侧窗口打开cubemx，勾选上ADC1的CH1，确认一下引脚是不是对的，参数配置可以不用管。ADC打开了，时钟树配置界面ADC的时钟也要配置一下，不能超过14Mhz（ADC的需求）。然后关闭cubemx界面，生成代码后刷新左侧目录界面。即可在cubemx文件夹中的stm32f1xx_hal_msp.c文件中看到ADC的引脚初始化代码。 此时如果直接编译，然后在Shell窗口输入list_device命令，就已经能看到adc1设备了。 第四步：编写测试代码，程序运行后，在Shell窗口输入adc_vol_test命令，即可以在Shell窗口看到连续发送50次的ADC采样值和电压值。在此过程中改变PA1接触的地方，可以看到电压值的改变。 /* * 程序清单： ADC 设备使用例程 * 例程导出了 adc_vol_test 命令到控制终端 * 命令调用格式：adc_vol_test * 程序功能：通过 ADC 设备采样电压值并转换为数值。 * 示例代码参考电压为3.3V,转换位数为12位。*/#include rtthread.h#include rtdevice.h#define ADC_DEV_NAME adc1 /* ADC 设备名称 */#define ADC_DEV_CHANNEL 1 /* ADC 通道 */#define REFER_VOLTAGE 330 /* 参考电压 3.3V,数据精度乘以100保留2位小数*/#define CONVERT_BITS (1 12) /* 转换位数为12位 */static int adc_vol_test(int argc, char *argv[]) rt_adc_device_t adc_dev; rt_uint32_t value, vol; rt_err_t ret = RT_EOK; /* 查找设备 */ adc_dev = (rt_adc_device_t)rt_device_find(ADC_DEV_NAME); if (adc_dev == RT_NULL) rt_kprintf(adc test run failed! cant find %s device! , ADC_DEV_NAME); return RT_ERROR; /* 使能设备 */ ret = rt_adc_enable(adc_dev, ADC_DEV_CHANNEL); // 连续采集并发送50次 for(rt_uint16_t times = 0; times = 50; times++) /* 读取采样值 */ value = rt_adc_read(adc_dev, ADC_DEV_CHANNEL); /* 转换为对应电压值 */ vol = value * REFER_VOLTAGE / CONVERT_BITS; // 输出 rt_kprintf(the value is :%d, the voltage is :%d.%02d , value, vol / 100, vol % 100); // 等待一下下再开启下一轮 rt_thread_mdelay(500); /* 关闭通道 */ ret = rt_adc_disable(adc_dev, ADC_DEV_CHANNEL); return ret;/* 导出到 msh 命令列表中 */MSH_CMD_EXPORT(adc_vol_test, adc voltage convert test); 2.5 IIC目标：实现对24C02的读写功能。 此设备的开启步骤在board.h中是有描述的。 第一步：在 RT-Thread Settings 中 - 组件 - 设备驱动程序 - 使用GPIO模拟I2C，勾选上。 第二步：在board.h中打开#define BSP_USING_I2C1宏定义，并修改对应的引脚。注意这里的引脚是用的软件模拟，跟硬件IIC没关系，所以引脚用哪个写哪个。这里如下： #define BSP_USING_I2C1#ifdef BSP_USING_I2C1#define BSP_I2C1_SCL_PIN GET_PIN(B, 6)#define BSP_I2C1_SDA_PIN GET_PIN(B, 7)#endif 此时如果直接编译，然后在Shell窗口输入list_device命令，就已经能看到i2c1设备了。 第三步：编写24C02驱动代码及测试代码。 C文件 #include drv_iic_24c02.h#define LOG_TAG AT24C02#define LOG_LVL LOG_LVL_DBG#include rtdbg.h/* I2C总 线 设 备 句 柄 */static struct rt_i2c_bus_device *i2c_bus = RT_NULL;/** * @brief 读AT24C02中addr地址的数据 * * @param addr 读取的地址（0-255） * * @return RT_EOK：正常；RT_ERROR：不正常。 */uint8_t at24c02_read_byte(uint8_t addr) struct rt_i2c_msg msg; uint8_t buffer[2]; uint8_t data; msg.addr = AT24C02_I2C_ADDR; msg.flags = RT_I2C_WR; buffer[0] = addr; msg.buf = buffer; msg.len = 1; // 发送要读数据的地址 rt_i2c_transfer(i2c_bus, msg, 1); msg.flags = RT_I2C_RD; msg.buf = data; // 读数据 rt_i2c_transfer(i2c_bus, msg, 1); return data;/** * @brief AT24C02写一个字节数据 * * @param addr 写入的地址（0-255） * @param data 写入的数据 * * @return RT_EOK：正常；RT_ERROR：不正常。 */rt_err_t at24c02_write_byte(uint8_t addr, uint8_t data) struct rt_i2c_msg msg; uint8_t buffer[2]; buffer[0] = addr; buffer[1] = data; msg.addr = AT24C02_I2C_ADDR; msg.flags = RT_I2C_WR; msg.buf = buffer; msg.len = 2; // 发送要写数据的地址、写的数据 if(rt_i2c_transfer(i2c_bus, msg, 1) != 1) return RT_ERROR; return RT_EOK;/** * @brief 检查AT24C02设备是否正常 * * @param check 任意传入一个数（1字节），每次检查不要一样。 * * @return RT_EOK：正常；RT_ERROR：不正常。 */static rt_err_t at24c02_check(uint8_t check) uint8_t temp; // 读取最后一个字节的数据 temp = at24c02_read_byte(AT24C02_SIZE - 1); if(temp != check) // 把数据写入最后一个字节的位置 at24c02_write_byte(AT24C02_SIZE - 1, check); rt_thread_mdelay(5); // wait 5ms // 再次读取 temp = at24c02_read_byte(AT24C02_SIZE - 1); if(temp != check) return RT_ERROR; return RT_EOK;/** * @brief 初始化AT24C02 * * @param void * * @return none */rt_err_t at24c02_init() // 查找I2C总线设备，获取I2C总线设备句柄 i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(AT24C02_I2C_BUS_NAME); if (i2c_bus == RT_NULL) LOG_D(cant find device! ); return RT_ERROR; // 检查AT24C02 if(at24c02_check(AT24C02_CHECK_VALUE) != RT_EOK) LOG_D(at24c02 check fail! ); return RT_ERROR; LOG_D(at24c02 check ok! ); return RT_EOK; 头文件 #ifndef APPLICATIONS_ICODE_IIC_24C02_SUPPORT_DRV_IIC_24C02_H_#define APPLICATIONS_ICODE_IIC_24C02_SUPPORT_DRV_IIC_24C02_H_#include rtthread.h#include drv_soft_i2c.h#define AT24C02_I2C_BUS_NAME i2c1 // 挂载IIC1上，PB6、PB7#define AT24C02_I2C_ADDR 0x50 // AT24C02从机地址(原有的是0xA0)#define AT24C02_SIZE 256 // AT24C02大小，共256字节#define AT24C02_CHECK_VALUE 0x5a/* * 24C02是2K，A0/A1/A2均为0，根据数据手册地址应该为，1 0 1 0 0 0 0 R/W； * 即 * 写：R/W=0，1 0 1 0 0 0 0 0，即0xA0； * 读：R/W=1，1 0 1 0 0 0 0 1，即0xA1； * 但是：对于7位地址模式，rt_i2c_transfer函数调用了bus-ops-master_xfer(bus, msgs, num); * 这个函数为：i2c_bit_xfer，这个函数又调用了i2c_bit_send_address。 * 这个函数对于七位地址的处理为 addr1 = msg-addr 1; * 即 左移了一位。我们原有的 0xA0 左移之后就不对了。 * 因此，这里将我们的0xA0提前右移一位 变成0x50，然后再发送就可以了。 * * */rt_err_t at24c02_init(); // 初始化AT24C02uint8_t at24c02_read_byte(uint8_t addr);rt_err_t at24c02_write_byte(uint8_t addr, uint8_t data);#endif /* APPLICATIONS_ICODE_IIC_24C02_SUPPORT_DRV_IIC_24C02_H_ */ 测试代码 #include drv_iic_24c02.h#include rtthread.hstatic int iic_at24c02_test(void) rt_uint8_t *read_write_read_buf = RT_NULL; // 申请一段内存（256个字节） read_write_read_buf = (rt_uint8_t *)rt_malloc(AT24C02_SIZE); // 初始化 at24c02 at24c02_init(); // 擦除(即全部填充为0) for(rt_uint16_t addr = 0; addr AT24C02_SIZE; addr++) if(RT_EOK == at24c02_write_byte(addr, 0)) rt_kprintf(address %x erase OK. , addr); else rt_kprintf(address %x erase Failed. , addr); // 连续读255字节的数据 for(rt_uint16_t addr = 0; addr AT24C02_SIZE; addr++) read_write_read_buf[addr] = at24c02_read_byte(addr); rt_kprintf(the data at address %x is %d. , addr, read_write_read_buf[addr]); // 连续写 for(rt_uint16_t addr = 0; addr AT24C02_SIZE; addr++) if(RT_EOK == at24c02_write_byte(addr, addr)) rt_kprintf(address %x write OK. , addr); else rt_kprintf(address %x write Failed. , addr); // 再次连续读255字节的数据 for(rt_uint16_t addr = 0; addr AT24C02_SIZE; addr++) read_write_read_buf[addr] = at24c02_read_byte(addr); rt_kprintf(the data at address %x is %d. , addr, read_write_read_buf[addr]); // 释放申请的内存 rt_free(read_write_read_buf); return RT_EOK;MSH_CMD_EXPORT(iic_at24c02_test, iic at24c02 read write test); 程序运行后，在Shell窗口输入iic_at24c02_test命令，即可看到程序首先将芯片数据全部擦除，然后读取，读取之后写入，并再次读取查看是否是写入的数据。 2.6 SPI + DFS目标：直接上文件系统。 这里用的潘多拉的板子，存储使用SD卡，接口是SPI。 第一步：在 RT-Thread Settings 中 - 组件 - 设备驱动程序 - 使用 SPI 总线设备驱动程序，勾选上。 第二步：在board.h中打开#define BSP_USING_SPI1宏定义，根据自己实际使用的SPI接口设置即可。 第三步：从左侧窗口打开cubemx，SPI1，确认一下引脚是不是对的，参数配置可以不用管，然后关闭cubemx界面，生成代码后刷新左侧目录界面。即可在cubemx文件夹中的stm32l4xx_hal_msp.c文件中看到SPI的引脚初始化代码。 到了这里SPI就可以使用了。 第四步：在 RT-Thread Settings 中 - 组件 - 设备驱动程序 - 使用 SPI 总线设备驱动程序 - 使用 SPI SDTF 卡驱动程序，勾选上。 勾选上保存之后，就能在 rt-thread - components 中看到 dfs 文件夹。这个文件夹中的文件定义了系统挂载、打开文件、创建文件夹等等接口。 2.7 PWM（需要改驱动）目标：PWM实现呼吸灯。 此设备的开启步骤在board.h中是有描述的。但是不全，而且有BUG。 第一步：在 RT-Thread Settings 中 - 组件 - 设备驱动程序 - 使用 PWM 设备驱动程序，勾选上。 第二步：在board.h中打开#define BSP_USING_PWM3宏定义，并添加使用的通道宏定义#define BSP_USING_PWM3_CH2。 这里测试使用的引脚为PB5（TIM3的通道2）。根据自己使用的定时器和通道进行修改上述宏定义。 另外，通道宏定义board.h里面没写，要自己添加上。 第三步：从左侧窗口打开cubemx，勾选上TIM3的CH2，确认一下引脚是不是对的，参数配置可以不用管，然后关闭cubemx界面，生成代码后刷新左侧目录界面。即可在cubemx文件夹中的stm32f1xx_hal_msp.c文件中看到TIM的引脚初始化代码，一共有两个函数。 void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim) 第四步：修改drv_pwm.c 在drv_pwm.c文件中的static rt_err_t stm32_hw_pwm_init(struct stm32_pwm *device)函数中，添加定时器的初始化。 static rt_err_t stm32_hw_pwm_init(struct stm32_pwm *device) rt_err_t result = RT_EOK; TIM_HandleTypeDef *tim = RT_NULL; TIM_OC_InitTypeDef oc_config = 0; TIM_MasterConfigTypeDef master_config = 0; TIM_ClockConfigTypeDef clock_config = 0; RT_ASSERT(device != RT_NULL); tim = (TIM_HandleTypeDef *)device-tim_handle; /* configure the timer to pwm mode */ tim-Init.Prescaler = 0; tim-Init.CounterMode = TIM_COUNTERMODE_UP; tim-Init.Period = 0; tim-Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;#if defined(SOC_SERIES_STM32F1) || defined(SOC_SERIES_STM32L4) tim-Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;#endif // 以下是自己添加的 // 注意这里是定时器的初始化 别看混了!!! if (HAL_TIM_Base_Init(tim) != HAL_OK) LOG_E(%s tim init failed, device-name); result = -RT_ERROR; goto __exit; // 以上是自己添加的 if (HAL_TIM_PWM_Init(tim) != HAL_OK) LOG_E(%s pwm init failed, device-name); result = -RT_ERROR; goto __exit; ... 第五步：添加测试例程 /* * 程序清单：这是一个 PWM 设备使用例程 * 例程导出了 pwm_thread_test 命令到控制终端 * 命令调用格式：pwm_thread_test * 程序功能：通过 PWM 设备控制 LED 灯的亮度，可以看到LED不停的由暗变到亮，然后又从亮变到暗。*/#include rtthread.h#include rtdevice.h#define PWM_DEV_NAME pwm3 /* PWM设备名称 */#define PWM_DEV_CHANNEL 2 /* PWM通道 */struct rt_device_pwm *pwm_dev; /* PWM设备句柄 */static rt_thread_t pwm_thread = NULL;// 线程相关参数#define THREAD_PRIORITY 25#define THREAD_STACK_SIZE 512#define THREAD_TIMESLICE 5static void pwm_led_thread_entry(void *parameter) rt_uint32_t period, pulse, dir; period = 500000; /* 周期为0.5ms，单位为纳秒ns */ dir = 1; /* PWM脉冲宽度值的增减方向 */ pulse = 0; /* PWM脉冲宽度值，单位为纳秒ns */ /* 查找设备 */ pwm_dev = (struct rt_device_pwm *)rt_device_find(PWM_DEV_NAME); if (pwm_dev == RT_NULL) rt_kprintf(pwm sample run failed! cant find %s device! , PWM_DEV_NAME); /* 设置PWM周期和脉冲宽度默认值 */ rt_pwm_set(pwm_dev, PWM_DEV_CHANNEL, period, pulse); /* 使能设备 */ rt_pwm_enable(pwm_dev, PWM_DEV_CHANNEL); while (1) rt_thread_mdelay(50); if (dir) pulse += 5000; /* 从0值开始每次增加5000ns */ else pulse -= 5000; /* 从最大值开始每次减少5000ns */ if (pulse = period) dir = 0; if (0 == pulse) dir = 1; /* 设置PWM周期和脉冲宽度 */ rt_pwm_set(pwm_dev, PWM_DEV_CHANNEL, period, pulse); static int pwm_thread_test(void) pwm_thread = rt_thread_create(pwm_th, // name pwm_led_thread_entry, // 函数体入口 RT_NULL, // 函数体 参数 THREAD_STACK_SIZE, // 分配内存大小 THREAD_PRIORITY, // 优先级 THREAD_TIMESLICE); // 时间片大小 /* 如果获得线程控制块，启动这个线程 */ if (pwm_thread != RT_NULL) rt_thread_startup(pwm_thread); // 启动线程 else // 输出错误码 rt_kprintf(pwm led thread is failed...the error code is %ld \\r , pwm_thread-error); return RT_EOK;/* 导出到 msh 命令列表中 */MSH_CMD_EXPORT(pwm_thread_test, pwm thread test); 2.8 网口","tags":["RTOS","RT-Thread"],"categories":["RTOS"]},{"title":"C语言","path":"/2017/01/01/01. 编程语法/c/","content":"1. C语言概述1.1 特点 代码级别的跨平台：由于标准的存在，使得几乎同样的C代码可用于多种操作系统。 允许直接访问物理地址，对硬件进行操作。 C语言是一个有结构化程序设计、具有变量作用域（variable scope）以及递归功能的过程式语言。 C语言传递参数可以是值传递（pass by value，值），也可以传递指针（apointer passed by value，地址）。 C语言中，没有对象，不同的变量类型可以用结构体（struct）组合在一起。 预编译处理（preprocessor）,生成目标代码质量高，程序执行效率高。 1.2 运行机制 编辑：比如编写我们的 hello.c 文件，就是源代码. 编译：将 hello.c 程序翻译成目标文件 (hello.obj) 在计算机底层执行 链接：将目标文件 hello.obj + 库文件生成可执行文件(MyProject01.exe) 在计算机底层执行 运行：执行.exe文件，得到运行结果 编译 有了C源文件，通过编译器将其编译成 obj文件(目标文件)。 如果程序没有错误，没有任何提示，但在Debug目录下会出现一个 Hello.obj 文件，该文件称为目标文件。 链接 有了目标文件(.obj文件)，通过链接程序将其和运行需要的c库文件链接成exe文件(可执行文件)。 如果程序没有错误，没有任何提示，但在 Debug 目录下会出现一个项目名.exe文件，该文件称为可执行文件。 为什么需要链接库文件呢？因为我们的C程序中会使用C程序库的内容，比如stdio.hstdlib.h中的函数 printf()、system() 等等,这些函数不是程序员自己写的，而是C程序库中提供的，因此需要链接。 你会发现链接后，生成的.exe文件，比obj文件大了很多. 运行 有了可执行的exe文件,也称为可执行程序(二进制文件) 在控制台下可以直接运行exe文件 1.3 转义字符\\t ：一个制表位，实现对齐的功能 ：换行符\\\\ ：一个\\\\ : 一个\\ ：一个\\r : 一个回车printf(张无忌赵敏周\\r芷若小昭); 1.4 注释// 单行注释/*\t多行注释1\t多行注释2\t注释不允许嵌套*/ 1.5 标准库C标准库是一组C内置函数、常量和头文件，比如stdio.h、stdlib.h、math.h，等等。 可以查手册来找需要使用的库和函数。 2. 变量2.1 变量介绍变量相当于内存中一个数据存储空间的表示，通过变量名可以访问到变量(值)。 变量表示内存中的一个存储区域（不同的数据类型，占用的空间大小不一样） 该区域有自己的名称和类型 变量必须先声明，后使用 该区域的数据可以在同一类型范围内不断变化 变量在同一个作用域内不能重名 变量三要素(变量名+值+数据类型)，这一点请大家注意。 2.2 数据类型 基本类型 数值类型 整型 short短整型 int整形 long长整型 浮点数 float单精度 double双精度 char字符类型 构造类型 数组 结构体struct 共用体union 枚举类型enum 指针类型 空类型void 在c中，没有字符串类型,使用字符数组表示字符串 在不同系统上，部分数据类型字节长度不一样，int 2 或者 4个字节 2.3 整数类型如 #include stdio.hint main() int num = 3; printf(num=%d, num); return(0); 类型 存储大小 值范围 char 1字节 -128 即 -(2^7) 到 127(2^7 -1) unsigned char 1 字节 0 到 255 (2^8 - 1) signed char 1 字节 -128 即-(2^7) 到 127 (2^7-1) int signed int 2 或 4 字节 -32,768 (- 2^15 ) 到 32,767 (2^15-1) 或 -2,147,483,648 (- 2^31) 到 2,147,483,647 (2^31 -1) unsigned int 2 或 4 字节 0 到 65,535 (2^16-1) 或 0 到 4,294,967,295 (2^32 -1) short signed short 2 字节 -32,768 (- 2^15)到 32,767 (2^15 -1) unsigned short 2 字节 0 到 65,535 (2^16 - 1) long signed long 4 字节 -2,147,483,648 (- 2^31) 到 2,147,483,647 (2^31 - 1) unsigned long 4 字节 0 到 4,294,967,295 (2^32 - 1) 使用细节 各种类型的存储大小与操作系统、系统位数和编译器有关，目前通用的以 64 位系统为主。 C 语言的整型类型，分为有符号 signed 和无符号 unsigned 两种， 默认是 signed。 C 程序中整型常声明为 int 型，除非不足以表示大数，才使用 long long bit(位): 计算机中的最小存储单位。 byte(字节):计算机中基本存储单元。 2.4 浮点类型如 #include stdio.h int main() double salary = 10000.56; double num1 = 1.3; double num2 = 4.5; double sum = num1 + num2; printf(sum = %.2f , sum); printf(sum = %f , sum); return(0);sum = 5.80 sum = 5.800000 类型 存储大小 值范围 精度 float 单精度 4 字节 1.2E-38 到 3.4E+38 6 位小数 double 双精度 8 字节 2.3E-308 到 1.7E+308 15 位小数 注意 关于浮点数在机器中存放形式的简单说明，浮点数 符号位 + 指数位 + 尾数位，浮点数是近似值。 尾数部分可能丢失，造成精度损失。 使用细节 浮点型常量默认为 double 型，声明 float 型常量时，须后加‘f’ 或‘F’ 。 浮点型常量有两种表示形式 十进制数形式： 如：5.12、512.0f、.512 (必须有小数点） 科学计数法形式：如：5.12e2、5.12E-2 通常情况下，应该使用 double 型，因为它比 float 型更精确。 printf(“d1%f “, d1); 在输出时，默认保留 小数点 6 位。 main()int main() //浮点型常量默认为 double 型 ， 声明 float 型常量时， 须后加‘f’ 或‘F’ float d1 = 1.18909095; //从“double” 到“float” 截断, 1.1 是 double float d2 = 1.1f; // 1.1f 就是 float double d3 = 1.3; // ok double d4 = 5.12; double d5 = .512; // 等价 0.512 double d6 = 5.12e2; //等价 5.12 * (10^2) = 512 double d7 = 5.12e-2; // 等价 5.12 * (10^-2) = 5.12 / 100 = 0.0512 //在输出时， 如果%f 默认保留小数点 6 位 printf(d1=%.15f d2=%f d3=%f d4=%f d5=%f d6=%f d7=%f, d1,d2,d3,d4,d5,d6,d7); return(0);d1=1.189090967178345 d2=1.100000 d3=1.300000 d4=5.120000 d5=0.512000 d6=512.000000 d7=0.051200 2.5 字符类型 字符类型可以表示单个字符，字符类型是 char，char 是 1 个字节(可以存字母或者数字) 多个字符称为字符串，在C 语言中 使用 char 数组 表示，数组不是基本数据类型，而是构造类型。 如 int main() char c1 = A; char c2 = 0; char c3 = \\t; printf(c1=%c c3=%c c2=%c, c1, c3, c2); // %c 表示以字符的形式输出 return(0);c1=A c3= c2=0 使用细节 字符常量是用单引号括起来的单个字符。 例如：char c1 ‘a’; char c3 ‘9’; C 中还允许使用转义字符‘\\’ 来将其后的字符转变为特殊字符型常量。例如：char c3 ‘ ’ ; ‘ ’表示换行符 在 C 中，char 的本质是一个整数，在输出时，是 ASCII 码对应的字符。 可以直接给 char 赋一个整数，然后输出时，会按照对应的 ASCII 字符输出 [97]。 char 类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码。 int main() char c1 = a; char c2 = b; //这时当我们以 %c 输出时，就会按照 ASCII 编码表(理解 字符 == 数字 对应关系 ) 对应的 97 对应字符输出 char c3 = 97; int num = c2 + 10; // 98 + 10 = 108 printf(c1=%c c2=%c c3=%c , c1, c2, c3); // c3= a printf(num=%d, num); // 108 return(0);c1=a c2=b c3=a num=108 2.6 布尔类型 C 语言标准(C89)没有定义布尔类型，所以 C 语言判断真假时以 0 为假，非 0 为真。 但这种做法不直观，所以我们可以借助 C 语言的宏定义。 C 语言标准(C99)提供了 _Bool 型， _Bool 仍是整数类型， 但与一般整型不同的是， _Bool 变量只能赋值为 0 或 1，非 0 的值都会被存储为 1。 _ C99 还提供了一个头文件 stdbool.h 定义了 bool 代表_Bool，true 代表 1，false 代表 0。只要导入 stdbool.h，就能方便的操作布尔类型了 , 比如 bool flag false; //宏定义#define BOOL int#define TURE 1#define FALSE 0 int main() int isPass = -1; //定义一个布尔变量 BOOL isOk = TURE; // 等价 int isOK = 0 if(isPass) // 0 表示假， 非 0 表示真 printf(通过考试); if(isOk) printf(ok); return(0); 2.7 基本类型转换当 C 程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换。 数据类型按精度(容量)大小排序（从低到高）： short int unsigned int long unsigned long float double long double 自动转换表 flowchart LRA[Char, short] -- B(int)B -- C[unsigned]C -- D[long]D -- E[double]F[float] -- E[double] 细节说明 有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度最大的那种数据类型，然后再进行计算（如int 型 和 short 型 运算时，先把 short 转成 int 型后再进行运算）。 若两种类型的字节数不同，转换成字节数大的类型，若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型。 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边的类型将转换为左边的类型， 如果右边变量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按四舍五入向前舍入。 int main() //举例 1 char c1 = a; int num1 = c1; // ok double d1 = num1; // ok printf(d1=%f , d1); //ok //举例 2 short s1 = 10; int num2 = 20; int num3 = s1 + num2; //ok printf(num3=%d , num3); //举例 3 float f1 = 1.1f; //ok double d2 = 4.58667435; f1 = d2; // 出现精度损失 (double - float ) printf(f1=%.8f, f1); // 期望： 4.58667435 return(0);d1=97.000000 num3=30 f1=4.58667421 2.8 强制类型转换将精度高的数据类型转换为精度小的数据类型。 使用时要加上强制转换符 ( )，但可能造成精度降低或溢出，格外要注意。 int main() double d1 = 1.934; int num = (int) d1; //这里注意， 不是进行四舍五入， 而是直接截断小数后的部分 printf( num=%d d1=%f , num, d1); // d1 仍然是 double // 强制转换只对最近的数有效, 如果希望针对更多的表达式转换， 使用（） // int num2 = (int) 3.5 * 10 + 6 * 1.5; // 3 * 10 + 6 * 1.5 = 30 + 9.0 = 39.0 int num3 = (int) (3.5 * 10 + 6 * 1.5); // 35.0 + 9.0 = 44.0 - int = 44 printf( num3=%d, num3); // num3 = 44 return(0);num=1 d1=1.934000num3=44 注意 当进行数据的从 精度高 —— 精度低，就需要使用到强制转换。 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级。 char c = a;int i = 5;float d = .314F;double d2 = 1.0;double result = c+i+d; // c+i+d 类型是 float - double okchar result = c+i+d+d2; // 提示? // 警告 double - char 2.9 指针入门指针表示一个地址（存放的是地址）。 int main() int num = 1; //定义一个指针变量， 指针 // 1. int * 表示类型为 指针类型 // 2. 名称 ptr , ptr 就是一个 int * 类型 // 3. ptr 指向了一个 int 类型的变量的地址 int *ptr = num; // num 的地址是多少 // 说明 1：如果要输出一个变量的地址， 使用格式是 %p // 说明 2: num 表示取出 num 这个变量对应地址 printf( num的值=%d num的地址=%p, num, num); // 1.指针变量，本身也有地址 ptr // 2.指针变量, 存放的地址 ptr // 3.获取指针指向的值 *ptr printf( ptr的地址是 %p ptr存放的值是一个地址为 %p ptr 指向的值=%d, ptr, ptr, *ptr); return(0); 简单来说： int num = 1; // 定义了一个值int *ptr = num; // 定义了一个指针，指针存放的是 num的地址ptr 表示 ptr这个指针本身的地址ptr 表示 ptr这个变量存放的那个地址值，也就是num的地址*ptr 表示 ptr存放的地址值上，对应的值，也就是num的值输出格式：像输出地址，格式为 %p像输出数值，格式和数值格式一样，%d等。 细节说明 基本类型，都有对应的指针类型，形式为 数据类型 *，比如 int 的对应的指针就是 int *, float 对应的指针类型就是 float * ，依次类推。 此外还有指向数组的指针、指向结构体的指针，指向共用体的指针， (二级指针， 多级指针)。 2.10 值传递和地址传递C 语言传递参数（或者赋值）可以是值传递（pass by value），也可以传递指针（a pointer passed by value），传递指针也叫地址传递。 默认传递值的类型： 基本数据类型 (整型类型、 小数类型， 字符类型), 结构体, 共用体。 默认传递地址的类似： 指针、 数组。 特点 值传递：将变量指向的存储内容， 在传递赋值时，拷贝一份给接收变量。 地址传递 也叫 指针传递：如果是指针，就将指针变量存储的地址，传递给接收变量，如果是数组， 就将数组的首地址传递给接收变量。 3. 常量 常量是固定值， 在程序执行期间不能改变。 这些固定的值， 又叫做字面量。 常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。 常量的值在定义后不能进行修改。 3.1 经常使用的常量整数常量 整数常量可以是十进制、 八进制或十六进制的常量。 前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合， U 表示无符号整数（unsigned） ， L 表示长整数（long） 。 后缀可以是大写， 也可以是小写， U 和 L 的顺序任意。 85 /* 十进制 */0213 /* 八进制 */0x4b /* 十六进制 */ 八进制和十六进制后面解释30 /* 整数 */30u /* 无符号整数 */30l /* 长整数 */30ul /* 无符号长整数 */ 浮点常量 浮点常量由整数部分、 小数点、 小数部分和指数部分组成。 您可以使用小数形式或者指数形式来表示浮点常量。 3.14159; //double 常量314159E-5; // 科学计数法3.1f; //float 常量 字符常量 字符常量是括在单引号中，例如，’x’ 可以存储在 char 类型的变量中。字符常量可以是一个普通的字符（例如’x’）、一个转义序列（例如 ‘\\t’）。 XYAb1\\t 字符串常量 字符串字面值或常量是括在双引号 “” 中的。 一个字符串包含类似于字符常量的字符： 普通的字符、 转义序列和通用的字符。 可以使用空格做分隔符， 把一个很长的字符串常量进行分行。 hello, world北京hello \\world 3.2 常量的定义 方式一 使用 #define 预处理器。 方式二 使用 const 关键字。 #define PI 3.14 //定义常量 PI 常量值 3.14int main() // PI = 3.1415 可以吗?=》 不可以修改， 因为 PI 是常量 // 可以修改 PI 值? // PI = 3.1415; // 提示 = 左值 必须是可修改的值 double area; double r = 1.2;//半径 area = PI * r * r; printf(面积 : %.2f, area); getchar(); return 0;面积 : 4.52 //1. const 是一个关键字，规定好，表示后面定义了一个常量//2. PI 是常量名，即是一个常量，常量值就是 3.14//3. PI 因为是常量，因此不可以修改//4. const 定义常量时，需要加 分号const double PI = 3.14;int main() //PI = 3.1415 可以吗? = 不可以 double area; double r = 1.2; area = PI * r * r; printf(面积 : %.2f, area); getchar(); return 0; const 和 #define 的区别 const 定义的常量时，带类型，define 不带类型。 const 是在 编译、运行的时候起作用，而 define 是在编译的预处理阶段起作用。 define 只是简单的替换，没有类型检查。简单的字符串替换会导致边界效应。 const 常量可以进行调试的，define 是不能进行调试的，主要是预编译阶段就已经替换掉了， 调试的时候就没它了。 const 不能重定义，不可以定义两个一样的，而 define 通过 undef 取消某个符号的定义，再重新定义。 define 可以配合#ifdef、#ifndef、#endif 来使用，可以让代码更加灵活，比如我们可以通过#define 来 启动或者关闭 调试信息。 #define A 1#define B (A+3) //#define C A/B*3 //// const不能重定义，不可以定义两个一样的，而define通过undef取消某个符号的定义，再重新定义const double PI=3.14;// const double PI=3.145; // 错误#define PI2 3.14#undef PI2 // 取消 PI2 的定义#define PI2 3.145void main() // 分析过程 // #define 就是一个简单的替换!!! // C 其实是 A/A+3*3 = 1/1 + 3 * 3 = 1 + 9 = 10 // C 其实是 A/(A+3)*3 = 1/(1+3) * 3 = 1/4 *3 = ? double d1 = 1.0/4 *3 ; // 0.25 * 3 = 0.75 printf( c=%.2f, C);// 问 c = ? printf( d1=%.2f, d1);c=0.00d1=0.75 // #define DEBUGint main() #ifdef DEBUG //如果定义过 DEBUF printf(ok, 调试信息); #endif #ifndef DEBUG //如果没有定义过 DEBUF printf(hello, 另外的信息); #endif return 0; 4. 运算符4.1 算术运算符算术运算符是对数值类型的变量进行运算的， 在 C 程序中使用的非常多。 运算符 运算 实例 结果 + 加 - 减 * 乘 除 % 取余 ++ a2;b++a;a2;ba++; a3;b3a3;b2 – a2;b–a;a2;ba–; a1;b1a1;b2 细节说明 对于除号“” ， 它的整数除和小数除是有区别的： 整数之间做除法时， 只保留整数部分而舍弃小数部分。 例如： int x 103 ,结果是 3。如果想要保留小数，参与运算数必须有浮点数。 当对一个数取模时， 可以等价 a%ba-ab*b ， 这样我们可以看到 取模的一个本质运算。 当 自增 当做一个 表达式使用时 j ++i 等价 i i + 1; j i; 当 自增 当做一个 表达式使用时 j i++ 等价 j i; i i + 1; //处理的流程 10 / 4 = 2.5 == 截取整数 == 2 = 2.00000double d1 = 10 / 4; //double d2 = 10.0 / 4; //如果希望保留小数， 参与运算数必须有浮点数int res1 = 10 % 3; // 求 10/3 的余数 1int res2 = -10 % 3; // = -10 - (-10) / 3 * 3 = -10- (-3) * 3 = -10 + 9 = -1int res3 = 10 % -3; // 10 - 10 / (-3) * (-3) = 10 - 9 = 1int res4 = -10 % -3; // ? -1 4.2 关系运算符结果只有 false 和 非0 == 等于!= 不等于 小于 大于= 小于等于= 大于等于 4.3 逻辑运算符用于连接多个条件（一般来讲就是关系表达式），最终的结果要么是真(非 0 表示)，要么是假(0 表示) 。 ||! 在进行 操作时, 如果第一个条件为 false ,则后面的条件不在判断； 该现象称为 短路现象， 所以 逻辑与 也称为 短路逻辑与。 4.4 赋值运算符赋值运算符就是将某个运算后的值， 赋给指定的变量。 运算符 描述 效果 + - * % 按位与之后赋值 C2 等同于CC2 ^ 按位异或之后赋值 C^2 等同于CC^2 | 按位或之后赋值 C|2 等同于CC|2 4.5 位运算符位运算符作用于位，并逐位执行操作。 按位与| 按位或^ 按位异或，不一样为1，一样为0~ 按照二进制取反 左移，右边补0 右移，正数左边补0，负数左边补1。也可以直接认为左边补的就是符号位。 4.6 三元运算符条件表达式 ? 表达式 1: 表达式 2;如果条件表达式为非 0 (真)， 运算后的结果是表达式 1；如果条件表达式为 0 (假)， 运算后的结果是表达式 2； 注意细节 表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换), 否则会有精度损失。 三元运算符可以转成 if–else 语句。 4.7 运算符优先级 优先级 运算符 名称或含义 使用形式 结合方向 说明 1 [] 数组下标 数组名[常量表达式] 左到右 () 圆括号 (表达式) 函数名(形参表) . 成员选择（对象） 对象.成员名 - 成员选择（指针） 对象指针-成员名 2 - 负号运算符 -表达式 右到左 单目运算符 (类型) 强制类型转换 (数据类型)表达式 ++ 自增运算符 ++变量名 变量名++ 单目运算符 – 自减运算符 –变量名 变量名– 单目运算符 * 取值运算符 *指针变量 单目运算符 取地址运算符 变量名 单目运算符 ! 逻辑非运算符 !表达式 单目运算符 ~ 按位取反运算符 ~表达式 单目运算符 sizeof 长度运算符 sizeof(表达式) 3 除 表达式 表达式 左到右 双目运算符 * 乘 表达式*表达式 双目运算符 % 余数（取模） 整型表达式%整型表达式 双目运算符 4 + 加 表达式+表达式 左到右 双目运算符 - 减 表达式-表达式 双目运算符 5 左移 变量表达式 左到右 双目运算符 右移 变量表达式 双目运算符 6 大于 表达式表达式 左到右 双目运算符 大于等于 表达式表达式 双目运算符 小于 表达式表达式 双目运算符 小于等于 表达式表达式 双目运算符 7 等于 表达式表达式 左到右 双目运算符 ! 不等于 表达式! 表达式 双目运算符 8 按位与 表达式表达式 左到右 双目运算符 9 ^ 按位异或 表达式^表达式 左到右 双目运算符 10 | 按位或 表达式|表达式 左到右 双目运算符 11 逻辑与 表达式表达式 左到右 双目运算符 12 || 逻辑或 表达式||表达式 左到右 双目运算符 13 ?: 条件运算符 表达式1? 表达式2: 表达式3 右到左 三目运算符 14 赋值运算符 变量表达式 右到左 除后赋值 变量表达式 * 乘后赋值 变量*表达式 % 取模后赋值 变量%表达式 + 加后赋值 变量+表达式 - 减后赋值 变量-表达式 左移后赋值 变量表达式 右移后赋值 变量表达式 按位与后赋值 变量表达式 ^ 按位异或后赋值 变量^表达式 | 按位或后赋值 变量|表达式 15 , 逗号运算符 表达式,表达式,… 左到右 算术运算符 关系运算符 逻辑运算符(逻辑非! 除外) 赋值运算符 逗号运算符 4.8 表示符名命规范C 语言 对各种变量、函数等命名时使用的字符序列称为标识符。 凡是自己可以起名字的地方都叫标识符。 命名规则 由 26 个英文字母大小写， 0-9 ， _或 $ 组成。 数字不可以开头。 不可以使用关键字和保留字，但能包含关键字和保留字。 C 语言中严格区分大小写， 长度无限制。 标识符不能包含空格。 规范 程序中不得出现仅靠大小写区分的相似的标识符 所有宏定义、 枚举常数、 常量(只读变量)全用大写字母命名， 用下划线分隔单词 定义变量别忘了初始化。 定义变量时编译器并不一定清空了这块内存，它的值可能是无效的数据，运行程序，会异常退出。 变量名、函数名：多单词组成时，第一个单词首字母小写， 第二个单词开始每个单词首字母大写。小驼峰。 4.9 关键字被C语言用作特殊用途的字符串 auto、break、case、char、const、continue、default、do、double、else、enum、extern、float、for、goto、if、int、long、register、return、short、signed、sizeof、static、struct、switch、typedef、union、unsigned、void、volatile、while C99标准中有增加了5个 inline、retrict、_Bool、_Complex、_Imaginary C11标准中新增了7个 _Alignas、_Alignof、_Atomic、_Static_assert、_Noreturn、_Thread_local、_Generic 4.10 键盘输入语句步骤 include stdio.h 使用 scanf 函数 使用适当的格式接收 #include stdio.hvoid main() //使用字符数组接收名 char name[10] = ; int age = 0; double sal = 0.0; char gender = ; // 提示用户输入信息 printf(请输入名字： ); // scanf(%s, name) 表示接收 一个字符串， 存放到 name 字符数组 scanf(%s, name); printf(请输入年龄： ); scanf(%d, age); // 因为我们将得到输入存放到 age 变量指向地址,因此需要加 printf(请输入薪水： ); scanf(%lf, sal); // 接收一个 double 时， 格式参数 %lf printf(请输入性别(m/f)： ); scanf(%c, gender); // 这里是接收到了上面的回车字符 scanf(%c, gender); // 等待用户输入. //输 出得到信息 printf( name %s age %d sal %.2f gender %c, name, age,sal,gender); getchar(); // 接收到一个回车 getchar(); // 这个 getchar() 才会让控制台暂停 5. 二进制和位运算5.1 进制int num2 = 210; // 十进制int num3 = 01010; // 八进制int num4 = 0x1010; // 十六进制 5.2 位运算#define DEBUGint main() int a = 12; // 1 向右位移 2 位 , 这里还涉及到二进制中 原码， 反码， 补码 int b = -12; int c = 12; int d = -12; // a,b,c,d,e 结果是多少 printf(a=%d b=%d c=%d d=%d ,a,b,c,d); return 0;标准输出：a=0 b=-1 c=4 d=-4 二进制最高位 表示符号位。0表示正，1表示负。 原码：正数 0000 1111、0000 0001、负数 1000 0001、1000 1111 反码： 0000 1111、0000 0001、 1111 1110、1111 0000 补码： 0000 1111、0000 0001、 1111 1111、1111 0001（就是反码+1） 计算机中存储的都是补码。没有原码和反码，移动的也都是补码。 对于正数好理解、就按照原码移动理解就好了。 对于负数，比如-1，补码是 1111 1111，除去符号位剩下 111 1111，不管右移几位，左边都要补上1，最后加上符号位还是 1111 1111，对应的数还是-1.所以 -1不管左移几位都还是 -1。 计算按位与 按位或等 都是这样的逻辑，用反码算。 6. 程序与流程控制 顺序控制 分支控制 循环控制 6.1 if 分支控制if(条件表达式) // 这是单分支语句 if(条件表达式) // 分支1 else // 分支2 if(条件表达式1) // 分支1 else if(条件表达式2) // 分支2 else if(条件表达式3) // 分支3...else // 分支n 6.2 switch 分支结构switch(表达式) case 常量1: 语句块1; break; case 常量2: 语句块2; break; case 常量3: 语句块3; break; case 常量4: 语句块4; break; default: default语句块1; break; 细节 switch 语句中的 expression 是一个常量表达式， 必须是一个整型(char、 short, int, long 等) 或枚举类型。 case 子句中的值必须是常量，而不能是变量。 default 子句是可选的，当没有匹配的 case 时，执行 default。 break 语句用来在执行完一个 case 分支后使程序跳出 switch 语句块。 如果没有写 break，会执行下一个 case 语句块，直到遇到 break 或者执行到 switch 结尾，这个现象称为穿透。 6.3 for循环控制for(int i = 1;i = 5;i++)\tprintf(hello world, i=%d, i); 使用细节 循环条件是 返回一个表示真(非 0)假(0) 的表达式。 **for(;循环判断条件;)**中的初始化和变量迭代可以不写（写到其它地方），但是两边的分号不能省略。 循环初始值可以有多条初始化语句， 但要求类型一样， 并且中间用逗号隔开， 循环变量迭代也可以有多条变量迭代语句， 中间用逗号隔开。 for(i 0, j 0; j count; i++, j + 2) 6.4 while循环控制int i = 1;while(i 5) printf(hello world, i=%d, i); i++; 6.5 do…while循环控制int i = 1; //循环变量初始化int max = 5; //循环的最大次数do printf( hello，world i=%d, i); //循环体 i++; //循环变量迭代while(i = max); // 循环条件 后面有一个分号，不能省略. 6.6 跳转控制语句break结束循环。 6.7 跳转控制语句continue结束本轮循环。直接开始下一轮循环。只能配合循环语言使用，不能单独和 switchif 使用。 6.8 跳转控制语句goto C 语言的 goto 语句可以无条件地转移到程序中指定的行。 goto 语句通常与条件语句配合使用。可用来实现条件转移，跳出循环体等功能。 在 C 程序设计中一般不主张使用 goto 语句，以免造成程序流程的混乱，使理解和调试程序都产生困难。 goto lable1; //lable1 称为标签printf(ok1 );printf(ok2 );lable1:printf(ok3 );printf(ok4 ); 6.9 跳转控制语句returnreturn 使用在函数，表示跳出所在的函数。 7. 枚举举个例子， 比如： 一星期有 7 天， 请定义数据表示星期一到星期天. // 方式1#define MON 1#define TUE 2#define WED 3#define THU 4#define FRI 5#define SAT 6#define SUN 7 7.1 基本介绍 枚举是 C 语言中的一种构造数据类型，它可以让数据更简洁，更易读, 对于只有几个有限的特定数据，可以使用枚举。 枚举对应英文(enumeration, 简写 enum)。 枚举是一组常量的集合，包含一组有限的特定的数据。 枚举语法定义格式为：enum 枚举名 枚举元素1,枚举元素2,……; int main() enum DAY MON=1, TUE=2, WED=3, THU=4, FRI=5, SAT=6, SUN=7 ; // 这里 DAY 就是枚举类型, 包含了 7 个枚举元素 enum DAY day; // enum DAY 是枚举类型， day 就是枚举变量 day = WED; //给枚举变量 day 赋值， 值就是某个枚举元素 printf(%d, day); // 3 ， 每个枚举元素对应一个值 return 0; 7.2 枚举的遍历C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，枚举类型必须连续是可以实现有条件的遍历。 以下实例使用 for 来遍历枚举的元素 // 遍历枚举元素// day++ 会给出警告， 但是可以运行for (day = MON; day = SUN; day++) // 要求枚举元素是连续赋值 printf(枚举元素： %d , day); 7.3 switch 中使用枚举int main() enum SEASONS SPRING=1, SUMMER, AUTUMN, WINTER; //定义枚举类型 enum SEASONS enum SEASONS season;//定义了一个枚举类型变量 season(类型 enum SEASONS ) printf(请输入你喜欢的季节: (1. spring, 2. summer, 3. autumn 4. winter): ); scanf(%d, season); switch (season) case SPRING: printf(你喜欢的季节是春天); break; case SUMMER: printf(你喜欢的季节是夏天); break; case AUTUMN: printf(你喜欢的季节是秋天); break; case WINTER: printf(你喜欢的季节是冬天); break; default: printf(你没有选择你喜欢的季节); return 0; 使用细节 第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。 我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。 在定义枚举类型时改变枚举元素的值 enum DAY MON, TUE, WED, THU=9, FRI, SAT, SUN // 如果没有给赋值， 就会按照顺序赋值 day; // 表示 定义了一个枚举类型 enum Day ,同时定义了一个变量 day(类型是 enum DAY)// 说明 FRI, SAT, SUN 就是 10, 11, 12 枚举类型的 三种定义方式。 enum DAY MON=1, TUE, WED, THU, FRI, SAT, SUN ; enum DAY day; 2. ~~~ c enum DAY MON=1, TUE, WED, THU, FRI, SAT, SUN day; enum MON=1, TUE, WED, THU, FRI, SAT, SUN day; // 这样使用枚举， 该枚举类型只能使用一次. 4. 不能直接将一个整数，赋给枚举变量，但是可以将整数，转成枚举类型，再赋给枚举变量. ~~~ c enum SEASONS SPRING=1, SUMMER, AUTUMN, WINTER; enum SEASONS season; int n = 4; season = (enum SEASONS) n; printf(season=:%d,season); 标准输出：season=:4 8. 函数 为完成某一功能的程序指令(语句)的集合，称为函数。 在 C 语言中，函数分为：自定义函数、系统函数(查看 C 语言函数手册) 函数还有其它叫法，比如方法等，我们统一称为 函数。 8.1 函数的定义返回类型 函数名(形参列表)\t执行语句;\treturn 返回值; // 如果 返回类型为void 可以没有返回值double cal(int n1, int n2) double res = 0.0;\tres = n1 + n2\treturn res;int main() int num1 = 10; //第一个数 int num2 = 20; //第二个数\treturn cal(num1, num2); 8.2 头文件在实际的开发中，我们往往需要在不同的文件中，去调用其它文件的定义的函数， 比如 hello.c 中，去使用myfuns.c 文件中的函数。 头文件 头文件是扩展名为 .h的文件， 包含了C 函数声明和宏定义， 被多个源文件中引用共享。 有两种类型的头文件：程序员编写的头文件和 C 标准库自带的头文件。 在程序中要使用头文件，需要使用C 预处理指令 #include来引用它。 前面我们已经看过 stdio.h 头文件，它是C 标准库自带的头文件。 #include 叫做文件包含命令， 用来引入对应的头文件（.h 文件）。#include 也是 C 语言预处理命令的一种。#include 的处理过程很简单， 就是将头文件的内容插入到该命令所在的位置， 从而把头文件和当前源文件连接成一个源文件， 这与复制粘贴的效果相同。 建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。 如 myfun.c #include stdio.hint myCal(int n1, int n2, char oper) //定义一个变量 res ,保存运算的结果 double res = 0.0; switch(oper) case + : res = n1 + n2; break; case -: res = n1 - n2; break; case *: res = n1 * n2; break; case /: res = n1 / n2; break; default : printf(你的运算符有误~); printf( %d %c %d = %.2f , n1, oper, n2, res); return res;void sayHello() //定义函数 printf(say Hello); myfun.h #include stdio.h// 声明函数int myCal(int n1, int n2, char oper);void sayHello(); hello.c #include stdio.h//引入我们需要的头文件(用户头文件)#include myfun.hvoid main() //使用 myCal 完成计算任务 int n1 = 10; int n2 = 50; char oper = -; double res = 0.0; //调用 myfun.c 中定义的函数 myCal res = myCal(n1, n2, oper); printf( res=%.2f, res); sayHello(); getchar(); 使用细节 引用头文件相当于复制头文件的内容。 源文件的名字 可以不和头文件一样，但是为了好管理，一般头文件名和源文件名一样。 C 语言中 include 与 include “” 的区别 include ：引用的是编译器的类库路径里面的头文件，用于引用系统头文件。 include “”：引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件，用于引用用户头文件。 引用系统头文件，两种形式都会可以，include 效率高。引用用户头文件，只能使用 include “”。 一个 #include 命令只能包含一个头文件，多个头文件需要多个 #include 命令。 同一个头文件如果被多次引入，多次引入的效果和一次引入的效果相同，因为头文件在代码层面有防止重复引入的机制。 在一个被包含的文件(.c)中又可以包含另一个文件头文件(.h) 不管是标准头文件，还是自定义头文件，都只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误。 8.3 函数细节 函数的形参列表可以是多个。 C 语言传递参数可以是值传递（pass by value） ， 也可以传递指针（a pointer passed by value） 也叫引用传递。 函数的命名遵循标识符命名规范，首字母不能是数字，可以采用 驼峰法 或者 下划线法。 函数中的变量是局部的，函数外不生效。 基本数据类型默认是值传递的， 即进行值拷贝。在函数内修改，不会影响到原来的值。 // 基本数据类型默认是值传递的， 即进行值拷贝。 在函数内修改， 不会影响到原来的值void f2(int n) n++; printf( f2中的n=%d, n); // n=10void main() //函数中的变量是局部的， 函数外不生效 //printf(num=%d, num); int n = 9; f2(n); printf( main 函数中 n=%d, n); // 9 getchar(); 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址，函数内以指针的方式操作变量。从效果上看类似引用(即传递指针) // 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址，// 函数内以指针的方式操作变量。 从效果上看类似引用(即传递指针)void f3(int *p) (*p)++; // 修改会对函数外的变量有影响void main() // 函数中的变量是局部的， 函数外不生效 // printf(num=%d, num); int n = 9; f3(n); printf( main 函数中 n=%d, n); //10 getchar(); C 语言 不支持函数重载。 C 语言支持可变参数函数。 #include stdio.h#include stdarg.h// 说明// num 表示传递的参数格式// ... 表示可以传递多个参数和 num 一致即可int fun(int num, ...) // 可变函数， 即参数的个数可以不确定, 使用... 表示 int i, totalSum=0; // totalSum 一定要初始化 int val = 0; va_list v1; // v1 实际是一个字符指针，从头文件里可以找到 va_start(v1, num); // 使 v1 指向可变列表中第一个值， 即 num 后的第一个参数 printf(*v = %d , *v1); for(i = 0; i num; i++) //num 减一是为了防止下标超限 val = va_arg(v1, int); // 该函数返回 v1 指向的值， 并使 v1 向下移动一个 int 的距离， 使其指向下一个 int printf(val = %d , val); // val = 10 val=30 val=60 totalSum += val; va_end(v1); //关闭 v1 指针， 使其指向 null return totalSum; void main() int res = fun(8, 10,30,60, -100,1,5,7,98); printf(和是=%d, res); getchar(); 8.4 函数参数的传递方式C 语言传递参数可以是值传递（pass by value） ， 也可以传递指针（a pointer passed by value） 也叫传递地址或者 引用传递。 其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的数据大小，数据越大，效率越低。 值传递和引用传递使用特点 值传递：变量直接存储值，内存通常在栈中分类。 默认是值传递的数据类型有：1. 基本数据类型；2. 结构体；3. 共用体；4. 枚举。 引用传递：变量存储的是一个地址，这个地址对应的空间才真正存储数据（值）。 默认是引用传递的数据类型有：指针和数组。 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址，函数内以指针的方式操作变量(*指针)。从效果上看类似引用，比如修改结构体的属性。 8.5 变量作用域所谓变量作用域（Scope），就是指变量的有效范围。 函数内部声明定义的局部变量，作用域仅限于函数内部。 函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用局部变量(编译器使用就近原则)。 在一个代码块，比如 for if 中 的局部变量，那么这个变量的的作用域就在该代码块。 在所有函数外部定义的变量叫全局变量，作用域在整个程序有效。 初始化 局部变量，系统不会对其默认初始化，必须对局部变量初始化后才能使用，否则，程序运行后可能会异常退出。 全局变量，系统会自动对其初始化，如下所示。 int 0 char ‘\\0’ float 0.0 double 0.0 pointer指针 NULL 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。 使用细节 全局变量(Global Variable)保存在内存的全局存储区中，占用静态的存储单元，它的作用域默认是整个程序，也就是所有的代码文件，包括源文件（.c 文件）和头文件（.h 文件）。 局部变量(Local Variable)保存在栈中，函数被调用时才动态地为变量分配存储单元，它的作用域仅限于函数内部。 C 语言规定，只能从小的作用域向大的作用域中去寻找变量，而不能反过来。 在同一个作用域，变量名不能重复，在不同的作用域，变量名可以重复，使用时编译器采用就近原则。 由**{ }包围的代码块也拥有独立的作用域**。 8.6 static关键字static 关键字在 c 语言中比较常用，使用恰当能够大大提高程序的模块化特性，有利于扩展和维护。 局部变量使用 static 修饰 局部变量被 static 修饰后，我们称为静态局部变量。 对应静态局部变量在声明时未赋初值，编译器也会把它初始化为 0。 静态局部变量存储于进程的静态存储区(全局性质)，只会被初始一次，即使函数返回，它的值也会保持不变。 void fn(void) int n = 10; //普通变量, 每次执行都会初始化， n 在栈区 printf(n=%d , n); n++; printf(n++=%d , n); void fn_static(void) static int n = 10; //静态局部变量， 放在静态存储区， 全局性质空间 printf( static n=%d , n); // 10 n++; // n = 11 printf( n++=%d , n); // 11 int main(void) fn_static(); fn_static(); return 0;标准输出： // 可以看出 第二次运行的初始化 并没有成功static n=10 n++=11static n=11 n++=12 全局变量使用 static 修饰 普通全局变量对整个工程可见，其他文件可以使用 extern 外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了。静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。 定义不需要与其他文件共享的全局变量时，加上 static 关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。 file01.c#include stdio.h // 在一个文件中， 使用另外一个文件的全局变量, 使用 extern 引入即可extern int num;// extern int num2; 不可以int num2 = 60;void main() printf( num=%d num2=%d, num, num2); getchar();file02.cint num = 10; // 普通全局变量static int num2 = 20; // 静态全局变量, 只能在本文件中使用， 而不能在其它文件使用 函数使用 static 修饰 函数的使用方式与全局变量类似，在函数的返回类型前加上 static，就是静态函数。 非静态函数可以在另一个文件中通过 extern 引用。 静态函数只能在声明它的文件中可见，其他文件不能引用该函数。 不同的文件可以使用相同名字的静态函数，互不影响。 8.7 字符串中常用的系统函数头文件 string.h 得到字符串的长度\tsize_t strlen(const char *str) 拷贝字符串 char *strcpy(char *dest, const char *src) 把 src 所指向的字符串复制到 dest。 连接字符串 char *strcat(char *dest, const char *src) 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。 #include stdlib.h#include string.hint main(void) char src[50] = abc; char dest[50]; // 定义了两个字符数组(字符串) , 大小为 50 char * str = abcdff; printf(str.len=%d , strlen(str)); // 统计字符串的大小 // 表示将 hello 拷贝到 src // 注意， 拷贝字符串会将原来的内容覆盖 strcpy(src, hello); printf(\\s src=%s , src); strcpy(dest, world ); //strcat 是将 src 字符串的内容连接到 dest ,但是不会覆盖 dest 原来的内容， 而是连接!! strcat(dest, src); // hello 尚硅谷 printf(最终的目标字符串： dest=%s , dest); return 0;标准输出：str.len=6 s src=hello 最终的目标字符串： dest=world hello 8.8 时间和日期相关函数头文件 time.h 获取当前时间 char *ctime(const time_t *timer) 返回一个表示当地时间的字符串， 当地时间是基于参数 timer。 编写一段代码来统计 函数 test 执行的时间 double difftime(time_t time1, time_t time2)返回 time1 和 time2 之间相差的秒数 (time1-time2)。 #include stdlib.h#include time.hvoid test() // 运行 test 函数， 看看执行花费时间 int i = 0; int sum = 0; int j = 0; for(i = 0; i 77777777;i++) sum = 0; for (j = 0; j 10;j++) sum += j; int main(void) time_t curtime; // time_h 是一个结构体类型 time(curtime); // time() 完成初始化 // ctime 返回一个表示当地时间的字符串， 当地时间是基于参数 timer printf(当前时间 = %s, ctime(curtime)); //先得到执行 test 前的时间 time_t start_t, end_t; double diff_t; //存放时间差 printf(程序启动... ); time(start_t); //初始化得到当前时间 test(); //执行 test //再得到执行 test 后的时间 time(end_t);//得到当前时间 diff_t = difftime(end_t, start_t); //时间差， 按秒 ent_t - start_t //然后得到两个时间差就是耗用的时间 printf(执行 test()函数 耗用了%.2f 秒, diff_t); return 0;标准输出：当前时间 = Wed Sep 7 10:05:00 2022程序启动...执行 test()函数 耗用了1.00 秒 8.9 数学相关函数math.h 头文件定义了各种数学函数和一个宏。 在这个库中所有可用的功能都带有一个 double 类型的参数， 且都返回 double 类型的结果。 double exp(double x) 返回 e 的 x 次幂的值 double log(double x) 返回 x 的自然对数（基数为 e 的对数） double pow(double x, double y) 返回 x 的 y 次幂。 double sqrt(double x) 返回 x 的平方根 double fabs(double x) 返回 x 的绝对值。 #include math.hint main(void) double d1 = pow(2.0,3.0); double d2 = sqrt(5.0); printf(d1=%.2f, d1); printf(d2=%.2f, d2); return 0; 8.10 基本数据类型和字符串类型的转换我们经常需要将基本数据类型转成字符串类型(即 char 数组 )。 或者将字符串类型转成基本数据类型。 sprintf 函数的用法 sprintf 和平时我们常用的 printf 函数的功能很相似。sprintf 函数打印到字符串中，而 printf 函数打印输出到屏幕上。sprintf 函数在我们完成其他数据类型转换成字符串类型的操作中应用广泛。 该函数包含在 stdio.h 的头文件中。 基本类型转字符串类型 #include stdio.hint main(void) char str1[20]; // 字符数组， 即字符串 char str2[20]; char str3[20]; int a = 20984, b = 48090; double d = 14.309948; // 说明 // 1. sprintf 是一个系统函数， 可以将结果存放到字符串中 // 2. 格式化的结果， 会存放到 str1 中 sprintf(str1, %d %d, a, b); sprintf(str2, %.2f, d); sprintf(str3, %8.2f, d); // %8.2f 含义是格式化后， 一共有 8 位， 小数点后占用 2 位， 不够用空格占位 printf(str1=%s str2=%s str3=%s, str1, str2, str3); return 0;标准输出：str1=20984 48090 str2=14.31 str3= 14.31 字符串类型转基本数据类型 #include stdio.hint main(void) // 字符数组 char str[10] = 123456; char str2[10] = 12.67423; char str3[3] = ab; char str4[4] = 111; // 说明 // 1. atoi(str) 将 str 转成整数 int num1 = atoi(str); short s1 = atoi(str4); // 说明 // 1. atof(str2); 将 str2 转成小数 double d = atof(str2); // 说明 // 1. str3[0] 表示获取到 str3 这个字符串(数组)的第一个元素 a char c = str3[0]; printf(num1=%d d=%f c=%c s1=%d, num1, d, c, s1);// return 0;标准输出：num1=123456 d=12.674230 c=a s1=111 注意事项 在将 char 数组 类型转成 基本数据类型时，要确保能够转成有效的数据，比如 我们可以把 “123” , 转成一个整数，但是不能把 “hello” 转成一个整数。 如果格式不正确，会默认转成 0 或者 0.0。 9. 预处理命令 使用库函数之前，应该用 #include 引入对应的头文件。这种以#号开头的命令称为预处理命令。 这些在编译之前对源文件进行简单加工的过程，就称为预处理（即预先处理、 提前处理） 预处理主要是处理以#开头的命令， 例如#include stdio.h等。 预处理命令要放在所有函数之外， 而且一般都放在源文件的前面。 预处理是 C 语言的一个重要功能，由预处理程序完成。当对一个源文件进行编译时，系统将自动调用预处理程序对源程序中的预处理部分作处理， 处理完毕自动进入对源程序的编译。 C 语言提供了多种预处理功能，如宏定义、文件包含、条件编译等，合理地使用它们会使编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。 9.1 预处理命令快速入门 要求 开发一个 C 语言程序，让它暂停 5 秒以后再输出内容 “helllo, 尚硅谷!~”，并且要求跨平台，在 Windows 和Linux 下都能运行，如何处理。 Windows 平台下的暂停函数的原型是 void Sleep(DWORD dwMilliseconds)，参数的单位是“ 毫秒” ，位于 windows.h 头文件。 Linux 平台下暂停函数的原型是 unsigned int sleep (unsigned int seconds)， 参数的单位是“秒” ， 位于 unistd.h 头文件。 #if、 #elif、 #endif 就是预处理命令， 它们都是在编译之前由预处理程序来执行的。 #if _WIN32 //如果是 windows 平台, 就执行 #include windows.h #include windows.h#elif __linux__ //否则判断是不是 linux ,如果是 linux 就引入unistd.h #include unistd.h#endifint main() // 不同的平台下调用不同的函数 #if _WIN32 // 识别 windows 平台 Sleep(5000); //毫秒 #elif __linux__ //识别 linux 平台 sleep(5); //秒 #endif puts(hello, world~); //输出 getchar(); return 0; 9.2 C 语言宏定义 基本介绍 #define 叫做宏定义命令，它也是 C 语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。 宏定义的形式 #define 宏名 字符串 #表示这是一条预处理命令，所有的预处理命令都以 # 开头。宏名是标识符的一种，命名规则和变量相同。字符串可以是数字、表达式、if 语句、函数等。 这里所说的字符串是一般意义上的字符序列，不要和 C 语言中的字符串等同，它不需要双引号。 程序中反复使用的表达式就可以使用宏定义。 注意细节 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单的替换。字符串中可以含任何字符，它可以是常数、表达式、if 语句、函数等，预处理程序对它不作任何检查， 如有错误，只能在编译已被宏展开后的源程序时发现。 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef 命令。 代码中的宏名如果被引号包围， 那么预处理程序不对其作宏代替。 #include stdio.h#define OK 100int main() printf(OK ); return 0; 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。 习惯上宏名用大写字母表示， 以便于与变量区别。 但也允许用小写字母。 可用宏定义表示数据类型， 使书写方便。 宏定义表示数据类型和用 typedef 定义数据说明符的区别：宏定义只是简单的字符串替换，由预处理器来处理；而 typedef 是在编译阶段由编译器处理的， 它并不是简单的字符串替换， 而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。 9.3 带参数的宏定义 C 语言允许宏带有参数。在宏定义中的参数称为“形式参数” ，在宏调用中的参数称为“实际参数” ，这点和函数有些类似。 对带参数的宏， 在展开过程中不仅要进行字符串替换， 还要用实参去替换形参。 带参宏定义的一般形式为 #define 宏名(形参列表) 字符串 ,在字符串中可以含有各个形参。 带参宏调用的一般形式为 : 宏名(实参列表) // 说明// 1. MAX 就是带参数的宏// 2. (a,b) 就是形参// 3. (ab) ? a : b 是带参数的宏对应字符串， 该字符串中可以使用形参#define MAX(a,b) (ab) ? a : bint main() int x , y, max; printf(input two numbers: ); scanf(%d %d, x, y); // 说明 // 1. MAX(x, y); 调用带参数宏定义 // 2. 在宏替换时(预处理， 由预处理器)， 会进行字符串的替换， 同时会使用实参， 去替换形参 // 3. 即 MAX(x, y) 宏替换后 (xy) ? x : y max = MAX(x, y); printf(max=%d , max); return 0;标准输出：input two numbers: max=32764 使用细节 带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现。 #define MAX(a,b) (ab)?a:b 如果写成了#define MAX (a, b) (ab)?a:b 在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。 在宏定义中，字符串内的形参通常要用括号括起来以避免出错。 #define SQ(y) (y)*(y) 带参宏定义,字符串内的形参通常要用括号括起来以避免出错 9.4 带参宏定义和函数的区别 宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。 函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。 9.5 预处理命令总结 指令 说明 # 空指令， 无任何效果 #include 包含一个源代码文件 #define 定义宏 #undef 取消已定义的宏 #if 如果给定条件为真， 则编译下面代码 #ifdef 如果宏已经定义， 则编译下面代码 #ifndef 如果宏没有定义， 则编译下面代码 #elif 如果前面的#if 给定条件不为真， 当前条件 为真， 则编译下面代码 #endif 结束一个#if……#else 条件编译块 注意事项 预处理功能是 C 语言特有的功能， 它是在对源程序正式编译前由预处理程序完成的， 程序员在程序中用预处理命令来调用这些功能。 宏定义可以带有参数，宏调用时是以实参代换形参，而不是“值传送” 。 为了避免宏代换时发生错误，宏定义中的字符串应加括号，字符串中出现的形式参数两边也应加括号。 文件包含是预处理的一个重要功能，它可用来把多个源文件连接成一个源文件进行编译，结果将生成一个目标文件。 条件编译允许只编译源程序中满足条件的程序段，使生成的目标程序较短，从而减少了内存的开销并提高了程序的效率。 使用预处理功能便于程序的修改、阅读、移植和调试，也便于实现模块化程序设计 10. 数组数组可以存放多个同一类型数据。数组也是一种数据类型，是构造类型。传递是以引用的方式传递(即传递的是地址) 10.1 数组定义 数据类型 数组名 [数组大小]; 如 int a[5] 赋初值 a[0] 1; a[1] 30; 内存 数组名 就代表 该数组的首地址， 即 a[0]地址。 数组的各个元素是连续分布的 假如 a[0] 地址 0x1122 a[1] 地址 a[0]的地址 + int 字节数(4) 0x1122 + 4 0x1126 a[2] 地址 a[1]地址 + int 字节数(4) 0x1126 + 4 0x112A 访问：数组名[下标] 三种初始化方式 int main() // 方式 int arr1[3]; arr1[0] = 100; arr1[1] = 200; arr1[2] = 300; // 方式2 int arr2[3] = 4, 5, 6; // 方式3 int arr3[] = 7, 8, 9, 10; for (int i = 0; i sizeof(arr3) / sizeof(int); i++) printf(%d, arr3[i]); return 0; 使用细节 数组是多个相同类型数据的组合，一个数组一旦声明定义了，其长度是固定的，不能动态变化。 数组创建后，如果没有赋值，则遵守如下规则。 全局数组默认值 0 非全局数组初值是机器垃圾值(即： 原来系统分配给这块空间的值) 使用数组的步骤 1. 定义数组 2 给数组各个元素赋值 3 使用数组, 也可以一步到位 C 的数组属构造类型，是引用传递(传递的是地址)，因此当把一个数组传递给一个函数时或者变量，函数变量操作数组会影响到原数组。 10.2 字符数组与字符串用来存放字符的数组称为字符数组。 char a[10]; 一维字符数组, 长度为 10 char b[5][10]; 二维字符数组 char c[20]=c, , p, r, o, g, r, a,m; 给部分数组元素赋值 字符数组实际上是一系列字符的集合，也就是字符串（String）。在 C 语言中，没有专门的字符串变量，没有string 类型，通常就用一个字符数组来存放一个字符串。 在 C 语言中，字符串实际上是使用 null 字符 (‘\\0’) 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 ‘\\0’ 是 ASCII 码表中的第 0 个字符，用 NUL 表示，称为空字符。该字符既不能显示，也不是控制字符，输出该字符不会有任何效果，它在 C 语言中仅作为字符串的结束标志。 如果在给某个字符数组赋值时， 赋给的元素的个数小于该数组的长度，则会自动在后面加 ‘\\0’，表示字符串结束。 赋给的元素的个数等于该数组的长度，则不会自动添加 ‘\\0’ int main() // c 是一个一维字符数组， 给部分元素赋值 char c[7]=t,o,m; char str[4] = a,b,d,\\0; char str2[] = j,a,c,k; // 这个后面系统也不会自动添加 \\0 // 输出 c , 系统会这样处理 //1. 从第一个字符开始输出， 直到遇到 \\0 , 表示该字符串结束 printf( c=%s, c); // tom printf( str=%s, str); // abc（最后一个结束符不会输出） printf( str2=%s, str2); // jack 乱码（乱码直到碰到结束符为止） return 0;标准输出： c=tomstr=abdstr2=jackabd 访问和遍历 因为字符串的本质就是字符数组，因此可以按照数组的方式遍历和访问某个元素即可。 int main() char greeting[] = Hello; int i; int len = strlen(greeting); // len = 5 printf( greeting=%s, greeting); printf( len=%d, len); //5 printf( 字符串第 3 个字符是=%c, greeting[2]); //l printf( ); for(i = 0; i len; i++) //遍历 printf(%c , greeting[i]); //H e l l o return 0;标准输出： greeting=Hellolen=5字符串第 3 个字符是=lH e l l o 10.3 字符串的表示形式 两种表示形式 用字符数组存放一个字符串 char str[] = hello tom; char str2[] = h, e; 用字符指针指向一个字符串 char* pStr = hello tom; C 语言对字符串常量” hello tom”是按字符数组处理的，在内存中开辟了一个字符数组用来存放字符串常量，程序在定义字符串指针变量 pStr 时只是把字符串首地址（即存放字符串的字符数组的首地址） 赋给 pStr。 printf(%s ,pStr); 可以输出 str 指向的字符串 区别 字符数组由若干个元素组成，每个元素放一个字符；而字符指针变量中存放的是地址（字符串字符数组的首地址），绝不是将字符串放到字符指针变量中（是字符串首地址） 对字符数组只能对各个元素赋值，不能用char str[14]; str=hello tom;对字符数组赋值。 对字符指针变量，采用下面方法赋值，是可以的char* a=yes; a= hello tom; 如果定义了一个字符数组，那么它有确定的内存地址(即字符数组名是一个常量)；而定义一个字符指针变量时，它并未指向某个确定的字符数据，并且可以多次赋值。 10.4 字符串相关函数 strcpy(s1, s2) 复制字符串S2到S1 strcat(s1, s2) 链接字符串S2到字符串S1的末尾 strlen(s1) 返回字符串S1的长度 strcmp(s1, s2) 如果S1和S2是相同的，则返回0，如果S1S2则返回小于0，如果S1S2返回大于0 strchr(s1, ch) 返回一个指针，指向字符串S1中字符ch第一次出现的位置 strstr(s1, s2) 返回一个指针，指向字符串S1中字符串S2第一次出现的位置 #include string.hint main() char str1[12] = Hello; char str2[12] = World; char str3[12]; int len ; /* 复制 str1 到 str3 */ strcpy(str3, str1); // str3 内容 Hello printf(strcpy( str3, str1) : %s , str3 ); //Hello /* 连接 str1 和 str2 */ strcat( str1, str2); printf(strcat( str1, str2): %s , str1 ); //HelloWorld /* 连接后， str1 的总长度 */ len = strlen(str1);// printf(strlen(str1) : %d , len );//10 return 0;标准输出：strcpy( str3, str1) : Hello strcat( str1, str2): HelloWorldstrlen(str1) : 10 使用注意事项和细节 程序中往往依靠检测 ‘\\0’ 的位置来判定字符串是否结束，而不是根据数组的长度来决定字符串长度。 因此，字符串长度不会统计 ‘\\0’, 字符数组长度会统计。 在定义字符数组时应估计实际字符串长度，保证数组长度始终大于字符串实际长度，否则，在输出字符数组时可能出现未知字符。 系统对字符串常量也自动加一个’\\0’作为结束符。例如”C Program” 共有 9 个字符，但在内存中占 10 个字节，最后一个字节’\\0’是系统自动加上的。 定义字符数组时，如果给的字符个数比数组的长度小，则系统会默认将剩余的元素空间，全部设置为 ‘\\0’, 比如 char str[6] “ab” , str 内存布局就是[a][b][\\0][\\0][\\0][\\0]。 字符数组定义和初始化的方式比较多 char str1[ ] = I am happy; // 默认后面加 \\0char str2[ ] = I am happy; // 省略号 ,默认后面加 \\0char str3[ ] = I, ,a,m, ,h,a,p,p,y; // 字符数组后面不会加 \\0, 可能有乱码char str4[5] = C,h,i,n,a; //字符数组后面不会加 \\0, 可能有乱码char * pStr = hello; //ok 11. 排序和查找11.1 冒泡排序//冒泡排序的函数void bubbleSort(int arr[], int arrLen) //因为每轮排序几乎一样， 因此， 我们可以使用 for 循环处理 int j,i; int t;//临时变量 for(i=0; i arrLen - 1; i++) for(j = 0; j arrLen-1-i; j++) //如果前面的数大于后面的数， 就交换 if(arr[j] arr[j+1]) t = arr[j]; arr[j] = arr[j+1]; arr[j+1] = t; int main() int arr[] = 3, 9, -1, 10, -2,-11 ; int arrLen = sizeof(arr) / sizeof(int); // 通过计算得到 int j; bubbleSort(arr, arrLen); // 数组默认是地址传递(指针) printf( 排序后(函数) ); for(j= 0; j arrLen; j++) printf(%d , arr[j]); return 0; 11.2 二分查找int seqSearch(int arr[], int arrLen, int val) int i; for(i = 0; i arrLen; i++) if(arr[i] == val) return i; // 如果在 for 循环中， 没有执行到 return ,说明没有找到 return -1;int main() // 有一个数列： 23， 1， 34,89， 101 // 猜数游戏： 从键盘中任意输入一个数， 判断数列中是否包含该数【顺序查找】 要求: 如果找到了， // 就提示找到， 并给出下标值, 找不到提示 没有。 // 分析思路 // 1. 安装数组进行遍历， 一个一个的比较， 如果相等， 则找到 int arr[] = 23, 1, 34, 89, 101; int arrLen = sizeof(arr) / sizeof(int); int index = seqSearch(arr, arrLen, 101); if (index != -1) //找到 printf(找到 下标为 %d, index); else printf(没有找到); return 0; 11.3 多维数组-二维数组使用方式1 类型 数组名[大小][大小];比如：比如: int a[2][3]; 二维数组在内存的存在形式，各个元素的地址是连续分布的，即在前一个元素基础上。 int main() int a[4][6]; // 没有初始化， 则是分配的内存垃圾值 int i, j; //全部初始化 0 for(int i = 0; i 4; i++) //先遍历行 for(int j = 0; j 6; j++) //遍历列 a[i][j] = 0; //看看二维数组的内存布局 printf( 二维数组 a 的首地址=%p, a); printf( 二维数组 a[0]的地址=%p, a[0]); printf( 二维数组 a[0][0]的地址=%p, a[0][0]); printf( 二维数组 a[0][1]的地址=%p, a[0][1]); //将二维数组的各个元素得地址输出 printf( ); for(i = 0; i 4; i++) printf(a[%d]的地址=%p , i, a[i]); for(j=0; j 6; j++) printf(a[%d][%d]的地址=%p , i, j , a[i][j]); printf( ); return 0;标准输出： 二维数组 a 的首地址=0x7ffdc984fb40 二维数组 a[0]的地址=0x7ffdc984fb40 二维数组 a[0][0]的地址=0x7ffdc984fb40 二维数组 a[0][1]的地址=0x7ffdc984fb44a[0]的地址=0x7ffdc984fb40 a[0][0]的地址=0x7ffdc984fb40 a[0][1]的地址=0x7ffdc984fb44 a[0][2]的地址=0x7ffdc984fb48 a[0][3]的地址=0x7ffdc984fb4c a[0][4]的地址=0x7ffdc984fb50 a[0][5]的地址=0x7ffdc984fb54 a[1]的地址=0x7ffdc984fb58 a[1][0]的地址=0x7ffdc984fb58 a[1][1]的地址=0x7ffdc984fb5c a[1][2]的地址=0x7ffdc984fb60 a[1][3]的地址=0x7ffdc984fb64 a[1][4]的地址=0x7ffdc984fb68 a[1][5]的地址=0x7ffdc984fb6c a[2]的地址=0x7ffdc984fb70 a[2][0]的地址=0x7ffdc984fb70 a[2][1]的地址=0x7ffdc984fb74 a[2][2]的地址=0x7ffdc984fb78 a[2][3]的地址=0x7ffdc984fb7c a[2][4]的地址=0x7ffdc984fb80 a[2][5]的地址=0x7ffdc984fb84 a[3]的地址=0x7ffdc984fb88 a[3][0]的地址=0x7ffdc984fb88 a[3][1]的地址=0x7ffdc984fb8c a[3][2]的地址=0x7ffdc984fb90 a[3][3]的地址=0x7ffdc984fb94 a[3][4]的地址=0x7ffdc984fb98 a[3][5]的地址=0x7ffdc984fb9c 使用方式2 类型 数组名[大小][大小] = 值 1,值 2..,值 1,值 2..,值 1,值 2..; 类型 数组名[大小][大小] = 值 1,值 2,值 3,值 4,值 5,值 6 ..; int main() int map[3][3] = 0,0,1,1,1,1,1,1,3; // 遍历 // 先得到行 // 1. sizeof(map) 得到这个 map 数组的大小 9 * 4 = 36 // 2. sizeof(map[0]) 得到 map 中， 第一行有多大 3 * 4 = 12 int rows = sizeof(map) / sizeof(map[0]); // 3 // 得到列 int cols = sizeof(map[0]) / sizeof(int); // 12 / 4 = 3 int i,j, sum=0; for(i = 0; i rows; i++) for(j = 0; j cols; j++) printf(%d , map[i][j]); sum += map[i][j]; //累计到 sum printf( ); printf( sum=%d, sum); return 0; 使用细节 可以只对部分元素赋值，未赋值的元素自动取“零” 值。 如果对全部元素赋值，那么第一维的长度可以不给出。 二维数组可以看作是由一维数组嵌套而成的；如果一个数组的每个元素又是一个数组，那么它就是二维数组。 12. 指针 指针，也就是内存的地址；所谓指针变量，也就是保存了内存地址的变量。 获取变量的地址，用，比如：int num 10，获取 num 的地址：num。 指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值。 比如：int *ptr = num; ptr 就是指向 int 类型的指针变量，即 ptr 是 int * 类型。 获取指针类型所指向的值，使用：*(取值符号)，比如：int * ptr，使用 *ptr 获取 ptr 指向的值。 int *ip; 一个整型的指针 double *dp; 一个 double 型的指针float *fp; 一个浮点型的指针char *ch; 一个字符型的指针 12.1 指针的算术运算指针是一个用数值表示的地址。可以对指针执行算术运算。可以对指针进行四种算术运算：++、 –、 +、 -。 当对指针进行++时，指针会按照它指向的数据类型字节数大小增加，比如 int * 指针，每++ ，就增加 4 个字节。 const int MAX = 3; // 常量int main() int var[] = 10, 100, 200; // int 数组 int i, *ptr; // ptr 是一个 int* 指针 ptr = var; // ptr 指向了 var 数组的首地址 for ( i = 0; i MAX; i++) printf(var[%d] 地址= %p , i, ptr ); printf(存储值： var[%d] = %d , i, *ptr ); ptr++;// ptr = ptr + 1(1 个 int 字节数); ptr 存放值+4 字节(int) return 0;标准输出：var[0] 地址= 0x7fff2cdffde4 存储值： var[0] = 10var[1] 地址= 0x7fff2cdffde8 存储值： var[1] = 100var[2] 地址= 0x7fff2cdffdec 存储值： var[2] = 200/* 指针中最后一个元素的地址 */ptr = var[MAX-1]; // var[2]ptr--; 如果是 ptr + 2；那就是一次增加8个字节（2个int类型的空间）。减法同理。 12.2 指针的比较指针可以用关系运算符进行比较，如 、 、 和 、。 int main() int var[] = 10, 100, 200; int *ptr; ptr = var; // ptr 指向 var 首地址(第一个元素) // if(ptr == var[0]) //错误,类型不一样 (int *) 和 (int ) // printf(ok1); // if(ptr == var[0]) // 可以 printf( ok2); //输出 if(ptr == var) //可以 printf( ok3); //输出 if(ptr = var[1]) //可以比较,但是返回 false printf( ok4); //不会输出 return 0; 其实就是说 地址也是可以用来比较的。 12.3 指针数组要让数组的元素 指向 int 或其他数据类型的地址(指针)。可以使用指针数组。 数据类型 *指针数组名[大小]; 比如：int *ptr[3]; ptr 声明为一个指针数组。 由 3 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。 int main() // 定义一个指针数组， 该数组的每个元素， 指向的是一个字符串 char *books[] = 三国演义, 西游记, 红楼梦, 水浒传 ; char * pStr = abc; // 遍历 int i, len = 4; for(i = 0; i len; i++) printf( books[%d] 指向字符串是=%s pStr 指向的内容=%s, i, books[i], pStr); return 0;标准输出：books[0] 指向字符串是=三国演义 pStr 指向的内容=abcbooks[1] 指向字符串是=西游记 pStr 指向的内容=abcbooks[2] 指向字符串是=红楼梦 pStr 指向的内容=abcbooks[3] 指向字符串是=水浒传 pStr 指向的内容=abc 12.4 指向指针的指针又叫多重指针 指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。 当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。 一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。 int **ptr; // ptr 的类型是 int ** int main () int var; int *ptr; //一级指针 int **pptr; //二级指针 int ***ppptr; // 三级指针 var = 3000; ptr = var; // var 变量的地址赋给 ptr pptr = ptr;// 表示将 ptr 存放的地址， 赋给 pptr ppptr = pptr; // 表示将 pptr 存放的地址， 赋给 ppptr printf(var 的地址=%p var = %d , var, var );// 0x1133 3000 printf(ptr 的本身的地址=%p ptr 存放的地址=%p *ptr = %d , ptr, ptr, *ptr ); printf(pptr 本身地址 = %p pptr 存放的地址=%p **pptr = %d , pptr, pptr, **pptr); printf(ppptr 本身地址 = %p ppptr 存放的地址=%p ***pptr = %d , ppptr, ppptr, ***ppptr); getchar(); return 0; 12.5 传递指针(地址)给函数当函数的形参类型是指针类型时，是使用该函数时，需要传递指针，或者地址，或者数组给该形参。 12.6 传数组给指针变量数组名本身就代表该数组首地址，因此传数组的本质就是传地址。 12.7 指针函数返回指针的函数 C 语言 允许函数的返回值是一个指针（地址），这样的函数称为指针函数。 // 请编写一个函数 strlong()， 返回两个字符串中较长的一个。#include string.hchar *strlong(char *str1, char *str2) // 函数返回的 char * (指针) printf( str1 的长度%d str2 的长度%d, strlen(str1), strlen(str2)); if(strlen(str1) = strlen(str2)) return str1; else return str2; int main() char str1[30], str2[30], *str; // str 是一个指针类型， 指向一个字符串 printf( 请输入第 1 个字符串); gets(str1); printf( 请输入第 2 个字符串); gets(str2); str = strlong(str1, str2); printf( Longer string: %s , str); return 0;输入：aaa bbbb标准输出： 请输入第 1 个字符串请输入第 2 个字符串str1 的长度3 str2 的长度4Longer string: bbbb 指针函数注意事项和细节 用指针作为函数返回值时需要注意，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针不能指向这些数据。 函数运行结束后会销毁该函数所有的局部数据，这里所谓的销毁并不是将局部数据所占用的内存全部清零，而是程序放弃对它的使用权限，后面的代码可以使用这块内存。 C 语言不支持在调用函数时返回局部变量的地址， 如果确实有这样的需求， 需要定义局部变量为 static 变量。 int *func() // int n = 100; //局部变量, 在 func 返回时，就会销毁 static int n = 100; // 如果这个局部变量是 static 性质的，那么n存放数据的空间在静态数据区 return n; int main() int *p = func(); //func 返回指针 int n; printf(okoook~~); //可能是使用到 局部变量 int n = 100 占用空间 n = *p; printf( value = %d , n);// 思考，是否能够输出 100? 不一定 return 0; 12.8 函数指针就是：指向函数的指针 一个函数总是占用一段连续的内存区域， 函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。 把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。 定义returnType (*pointerName)(param list); returnType 为函数指针指向的函数返回值类型 pointerName 为函数指针名称 param list 为函数指针指向的函数的参数列表 参数列表中可以同时给出参数的类型和名称， 也可以只给出参数的类型， 省略参数的名称 注意( )的优先级高于*，第一个括号不能省略，如果写作 returnType *pointerName(param list);就成了函数原型，它表明函数的返回值类型为 returnType * // 用函数指针来实现对函数的调用, 返回两个整数中的最大值.// 说明// 1. max 函数// 2. 接收两个 int ,返回较大数int max(int a, int b) return ab ? a : b;int main() int x, y, maxVal; // 说明 函数指针 // 1. 函数指针的名字 pmax // 2. int 表示 该函数指针指向的函数是返回 int 类型 // 3. (int, int) 表示 该函数指针指向的函数形参是接收两个 int // 4. 在定义函数指针时， 也可以写上形参名 int (*pmax)(int x, int y) = max; int (*pmax)(int , int) = max; // printf(Input two numbers:); scanf(%d %d, x, y); // (*pmax)(x, y) 通过函数指针去调用 函数 max maxVal = (*pmax)(x, y); printf(Max value: %d pmax=%p pmax 本身的地址=%p , maxVal, pmax, pmax); return(0); 12.9 回调函数 函数指针变量可以作为某个函数的参数来使用的， 回调函数就是一个通过函数指针调用的函数。 回调函数是由别人的函数执行时调用你传入的函数（通过函数指针完成） // 使用回调函数的方式， 给一个整型数组 int arr[10] 赋 10 个随机数// 回调函数// 1. int (*f)(void)// 2. f 就是 函数指针, 它可以接收的函数是 (返回 int ,没有形参的函数)// 3. f 在这里被 initArray 调用， 充当了回调函数角色void initArray(int *array, int arraySize, int (*f)(void)) int i; // 循环 10 for (i=0; iarraySize; i++) array[i] = f(); //通过 函数指针调用了 getNextRandomValue 函数 // 获取随机值int getNextRandomValue(void) return rand(); // rand 系统函数， 会返回一个随机整数int main(void) int myarray[10],i; //定义一个数组和 int // 说明 // 1. 调用 initArray 函数 // 2. 传入了一个函数名 getNextRandomValue (地址), 需要使用函数指针接收 initArray(myarray, 10, getNextRandomValue); // 输出赋值后的数组 for(i = 0; i 10; i++) printf(%d , myarray[i]); printf( ); return 0; 指针的注意事项和细节 指针变量存放的是地址，从这个角度看指针的本质就是地址。 变量声明的时候，如果没有确切的地址赋值，为指针变量赋一个 NULL 值是好的编程习惯。 赋为 NULL 值的指针被称为空指针，NULL 指针是一个定义在标准库 stdio.h 中的值为零的常量 #define NULL 0 12.10 动态内存分配 全局变量——内存中的静态存储区 非静态的局部变量——内存中的动态存储区——stack 栈 临时使用的数据—建立动态内存分配区域， 需要时随时开辟， 不需要时及时释放——heap 堆 根据需要向系统申请所需大小的空间，由于未在声明部分定义其为变量或者数组，不能通过变量名或者数组名来引用这些数据，只能通过指针来引用 相关函数 头文件 #include stdlib.h 声明了四个关于内存动态分配的函数 函数原型 void * malloc（usigned int size） // memory allocation 作用——在内存的动态存储区(堆区)中分配一个长度为 size 的连续空间。 形参 size 的类型为无符号整型， 函数返回值是所分配区域的第一个字节的地址， 即此函数是一个指针型函数，返回的指针指向该分配域的开头位置。 malloc(100); 开辟 100 字节的临时空间， 返回值为其第一个字节的地址 函数原型void *calloc（unsigned n,unsigned size） 作用——在内存的动态存储区中分配 n 个长度为 size 的连续空间， 这个空间一般比较大， 足以保存一个数组。 用 calloc 函数可以为一维数组开辟动态存储空间，n 为数组元素个数，每个元素长度为 size. 函数返回指向所分配域的起始位置的指针； 分配不成功， 返回 NULL。 p calloc(50, 4); 开辟 50*4 个字节临时空间， 把起始地址分配给指针变量 p 函数原型： void free（void *p） 作用——释放变量 p 所指向的动态空间， 使这部分空间能重新被其他变量使用。 p 是最近一次调用 calloc 或 malloc 函数时的函数返回值 free 函数无返回值 free(p); 释放 p 所指向的已分配的动态空间 函数原型：void *realloc（void *p，unsigned int size) 作用——重新分配 malloc 或 calloc 函数获得的动态空间大小，将 p 指向的动态空间大小改变为 size，p 的值不变，分配失败返回 NULL realloc(p, 50); 将 p 所指向的已分配的动态空间 改为 50 字节 #include stdlib.h#include stdio.hint main() void check(int *); int * p,i; // 在堆区开辟一个 5 * 4 的空间， 并将地址 (void *） ， 转成 (int *) , 赋给 p p = (int *)malloc(5*sizeof(int)); for( i = 0; i 5; i++) scanf(%d, p + i); check(p); // free(p); //销毁 堆区 p 指向的空间 return 0; void check(int *p) int i; printf( 不及格的成绩 有: ); for(i =0; i 5; i++) if(p[i] 60) printf( %d , p[i]); 动态分配内存的基本原则 避免分配大量的小内存块。分配堆上的内存有一些系统开销，所以分配许多小的内存块比分配几个大内存块的系统开销大。 仅在需要时分配内存。 只要使用完堆上的内存块， 就需要及时释放它(如果使用动态分配内存， 需要遵守原则：谁分配， 谁释放)， 否则可能出现内存泄漏。 总是确保释放以分配的内存。在编写分配内存的代码时，就要确定在代码的什么地方释放内存。 在释放内存之前， 确保不会无意中覆盖堆上已分配的内存地址， 否则程序就会出现内存泄漏。 13. 结构体和共用体13.1 结构体void main() /* 张老太养了两只猫猫:一只名字叫小白,今年 3 岁,白色。 还有一只叫小花,今年 100 岁,花色。 请编写一个程序， 当用户输入小猫的名字时， 就显示该猫的名字， 年龄， 颜色。 如果用户输入的小猫名错误， 则显示 张老太没有这只猫猫。 分析： 1. 猫猫有 三个成员(变量)组成 2. 使用结构体解决 */ // 创建 结构体 Cat 【是数据类型】 struct Cat // 结构体名 Cat, Cat 就是我们自己构造的一个数据类型 char * name; //名字， 使用指针， 指向一个字符串 int age; //年龄 char *color; //颜色 ; // 使用 Cat 结构体， 创建变量 struct Cat cat1; // cat1 就是 struct Cat 的一个变量 struct Cat cat2; // cat2 就是 struct Cat 的一个变量 // 给 cat1 的各个成员赋值 cat1.name = 小白; cat1.age = 3; cat1.color = 白色; //给 cat2 的各个成员赋值 cat2.name = 小花; cat2.age = 100; cat2.color = 花色; //输出两只猫的信息 printf( 第 1 只猫 name=%s age=%d color=%s, cat1.name, cat1.age, cat1.color); printf( 第 2 只猫 name=%s age=%d color=%s, cat2.name, cat2.age, cat2.color); 结构体和结构体变量的区别和联系 结构体是自定义的数据类型， 表示的是一种数据类型. 结构体变量代表一个具体变量 其实就是面向对象里面说的，类 和 对象之间的关系。 声明结构体 struct 结构体名称 // 结构体名首字母大写， 比如 Cat, Person 成员列表;;struct Student char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩 //成员也可以是结构体; 成员 成员是结构体的一个组成部分，一般是基本数据类型、也可以是数组、指针、结构体等。 成员声明语法同变量，示例：数据类型 成员名; 字段的类型可以为：基本类型、数组或指针、结构体等。 在创建一个结构体变量后，需要给成员赋值，如果没有赋值就使用可能导致程序异常终止。 不同结构体变量的成员是独立，互不影响，一个结构体变量的成员更改，不影响另外一个。 创建方式1 struct Stu char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩;struct Stu stu1, stu2;// 定义了两个变量 stu1 和 stu2， 它们都是 Stu 类型， 都由 5 个成员组成// 注意关键字 struct 不能少 创建方式2 struct Stu char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩 stu1, stu2;// 在定义结构体 Stu 的同时， 创建了两个结构体变量 stu1 和 stu2 创建方式3 // 如果只需要 stu1、 stu2 两个变量， 后面不需要再使用结构体数据类型， struct // 没有写 Stu char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩 stu1, stu2;stu1.name = tom; stu1.num = 100;....// 1. 该结构体数据类型， 没有名, 匿名结构体// 2. stu1 和 stu2 就是 该结构体的两个变量 成员获取和赋值 获取：结构体变量名.成员名; 赋值： struct Student stu3 {“林黛玉 2”, 12, 16, ‘A’, 100 }; struct Student char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩 stu1 = 贾宝玉, 11, 18, B, 90.50, stu2 = 林黛玉, 12, 16, A, 100 ; 3. ~~~ c struct Student stu4; //stu4 = 林黛玉 2, 12, 16, A, 100 ; // 这样赋值不可以 常用操作 typedef struct stu rt_base_t pin; rt_base_t mode;stu_t;// 定义一个名字叫stu的结构体类型，然后又把这个类型重定义了个叫stu_t的类型。// 后续创建结构体的时候，就只需要// stu_t studentA; 就可以了typedef Stu_t *stu_ptr;// 重定义了个指针类型// stu_ptr studentA_t;// 效果等同于// stu_t * studentA_t; 13.2 共用体共用体（Union）属于构造类型，它可以包含多个类型不同的成员。和结构体非常类似，但是也有不同的地方。 结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。 union 共用体名 成员列表; 定义 union data int n; char ch; double f;;union data a, b, c;union data int n; char ch; double f;a, b, c;union int n; char ch; double f;a, b, c; 内存问题 union data // data 就是一个共用体(内存布局)， 包含三个成员, 共享数据空间, 该空间的大小以占用最大的成员为准 int n; char ch; short m;;int main() union data a; // 定义一个 共用体变量 a printf(%d, %d , sizeof(a), sizeof(union data) ); // 4, 4 a.n = 0x40; // 16 进制 printf(%d, %c, %d , a.n, a.ch, a.m); a.ch = 9; // printf(%d, %c, %d , a.n, a.ch, a.m); a.m = 0x2059; printf(%d, %c, %d , a.n, a.ch, a.m); a.n = 0x3E25AD54; printf(%d, %c, %d , a.n, a.ch, a.m); return 0;标准输出：4, 464, @, 6457, 9, 578281, Y, 82811042656596, T, -21164 现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：请使用共用体编程完成。 Name Num Sex Profession Score Course 张三 111 女 学生 80.1 李四 222 男 老师 math 王五 333 女 老师 English 赵六 444 男 学生 60.1 #define TOTAL 2 //人员总数struct Person char name[20]; //name int num; //编号 char sex;//性别 f = 女 m=男 char profession; //职员 s=学生 t=老师 union float score; char course[20]; sc; // sc 是一个共用体变量;int main() int i; struct Person persons[TOTAL]; // 定义了一个结构体数组 // 输入人员信息 for(i=0; iTOTAL; i++) printf(Input info: ); scanf(%s %d %c %c, persons[i].name, (persons[i].num), (persons[i].sex), (persons[i].profession)); if(persons[i].profession == s) //如果是学生 printf(请输入该学生成绩:); scanf(%f, persons[i].sc.score); else //如果是老师 printf(请输入该老师课程:); scanf(%s, persons[i].sc.course); fflush(stdin);//刷新 // 输出人员信息 printf( Name\\t\\tNum\\tSex\\tProfession\\tScore / Course ); for(i=0; iTOTAL; i++) if(persons[i].profession == s) //如果是学生 printf(%s\\t\\t%d\\t%c\\t%c\\t\\t%f , persons[i].name, persons[i].num, persons[i].sex, persons[i].profession, persons[i].sc.score); else //如果是老师 printf(%s\\t\\t%d\\t%c\\t%c\\t\\t%s , persons[i].name, persons[i].num, persons[i].sex, persons[i].profession, persons[i].sc.course); return 0; 14. 文件操作 文件在程序中是以流的形式来操作的。 流： 数据在数据源(文件)和程序(内存)之间经历的路径 输入流： 数据从数据源(文件)到程序(内存)的路径 输出流： 数据从程序(内存)到数据源(文件)的路径 C 标准库 - stdio .h 该头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出, 在开发过程中，可以来查询. C 语言中的 IO (输入输出) 通常使用 printf() 和 scanf() 两个函数。 scanf() 函数用于从标准输入（键盘） 读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕） 14.1 getchar() putchar() 函数 int getchar(void) 函数从屏幕读取下一个可用的字符， 并把它返回为一个整数。 这个函数在同一个时间内只会读取一个单一的字符。 您可以在循环内使用这个方法， 以便从屏幕上读取多个字符。 int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。 这个函数在同一个时间内只会输出一个单一的字符。 您可以在循环内使用这个方法， 以便在屏幕上输出多个字符。 #include stdio.hint main( ) int c; printf( Enter a value :); c = getchar( ); printf( You entered: ); putchar( c ); printf( ); return 0; 14.2 gets() puts() 函数 char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区， 直到一个终止符或 EOF。 int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。 int main( ) char str[100]; printf( Enter a value :); gets( str ); printf( You entered: ); puts( str ); return 0; 14.3 scanf() 和 printf() 函数 int scanf(const char *format, …) 函数从标准输入流 stdin 读取输入， 并根据提供的 format 来浏览输入。 int printf(const char *format, …) 函数把输出写入到标准输出流 stdout ， 并根据提供的格式产生输出。 format 可以是一个简单的常量字符串， 但是您可以分别指定 %s、 %d、 %c、 %f 等来输出或读取字符串、整数、字符或浮点数。 还有许多其他可用的格式选项， 可以根据需要使用。 // 您输入一个文本并按下回车键时， 程序读取输入，#include stdio.hint main( ) char str[100]; int i; printf( Enter a value :); scanf(%s %d, str, i); printf( You entered: %s %d , str, i); printf( ); return 0; 14.4 文件操作打开文件 使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件， 这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。 FILE *fopen( const char * filename, const char * mode ); filename 是字符串， 用来命名文件， 访问模式 mode 的值可以是下列值中的一个 如果处理的是二进制文件(图片， 视频..)， 则需使用下面的访问模式: “rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”, “ab+”, “a+b” b :binary 二进制 关闭文件 关闭文件， 使用 fclose( ) 函数。int fclose( FILE *fp ); 如果成功关闭文件， fclose( ) 函数返回零， 如果关闭文件时发生错误， 函数返回 EOF。 这个函数实际上， 会清空缓冲区中的数据， 关闭文件， 并释放用于该文件的所有内存。 EOF 是一个定义在头文件 stdio.h 中的常量。 C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。 使用完文件后(读， 写)， 一定要将该文件关闭。 写入文件 下面是把字符写入到流中的函数 int fputc( int c, FILE *fp ); 说明：函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。 如果写入成功， 它会返回写入的字符，如果发生错误， 则会返回 EOF。 您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中： int fputs( const char *s, FILE *fp ); 说明： 函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。 如果写入成功， 它会返回一个非负值， 如果发生错误， 则会返回 EOF。 您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中 void main() // 创建一个文件指针 FILE *fp = NULL; // 打开该文件 fp = fopen(d:/test100.txt, w+); // w+ 模式是 文件会被截断为零长度 // fp = fopen(d:/test100.txt, a+); //w+ 模式是 文件会被截断为零长度 // 将内容写入到文件中 /* fprintf(fp, 你好 北京~~ ); fputs(你好，上海~~ , fp); */ //关闭文件!!! fclose(fp); printf(创建， 写入信息完成); 读取文件 下面是从文件读取单个字符的函数 int fgetc( FILE * fp ); 说明： fgetc() 函数从 fp 所指向的输入文件中读取一个字符。 返回值是读取的字符， 如果发生错误则返回 EOF。 下面的函数从流中读取一个字符串： char *fgets( char *buf, int n, FILE *fp ); 说明： 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。 它会把读取的字符串复制到缓冲区 buf， 并在最后追加一个 null 字符来终止字符串。 如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘ ’ 或文件的末尾 EOF， 则只会返回读取到的字符，包括换行符。 void main() // 创建一个文件指针 FILE *fp = NULL; // 定义一个缓冲区 char buff[1024]; // 打开文件 fp = fopen(d:/test200.txt, r); // 方法 1 // fscanf(fp, %s, buff); // 输出 // printf(%s , buff); // 方法 2 读取整个文件 // 说明， 循环读取 fp 指向的文件内容， 如果读到 NULL,就结束 while(fgets(buff, 1024,fp)!=NULL) printf(%s, buff); // 关闭文件 fclose(fp); getchar();","tags":["C语言"],"categories":["编程语法"]},{"title":"about","path":"/about/index.html","content":"imhaozi"}]