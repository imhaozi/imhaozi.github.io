[{"title":"博客搭建指南","url":"/2025/08/29/博客搭建指南/","content":"\n\n\n# 1. 环境准备\n\n1. 安装git\n2. 安装nodejs\n3. 在cmd或git命令行中，执行以下命令安装hexo。\n\n~~~ sh\nnpm install -g hexo-cli \n~~~\n\n> 如果后续有些命令无法识别，可能说明安装完需要重启一下电脑。\n\n\n\n# 2. 仓库创建\n\n创建一个GitHub仓库，仓库名固定`用户名.github.io`。\n\n仓库默认包含一个主分支`main`，再手动创建一个分支`hexo`。\n\n* main：存放编译后的静态页面，访问的博客也就是此处的内容。\n* hexo：存放编译前的源码文件，在此处进行文档编写，此分支用来在多设备同步内容。\n\n在github仓库设置中，找到`Pages`，找到`Build and deployment`，选择从分支获取资源，分支选择main，然后保存。\n\n\n\n# 3. 创建博客\n\n创建一个空的文件夹`Blog`，并在此文件夹中打开`git命令`。\n\n按顺序调用这三行命令。\n\n~~~ sh\nhexo init  // 初始化，将本文件夹初始化为博客文件夹\n\nhexo g  // 将源文件生成静态文件\n\nhexo s  // 在本地启动服务\n~~~\n\n执行效果如下\n\n~~~ sh\nXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/Blog\n$ hexo init\nINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git\nINFO  Install dependencies\nINFO  Start blogging with Hexo!\n\nXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/Blog\n$ hexo g\nINFO  Validating config\nINFO  Start processing\nINFO  Files loaded in 368 ms\nINFO  Generated: archives/index.html\nINFO  Generated: index.html\nINFO  Generated: archives/2025/08/index.html\nINFO  Generated: fancybox/jquery.fancybox.min.css\nINFO  Generated: css/style.css\nINFO  Generated: js/script.js\nINFO  Generated: archives/2025/index.html\nINFO  Generated: fancybox/jquery.fancybox.min.js\nINFO  Generated: js/jquery-3.6.4.min.js\nINFO  Generated: 2025/08/29/hello-world/index.html\nINFO  Generated: css/images/banner.jpg\nINFO  11 files generated in 283 ms\n\nXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/Blog\n$ hexo s\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n~~~\n\n执行完成后，将最后的地址`http://localhost:4000/`复制到浏览器即可看到默认的博客效果。\n\n\n\n# 4. 修改主题\n\n## 4.1 下载主题源码\n\n在官网自带的主题`https://hexo.io/themes/`中找到一个喜欢的主题，这里选择[NexT主题](https://github.com/next-theme/hexo-theme-next)\n\n按照github中提供的教程，将主题仓库clone到Blog/theme文件夹下。\n\n~~~ sh\nXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/Blog\n$ git clone https://github.com/next-theme/hexo-theme-next themes/next\nCloning into 'themes/next'...\nremote: Enumerating objects: 7752, done.\nremote: Counting objects: 100% (1052/1052), done.\nremote: Compressing objects: 100% (209/209), done.\nremote: Total 7752 (delta 926), reused 846 (delta 843), pack-reused 6700 (from 3)\nReceiving objects: 100% (7752/7752), 1.64 MiB | 13.08 MiB/s, done.\nResolving deltas: 100% (4927/4927), done.\n~~~\n\n可以看到多出了`Blog/theme/next`这个文件夹。\n\n## 4.2 主题美化\n\n### 4.2.1 主题基本信息\n\n修改主题标志，打开`Blog/_config.yml`这个文件，找到最下面的`theme`字段，修改为目标主题`next`，然后保存。\n\n~~~ yml\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n~~~\n\n语言修改，还是这个文件，找到`language: en`，修改为中文。\n\n~~~ sh\nlanguage: zh-CN\n~~~\n\n网站显示的基本信息如下：\n\n~~~ yml\n# Site\ntitle: Blog\nsubtitle: '攻城狮装备搭建日记'\ndescription: '身体和心灵总有一个在路上'\nkeywords:\nauthor: Haozi\nlanguage: zh-CN\ntimezone: ''\n~~~\n\n\n\n### 4.2.2 布局信息美化\n\n这个主题内部还有很多其他的配置项，保存在`Blog\\themes\\next\\_config.yml`，但是[NexT文档](https://theme-next.js.org/docs/getting-started/configuration.html)不推荐直接修改此文件，建议修改方式如下：\n\n将主题文件夹下默认的配置文件`Blog\\themes\\next`复制到项目根目录并重命名为`Blog\\_config.next.yml`\n\n~~~ sh\ncp themes/next/_config.yml _config.next.yml\n~~~\n\n**主题布局选择**\n\n主题内部还分为四种不同的主题布局，配置方式如下：\n\n将`Blog\\_config.next.yml`文件中的如下字段选择如下：\n\n~~~ yml\n# Schemes\n# scheme: Muse\n#scheme: Mist\n#scheme: Pisces\nscheme: Gemini\n~~~\n\n### 4.2.3 分类和标签功能\n\n`Blog\\_config.next.yml`文件下，找到以下字段，根据需要打开对应的菜单项\n\n~~~ yml\nmenu:\n  home: / || fa fa-home\n  # about: /about/ || fa fa-user\n  tags: /tags/ || fa fa-tags\n  categories: /categories/ || fa fa-th\n  archives: /archives/ || fa fa-archive\n  # schedule: /schedule/ || fa fa-calendar\n  #sitemap: /sitemap.xml || fa fa-sitemap\n  #commonweal: /404/ || fa fa-heartbeat\n\n# Enable / Disable menu icons / item badges.\nmenu_settings:\n  icons: true\n  badges: false\n~~~\n\n其中使用的菜单图标都是来自于[Font Awesome](https://fontawesome.com/?from=io)，可以在这个网站找到自己喜欢的图标后，把图标名称写在 `||` 后面即可。\n\n\n\n此时，当我们在首页点击 `标签` 或 `分类` 时，会报 404 ，这是因为我们还没有创建对应的文件夹，所以报 404 找不到。因此，需要在本地创建标签和分类文件夹。\n\n~~~ sh\nhexo new page 'tags' # 创建tags子目录\nhexo new page 'categories' # 创建categories子目录\n~~~\n\n执行效果如下，本地会多出来两个文件夹。\n\n~~~ sh\nXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/imhaozi.github.io (hexo)\n$ hexo new page 'tags'\nINFO  Validating config\nINFO  Created: ~\\Desktop\\imhaozi.github.io\\source\\tags\\index.md\n\nXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/imhaozi.github.io (hexo)\n$ hexo new page 'categories'\nINFO  Validating config\nINFO  Created: ~\\Desktop\\imhaozi.github.io\\source\\categories\\index.md\n~~~\n\n此时如果重新发布网站之后，页面不会报错，但是还不能自动检索文章，需要在刚才生成的文件夹中的`index.md` 中增加对应的 type 属性。\n\n添加完之后如下：\n\ncategories下的index\n\n~~~ markdown\n---\ntitle: categories\ndate: 2025-09-01 15:44:04\ntype: categories\n---\n~~~\n\ntags下的index\n\n~~~ markdown\n---\ntitle: tags\ndate: 2025-09-01 15:43:56\ntype: tags\n---\n~~~\n\n新发布的文章也需要加上对应的标签和主题才可以被检索到，比如本文章。\n\n~~~ md\n---\ntitle: 博客搭建指南\ndate: 2025-08-29 18:49:27\ntags:\n  - blog\n  - hexo\ncategories:\n  - 工具\n---\n~~~\n\n> 上面这个文章，属于`工具`类别，标签加了两个`hexo`、`blog`.\n\n\n\n### 4.2.4 首页不显示全文\n\n网站首页默认会将文章全文显示，但是一般都不是我们想看的内容，可以选择把文章都只显示一个概要，然后可以点进去再看全文。\n\n只需要在文章头部添加`description`字段即可。\n\n~~~ markdown\n---\ntitle: 博客搭建指南\ndate: 2025-08-29 18:49:27\ntags: [hexo,blog]\ncategories: 工具\ndescription: 记录搭建博客和美化主题的过程\n---\n~~~\n\n\n\n### 4.2.5 文章搜索功能\n\n安装插件\n\n~~~ sh\nnpm install hexo-generator-search  --save\nnpm install hexo-generator-searchdb --save\n~~~\n\n安装效果如下\n\n~~~ sh\nXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/imhaozi.github.io (hexo)\n$ npm install hexo-generator-search  --save\n\nadded 1 package, and audited 238 packages in 2s\n\n37 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n\nXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/imhaozi.github.io (hexo)\n$ npm install hexo-generator-searchdb --save\n\nadded 1 package, and audited 239 packages in 2s\n\n37 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n~~~\n\n\n\n`Blog\\_config.next.yml`文件下，添加如下字段（默认是没有这个字段的）\n\n~~~ yml\nsearch:\n  path: search.xml\n  field: post\n  format: html\n  limit: 10000\n~~~\n\n然后将以下字段修改使能\n\n~~~ yml\n# Local Search\n# Dependencies: https://github.com/next-theme/hexo-generator-searchdb\nlocal_search:\n  enable: true\n  # Show top n results per article, show all results by setting to -1\n  top_n_per_article: -1\n  # Unescape html strings to the readable one.\n  unescape: false\n  # Preload the search data when the page loads.\n  preload: false\n~~~\n\n\n\n### 4.2.6 隐藏底部强力驱动\n\n`Blog\\_config.next.yml`文件下\n\n~~~ yml\n  # Powered by Hexo & NexT\n  powered: false\n~~~\n\n\n\n### 4.2.7 目录自己编号\n\n主题默认会给文章目录加编号，如果我们自己已经加了编号了就会重复，需要关掉此功能。\n\n`Blog\\_config.next.yml`文件下\n\n~~~ yml\ntoc:\n  enable: true\n  # Automatically add list number to toc.\n  number: false\n~~~\n\n\n\n### 4.2.8 文章默认格式\n\n在 Hexo 根目录下 修改 `scaffolds/post.md`\n\n~~~ yml\ntitle: {{ title }}\ndate: {{ date }}\ntags: [tag1,tag2]\ncategories: [类别]\ndescription: null\n~~~\n\n### 4.2.9 代码块格式和复制按钮\n\n`Blog\\_config.next.yml`文件下\n\n~~~ yml\ncodeblock:\n  # Code Highlight theme\n  # All available themes: https://theme-next.js.org/highlight/\n  theme:\n    light: default\n    dark: stackoverflow-dark\n  prism:\n    light: prism\n    dark: prism-dark\n  # Add copy button on codeblock\n  copy_button:\n    enable: true\n    # Available values: default | flat | mac\n    style:\n  # Fold code block\n  fold:\n    enable: true\n    height: 500\n  # Display language name\n  language: true\n~~~\n\n\n\n### 4.2.10 文章阅读进度\n\n`Blog\\_config.next.yml`文件下\n\n~~~ yml\n# Reading progress bar\nreading_progress:\n  enable: true\n  # Available values: left | right\n  start_at: left\n  # Available values: top | bottom\n  position: top\n  reversed: false\n  color: \"#37c6c0\"\n  height: 3px\n~~~\n\n\n\n### 4.2.11 文章和图片单独创建文件夹\n\n`Blog/_config.yml`这个文件\n\n~~~ yml\npost_asset_folder: true\n~~~\n\n\n\n\n\n## 4.3 重新运行\n\n执行下面三行命令，重新生成静态文件。\n\n~~~ sh\nhexo clean\nhexo g\nhexo s\n~~~\n\n执行完成后，将最后的地址`http://localhost:4000/`复制到浏览器即可看到修改后的主题博客效果。\n\n\n\n# 5. github推送\n\n打开`Blog/_config.yml`这个文件，找到最下面的`deploy`字段，添加如下信息，然后保存。其中repo为仓库的链接。\n\n~~~ yml\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repo: https://github.com/imhaozi/imhaozi.github.io.git\n  branch: main \n~~~\n\n\n\n安装git部署插件\n\n~~~ sh\nXCHARGE-2024Q2-LT003@LAPTOP-F010DA3K MINGW64 ~/Desktop/Blog\n$ npm install hexo-deployer-git --save\n\nadded 10 packages, and audited 237 packages in 3s\n\n37 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n~~~\n\n\n\n重新生成界面并推送到远端。\n\n~~~ sh\nhexo clean\nhexo g\nhexo d // 部署到服务上\n~~~\n\n\n\n完成后在浏览器中访问`用户名.github.io`即可访问博客内容。\n\n\n\n# 6. 多端同步\n\n本机操作：\n\n1. 将远端仓库克隆到本地，并切换到`hexo`分支。并将此分支下的文件都删掉，仅留下`.git`\n2. 将创建的`Blog`文件夹中的内容全部复制到，`hexo`分支的仓库文件夹，并删去`.deploy_git`文件夹\n3. 如果你在`Blog/themes`文件夹下 clone 过其它主题文件，把其中的 `.git`文件夹删除掉\n4. 将`hexo`分支的内容推送到远端\n\n\n\n异地操作：\n\n1. 首次创建博客的电脑需要先将首次创建完成的博客源码推送到远端（上面的步骤）\n2. 本机下载已经上传到远端的源码\n3. 本机安装环境`npm install hexo-cli -g`、`npm install hexo-deployer-git --save`（如果创建的博客还需要其他的就分别安装）\n4. 在本机的`hexo`分支上继续写博客，写完之后生成并推送\n5. 博客推送完成后，记得把源码推送到远端。\n\n\n\n# 7. 博客图片显示\n\n安装图片插件\n\n~~~ sh\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n~~~\n\n修改配置，打开`Blog/_config.yml`这个文件，找到最下面的`post_asset_folder`字段\n\n~~~ yml\npost_asset_folder: true\n~~~\n\n后面新建文章的时候，会自动创建同文件名的文件夹（或者手动创建md文件和文件夹），图片都可以放到这个文件夹下。 \n\n插入图片的时候，采用如下形式。\n\n~~~ md\n![CAN接线方式](./canopen/CAN接线方式.jpg)\n~~~\n\n\n\n\n\n","tags":["blog","hexo"],"categories":["工具"]},{"title":"ros1学习笔记","url":"/2025/06/01/04. Linux应用/ros1/","content":"\n\n\n# 1. 环境准备\n\n* ubuntu环境\n  * 这里使用的`ubuntu 20.04.3`\n  * 镜像名称：ubuntu-20.04.6-desktop-amd64.iso（文件大小：4.05G）\n  * 下载地址：http://mirrors.ustc.edu.cn/ubuntu-releases/\n* ros1环境\n  * 这里使用的是`Noetic版本`。\n  * 安装方式：小鱼一键安装\n\n~~~ sh\nwget http://fishros.com/install -O fishros && bash fishros\n~~~\n\n\n\n# 2. 创建项目\n\n以下创建一个示例工程，也基于此工程完成本项目，后续的所有项目创建都是这个流程。\n\n\n\n**步骤一：创建工程**\n\n1. 创建一个工作空间文件夹（就是一个工程文件夹）\n   1. 工作空间中可以有多个软件包\n   2. 软件包中又可以又多个节点\n\n比如这里想创建一个基于泰山派的小车项目，就可以创建下面的文件目录\n\n* TspCarWs\n  * src：存放代码，源代码、功能包等\n\n\n\n创建一个`TspCarWs`目录作为本项目的工作空间。\n\n~~~ sh\nhaozi@haozi:~/work/develop$ mkdir TspCarWs\nhaozi@haozi:~/work/develop$ cd TspCarWs/\nhaozi@haozi:~/work/develop/TspCarWs$ mkdir src\n~~~\n\n\n\n**步骤二：创建软件包**\n\n本项目采用上下位机的架构进行设计，上下位机通过通信进行交互和控制，首先实现一个用于控制下位机运动的软件包`lower_ctrl_pkg`。\n\n\n\n切换到工作空间的src目录下，执行如下指令：\n\n~~~ sh\ncatkin_create_pkg 包名 <依赖项1> <依赖项2> ...\n~~~\n\n如下：\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs/src$ catkin_create_pkg lower_ctrl_pkg rospy roscpp std_msgs\nCreated file lower_ctrl_pkg/package.xml\nCreated file lower_ctrl_pkg/CMakeLists.txt\nCreated folder lower_ctrl_pkg/include/lower_ctrl_pkg\nCreated folder lower_ctrl_pkg/src\nSuccessfully created files in /home/haozi/work/develop/TspCarWs/src/lower_ctrl_pkg. Please adjust the values in package.xml.\n~~~\n\n执行完成后，在src目录下就会多出一个新的目录`catkin_create_pkg`，该目录就是一个包了，包里面又包含了多个文件。\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs/src$ ls\nlower_ctrl_pkg\nhaozi@haozi:~/work/develop/TspCarWs/src$ cd lower_ctrl_pkg/\nhaozi@haozi:~/work/develop/TspCarWs/src/lower_ctrl_pkg$ ls\nCMakeLists.txt  include  package.xml  src\n~~~\n\n\n\n**步骤三：添加代码**\n\n在软件包的src目录下创建代码文件`main.cpp`\n\n~~~ cpp\n#include <ros/ros.h>\n\nint main(int argc, char *argv[])\n{\n    printf(\"lower_ctrl_node running~ \\n\");\n    \n    // 后面的是节点名称\n    ros::init(argc, argv, \"lower_ctrl_node\");\n\n    while(ros::ok())\n    {\n        printf(\"lower_ctrl_node running~ \\n\");\n        sleep(1);\n    }\n    return 0;\n}\n~~~\n\n在CMakeLists.txt文件中，build部分，找到对应的注释的位置，添加如下两条（没注释掉的是添加的，注释掉的是原有的）。\n\n~~~ cmake\n## Declare a C++ executable\n## With catkin_make all packages are built within a single CMake context\n## The recommended prefix ensures that target names across packages don't collide\n# add_executable(${PROJECT_NAME}_node src/lower_ctrl_pkg_node.cpp)\nadd_executable(lower_ctrl_node src/main.cpp)\n\n## Specify libraries t\no link a library or executable target against\n# target_link_libraries(${PROJECT_NAME}_node\n#   ${catkin_LIBRARIES}\n# )\ntarget_link_libraries(lower_ctrl_node\n  ${catkin_LIBRARIES}\n)\n~~~\n\n其中\n\nadd_executable：表示需要编译可执行文件\n\ntarget_link_libraries：表示需要链接ros库\n\n\n\n**步骤四：编译代码**\n\n在工作空间目录（tsp_car_ws）下执行编译命令\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs$ pwd\n/home/haozi/work/develop/TspCarWs\nhaozi@haozi:~/work/develop/TspCarWs$ catkin_make\nBase path: /home/haozi/work/develop/TspCarWs\nSource space: /home/haozi/work/develop/TspCarWs/src\nBuild space: /home/haozi/work/develop/TspCarWs/build\nDevel space: /home/haozi/work/develop/TspCarWs/devel\nInstall space: /home/haozi/work/develop/TspCarWs/install\n####\n#### Running command: \"make cmake_check_build_system\" in \"/home/haozi/work/develop/TspCarWs/build\"\n####\n####\n#### Running command: \"make -j4 -l4\" in \"/home/haozi/work/develop/TspCarWs/build\"\n####\n[100%] Built target lower_ctrl_node\n~~~\n\n编译完成后，工作空间下就会多出来两个文件夹，build、devel\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs$ ls\nbuild  devel  src\n~~~\n\n* build：编译文件\n* devel：执行文件，执行前需要在这里添加源\n\n**步骤五：执行**\n\n启动一个新的终端，启动ros\n\n~~~ sh\nroscore\n~~~\n\n添加代码源（注意相对目录或者绝对目录）\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs$ source devel/setup.bash\n~~~\n\n执行代码\n\n~~~ sh\n# rosrun：执行\n# lower_ctrl_pkg：报名\n# lower_ctrl_node：节点名roslaunch launch_pkg all.launch tf\nhaozi@haozi:~/work/develop/TspCarWs$ rosrun lower_ctrl_pkg lower_ctrl_node\nlower_ctrl_node running~\n~~~\n\n到这里，创建一个ros软件包，并执行的流程就完成了。\n\n\n\n\n\n# 3. 小车开发\n\n## 3.1 速度订阅\n\n为了结构化实现功能，我们不会把所有逻辑都放到一个文件中，会按照功能进行划分一下。\n\n还是在`lower_ctrl_pkg`软件包下。\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs/src/lower_ctrl_pkg/src$ pwd\n/home/haozi/work/develop/TspCarWs/src/lower_ctrl_pkg/src\nhaozi@haozi:~/work/develop/TspCarWs/src/lower_ctrl_pkg/src$ ls\nlower_ctrl.cpp  lower_ctrl.h  main.cpp  uart.cpp  uart.h\n~~~\n\n功能如下：\n\n1. main.c：启动功能\n2. uart.x：提供和下位机通信的接口\n3. lower_ctrl.x：逻辑写在这里\n\n\n\nmain.cpp\n\n~~~ cpp\n#include <ros/ros.h>\n#include \"lower_ctrl.h\"\n\nint main(int argc, char *argv[])\n{\n    // 防止ROS_INFO中文乱码\n    setlocale(LC_CTYPE, \"zh_CN.utf8\");\n\n    printf(\"lower_ctrl_node running~ \\n\");\n\n    // 下位机控制节点\n    ros::init(argc, argv, \"lower_ctrl_node\");\n\n    // 通信串口\n    Uart lower_uart(\"/dev/ttyS3\");\n    lower_uart.Open(115200, 8, 'N', 1);\n\n    // 下位机控制节点\n    LowerCtrl lower_ctrl(lower_uart);\n    lower_ctrl.Run();\n\n    return 0;\n}\n~~~\n\nuart.cpp\n\n~~~ cpp\n#include \"uart.h\"\n#include <fcntl.h>   // 用于 open() 函数和文件控制选项\n#include <termios.h> // 用于终端I/O接口 (tcgetattr, tcsetattr等)\n#include <unistd.h>  // 用于 close(), read(), write() 等系统调用\n#include <stdio.h>   // 用于 printf(), perror()\n#include <strings.h> // 用于 bzero()\n\nUart::Uart(const char *name)\n{\n    fd_ = 0;\n    name_ = name;\n}\n\nUart::~Uart()\n{\n    Close();\n}\n\n// 波特率，数据位，是否奇偶校验位，停止位\nint Uart::Open(int buad, int nBits, char nEvent, int nStop)\n{\n    fd_ = open(name_, O_RDWR | O_NOCTTY);\n\n    if (fd_ <= 0)\n    {\n        printf(\"open %s failed, not exist or need to chmod!\", name_);\n        return -1;\n    }\n\n    struct termios newtio, oldtio;\n    if (tcgetattr(fd_, &oldtio) != 0)\n    {\n        perror(\"SetupSerial 1\");\n        return -2;\n    }\n    bzero(&newtio, sizeof(newtio));\n    newtio.c_cflag |= CLOCAL | CREAD;\n    newtio.c_cflag &= ~CSIZE;\n\n    switch (nBits)\n    {\n    case 7:\n        newtio.c_cflag |= CS7;\n        break;\n    case 8:\n        newtio.c_cflag |= CS8;\n        break;\n    }\n\n    switch (nEvent)\n    {\n    case 'O':\n        newtio.c_cflag |= PARENB;\n        newtio.c_cflag |= PARODD;\n        newtio.c_iflag |= (INPCK | ISTRIP);\n        break;\n    case 'E':\n        newtio.c_iflag |= (INPCK | ISTRIP);\n        newtio.c_cflag |= PARENB;\n        newtio.c_cflag &= ~PARODD;\n        break;\n    case 'N':\n        newtio.c_cflag &= ~PARENB;\n        break;\n    }\n\n    switch (buad)\n    {\n    case 2400:\n        cfsetispeed(&newtio, B2400);\n        cfsetospeed(&newtio, B2400);\n        break;\n    case 4800:\n        cfsetispeed(&newtio, B4800);\n        cfsetospeed(&newtio, B4800);\n        break;\n    case 9600:\n        cfsetispeed(&newtio, B9600);\n        cfsetospeed(&newtio, B9600);\n        break;\n    case 115200:\n        cfsetispeed(&newtio, B115200);\n        cfsetospeed(&newtio, B115200);\n        break;\n    case 460800:\n        cfsetispeed(&newtio, B460800);\n        cfsetospeed(&newtio, B460800);\n        break;\n    default:\n        cfsetispeed(&newtio, B9600);\n        cfsetospeed(&newtio, B9600);\n        break;\n    }\n\n    if (nStop == 1)\n        newtio.c_cflag &= ~CSTOPB;\n    else if (nStop == 2)\n        newtio.c_cflag |= CSTOPB;\n\n    newtio.c_cc[VTIME] = 10; // 等待时间，0表示永远等待，单位是十分之一秒，10就是1秒\n    newtio.c_cc[VMIN] = 0;   // 最小接收字节个数\n    tcflush(fd_, TCIFLUSH);\n\n    if ((tcsetattr(fd_, TCSANOW, &newtio)) != 0)\n    {\n        perror(\"com set error\");\n        return -3;\n    }\n\n    printf(\"vtime=%d vmin=%d\\n\", newtio.c_cc[VTIME], newtio.c_cc[VMIN]);\n\n    return 0;\n}\n\nint Uart::Close()\n{\n    if (fd_ > 0)\n        close(fd_);\n    return 0;\n}\n\nint Uart::Write(uint8_t *data, int len)\n{\n    if (fd_ <= 0)\n    {\n        // printf(\"send_data fd_ error!\");\n        return -1;\n    }\n\n    int cnt = write(fd_, data, len);\n    return cnt;\n}\n\nint Uart::Read(uint8_t *data, int len)\n{\n    // 阻塞接收，超时时间1秒（在Open函数中）\n    int cnt = read(fd_, data, len);\n    return cnt;\n}\n~~~\n\nuart.h\n\n~~~ cpp\n#pragma once\n\n#include <stdint.h>\n\nclass Uart\n{\npublic:\n    // 串口号\n    Uart(const char *name);\n    ~Uart();\n\n    // 波特率，数据位，是否奇偶校验位，停止位\n    int Open(int buad, int nBits, char nEvent, int nStop);\n    int Close();\n\n    // 读写\n    int Write(uint8_t *data, int len);\n    int Read(uint8_t *data, int len);\n\nprivate:\n    const char *name_;\n    int fd_;\n};\n~~~\n\n然后在`lower_ctrl.x`中实现速度订阅功能\n\nlower_ctrl.h\n\n~~~ h\n#pragma once\n\n#include <ros/ros.h>\n#include <std_msgs/String.h>     // 标准消息\n#include <geometry_msgs/Twist.h> // 速度消息\n\n#include \"uart.h\"\n\nclass LowerCtrl\n{\npublic:\n    LowerCtrl(Uart &uart);\n    ~LowerCtrl();\n\n    ros::NodeHandle nh_; // 节点管理工具\n    ros::Subscriber tar_speed_sub_;                                 // 订阅目标速度\n    void CmdVelCallback(const geometry_msgs::Twist::ConstPtr &msg); // 收到目标速度的响应\n\n    void Run();\n\nprivate:\n    Uart &uart_;\n};\n~~~\n\nlower_ctrl.cpp\n\n~~~ cpp\n#include \"lower_ctrl.h\"\n\nLowerCtrl::LowerCtrl(Uart &uart) : uart_(uart)\n{\n    tar_speed_sub_ = nh_.subscribe(\"/cmd_vel\", 10, &LowerCtrl::CmdVelCallback, this); // 订阅目标速度\n}\n\nLowerCtrl::~LowerCtrl()\n{\n}\n\n// 速度指令订阅回调函数\nvoid LowerCtrl::CmdVelCallback(const geometry_msgs::Twist::ConstPtr &msg)\n{\n    ROS_INFO(\"tar linear = %f(m/s), angular = %f(rad/s) ~ \\n\", msg->linear.x, msg->angular.z);\n}\n\nvoid LowerCtrl::Run()\n{\n    int ret;\n\n    // 20ms执行一次\n    ros::Rate loop_rate(50);\n\n    while (ros::ok())\n    {\n        ros::spinOnce();\n\n        // 延时（约等于 sleep）\n        loop_rate.sleep();\n    }\n}\n~~~\n\n这样的写法在CMakeLists.txt中也要修改，将新增的几个文件也添加上。\n\n~~~ txt\nadd_executable(lower_ctrl_node \n  src/uart.cpp  \n  src/lower_ctrl.cpp \n  src/main.cpp \n)\n~~~\n\n\n\n## 3.2 速度发布\n\n另起一个软件包用来发布速度\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs$ cd src/\nhaozi@haozi:~/work/develop/TspCarWs/src$ catkin_create_pkg move_ctrl_pkg rospy roscpp std_msgs\nCreated file move_ctrl_pkg/package.xml\nCreated file move_ctrl_pkg/CMakeLists.txt\nCreated folder move_ctrl_pkg/include/move_ctrl_pkg\nCreated folder move_ctrl_pkg/src\nSuccessfully created files in /home/haozi/work/develop/TspCarWs/src/move_ctrl_pkg. Please adjust the values in package.xml.\n~~~\n\n软件包中创建`main.cpp`，代码如下，其余操作流程同上\n\n~~~ cpp\n#include <ros/ros.h>\n#include <std_msgs/String.h>\n#include <geometry_msgs/Twist.h> // 速度消息\n\nint main(int argc, char *argv[])\n{\n    printf(\"move_ctrl_node running~ \\n\");\n\n    // 下位机控制节点\n    ros::init(argc, argv, \"move_ctrl_node\");\n\n    // 节点管理工具\n    ros::NodeHandle nh;\n    // 创建一个发布者，话题名称为cmd_vel, 队列长度为10\n    ros::Publisher cmd_vel_pub = nh.advertise<geometry_msgs::Twist>(\"/cmd_vel\", 10);\n\n    // 创建一个频率控制对象,每秒循环10次\n    ros::Rate loop_rate(10);\n\n    while (ros::ok())\n    {\n        geometry_msgs::Twist vel_cmd;\n        vel_cmd.linear.x = 0.1;\n        vel_cmd.linear.y = 0.0;\n        vel_cmd.linear.z = 0.0;\n        vel_cmd.angular.x = 0.0;\n        vel_cmd.angular.y = 0.0;\n        vel_cmd.angular.z = 0.0;\n        cmd_vel_pub.publish(vel_cmd);   // 发布\n\n        // 延时（约等于 sleep）\n        loop_rate.sleep();\n    }\n    return 0;\n}\n~~~\n\n\n\n## 3.3 查看消息\n\n将两个软件包中的两个节点都运行起来\n\n* `rostopic list`：查看当前存在的话题\n* `rostopic echo 话题名`：查看当前话题发布的消息\n* `rqt_graph`：查看话题之间的关系（需要图像显示）\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs/src/lower_ctrl_pkg/src$ rostopic list\n/cmd_vel\n/rosout\n/rosout_agg\nhaozi@haozi:~/work/develop/TspCarWs/src/lower_ctrl_pkg/src$ rostopic echo /cmd_vel\nlinear: \n  x: 0.1\n  y: 0.0\n  z: 0.0\nangular: \n  x: 0.0\n  y: 0.0\n  z: 0.0\n---\n~~~\n\n\n\n## 3.4 Launch启动\n\n\n\n当软件包和节点多了之后，一个个启动节点需要很多很多命令，因此需要一个能同时启动多个节点的工具。\n\n1. 重新创建一个软件包，`launch_pkg`\n2. 在软件包中创建一个launch文件夹\n3. 文件夹中创建一个`all.launch`文件\n\n结果如下\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs/src$ catkin_create_pkg launch_pkg rospy roscpp std_msgs\nhaozi@haozi:~/work/develop/TspCarWs/src$ cd launch_pkg/\nhaozi@haozi:~/work/develop/TspCarWs/src/launch_pkg$ mkdir launch\nhaozi@haozi:~/work/develop/TspCarWs/src/launch_pkg$ cd launch/\nhaozi@haozi:~/work/develop/TspCarWs/src/launch_pkg/launch$ ls\nall.launch\n~~~\n\n文件中的内容如下，每一条都表示需要启动这个包中的一个节点。\n\n~~~ xml\n<launch>\n    <node pkg=\"lower_ctrl_pkg\" type=\"lower_ctrl_node\" name=\"lower_ctrl_node\"/>\n    <node pkg=\"move_ctrl_pkg\" type=\"move_ctrl_node\" name=\"move_ctrl_node\" output=\"screen\"/>\n</launch>\n~~~\n\n> output=\"screen\"：表示将信息输出到屏幕。\n\n\n\n完成后编译工作空间，编译完成后，使用如下命令即可直接启动所有软件包。\n\n~~~ sh\nroslaunch <包名> <launch文件名>\n~~~\n\n结果如下\n\n~~~ sh\nhaozi@haozi:~/work/develop/ros1/tsp_car_ws$ roslaunch launch_pkg all.launch \n... logging to /home/haozi/.ros/log/82134f94-36e0-11f0-bea8-1303c288b02a/roslaunch-haozi-15144.log\nChecking log directory for disk usage. This may take a while.\nPress Ctrl-C to interrupt\nDone checking log file disk usage. Usage is <1GB.\n\nstarted roslaunch server http://haozi:42535/\n\nSUMMARY\n========\n\nPARAMETERS\n * /rosdistro: noetic\n * /rosversion: 1.17.3\n\nNODES\n  /\n    lower_ctrl_node (lower_ctrl_pkg/lower_ctrl_node)\n    move_ctrl_node (move_ctrl_pkg/move_ctrl_node)\n\nauto-starting new master\nprocess[master]: started with pid [15155]\nROS_MASTER_URI=http://localhost:11311\n\nsetting /run_id to 82134f94-36e0-11f0-bea8-1303c288b02a\nprocess[rosout-1]: started with pid [15165]\nstarted core service [/rosout]\nprocess[lower_ctrl_node-2]: started with pid [15168]\nprocess[move_ctrl_node-3]: started with pid [15173]\n~~~\n\n\n\n> 实际上，这个launch文件，放在任意一个软件包里都可以，但是为了代码结构清晰，就创建了一个空的软件包来干这件事了。\n\n\n\n## 3.5 雷达数据发送\n\n激光雷达数据格式\n\n* sensor_msgs::LaserScan\n  * header\n    * frame_id：坐标系基准\n    * stamp：本次扫描中接收到第一束反射信号的时间\n  * angle_min：扫描的其实角度，弧度\n  * angle_max：扫描的终止角度，弧度\n  * angle_increment：相邻两次测距的旋转夹角，弧度\n  * time_increment：相邻两次测距的时间差，秒\n  * scan_time：两次扫描的起始时间差，秒\n  * range_min：有效测距范围的最小距离，米\n  * range_max：有效测距范围的最大距离，米\n  * ranges[]：本次扫描的所有测距值，米\n  * intensities[]：所有测距值返回的信号强度\n\n\n\n创建雷达数据软件包，用于发送激光雷达数据\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs/src$ catkin_create_pkg lidar_pkg roscpp rospy sensor_msgs\nCreated file lidar_pkg/package.xml\nCreated file lidar_pkg/CMakeLists.txt\nCreated folder lidar_pkg/include/lidar_pkg\nCreated folder lidar_pkg/src\nSuccessfully created files in /home/haozi/work/develop/TspCarWs/src/lidar_pkg. Please adjust the values in package.xml.\n~~~\n\n并在软件包中创建五个文件\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs/src/lidar_pkg/src$ ls\nm1c1_mini.cpp  m1c1_mini.h  main.cpp  uart.cpp  uart.h\n~~~\n\n其中uart.x参考前面速度订阅的串口操作接口，内容相同。\n\n雷达消息接口如下：\n\nm1c1_mini.h\n\n~~~ h\n#pragma once\n\n#include <ros/ros.h>\n#include <std_msgs/Bool.h>\t // 标准消息\n#include <std_msgs/String.h> // 标准消息\n\n#include \"uart.h\"\n\n/* 雷达消息结构 */\n#define PKG_LEN_MIN 12\n#define PKG_LEN_MAX 60\n#define POINT_NUM_MAX_IN_A_PKG 25 // 一包最多25个点\n#pragma pack(1)\ntypedef struct\n{\n\tuint8_t head1;\t\t  // 数据头1 0xAA\n\tuint8_t head2;\t\t  // 数据头2 0x55\n\tuint8_t points_type;  // 点云类型1--每圈起始点;0--非一圈起始点\n\tuint8_t points_num;\t  // 点云个数 结构体总长度 = 10 + points_num * 2\n\tuint16_t start_angle; // 起始角度\n\tuint16_t end_angle;\t  // 结束角度\n\tuint16_t check_code;  // 校验\n\tuint16_t data[POINT_NUM_MAX_IN_A_PKG];\n} LidarData;\n#pragma pack()\n\nclass Lidar\n{\npublic:\n\tLidar(Uart &uart);\n\t~Lidar();\n\n\tint ReadData(std::string &lidar_data);\n\n\tros::NodeHandle nh_;\t   // 节点管理工具\n\tros::Publisher lidar_pub_; // 发布雷达数据\n\tvoid Run();\n\nprivate:\n\tUart &uart_;\n\tLidarData lidar_data_;\n};\n~~~\n\nm1c1_mini.cpp\n\n~~~ cpp\n#include \"m1c1_mini.h\"\n#include <sensor_msgs/LaserScan.h>\n\nLidar::Lidar(Uart &uart) : uart_(uart)\n{\n    lidar_pub_ = nh_.advertise<sensor_msgs::LaserScan>(\"/scan\", 10); // 发布雷达数据\n}\n\nLidar::~Lidar()\n{\n}\n\nint Lidar::ReadData(std::string &lidar_data)\n{\n    int recv_cnt = 0;\n\n    // 先清空雷达数据\n    lidar_data.clear();\n\n    // 先寻找数据头，0xAA 0x55\n    uint8_t buffer[100] = {0};\n    for (int c = 0; c < 100; c++) // 最多尝试100次寻找AA 55开头\n    {\n        // 阻塞接收，超时时间1s\n        recv_cnt = uart_.Read(&buffer[1], 1);\n        if (recv_cnt != 1)\n            return -1;\n\n        // 逐个字节依次插入lidar_data\n        lidar_data.append((char *)(&buffer[1]), 1);\n\n        // 已经找到数据头了\n        if (buffer[0] == 0xAA && buffer[1] == 0x55)\n            break;\n\n        buffer[0] = buffer[1];\n\n        // 长度过长则返回\n        if (lidar_data.size() >= 100)\n        {\n            printf(\"lidar_data100: \");\n            for (int i = 0; i < lidar_data.size(); i++)\n                printf(\"%02x \", (unsigned char)lidar_data.data()[i]);\n            printf(\"\\n\");\n            return -2;\n        }\n    }\n\n    // 删除数据头前面的部分，有可能是错误的数据，也有可能是上一包的部分\n    // 只保留末尾两个字母AA 55作为数据头\n    if (lidar_data.size() > 2)\n        lidar_data = lidar_data.substr(lidar_data.size() - 2);\n\n    // 再读取两个字节 点云类型 和 点云点数(1~25)\n    recv_cnt = uart_.Read(&buffer[0], 2);\n    if (recv_cnt < 2)\n        return -1;\n\n    // 把读到的数据添加到消息\n    lidar_data.append((char *)(&buffer[0]), 2);\n\n    // 判断点云类型 只能是0或1\n    if ((lidar_data.data()[2] != 0) && (lidar_data.data()[2] != 1))\n        return -4;\n\n    // 点云点数只会在1~25之间\n    if (lidar_data.data()[3] > 25 || lidar_data.data()[3] < 1)\n    {\n        for (int i = 0; i < lidar_data.size(); i++)\n            printf(\"%02x \", (unsigned char)lidar_data.data()[i]);\n        printf(\"\\n\");\n        return -5;\n    }\n\n    // 判断本包数据中 数据部分的长度\n    int data_len = 10 + lidar_data.data()[3] * 2 - lidar_data.size();\n    // 计算出的长度过长或过短，则返回错误\n    if (data_len > 100 || data_len < 5)\n        return -6;\n\n    // 读取数据部分\n    recv_cnt = uart_.Read(&buffer[0], data_len);\n    if (recv_cnt < data_len)\n    {\n        // printf(\"read_len=%d < need_read_len=%d !\\n\",read_len,need_read_len);\n        return -1;\n    }\n    lidar_data.append((char *)(&buffer[0]), data_len);\n\n    // 如果长度不正确\n    if (lidar_data.size() != 10 + lidar_data.data()[3] * 2)\n    {\n        printf(\"read len %ld != points num %d *2+10 error!\\n\", lidar_data.size(), lidar_data.data()[3]);\n        for (int i = 0; i < lidar_data.size(); i++)\n            printf(\"%02x \", (unsigned char)lidar_data.data()[i]);\n        printf(\"\\n\");\n        return -7;\n    }\n\n    return 0;\n}\n\nvoid Lidar::Run()\n{\n    int ret = 0;\n    int start_cnt = 0;\n\n    /* 创建雷达数据 */\n    float laser_min_range = 0.1; // 雷达最小量程\n    float laser_max_range = 8.0; // 雷达最大量程\n    int points_size = 800;       // 修正和插值到800点(本身390个点左右)\n    sensor_msgs::LaserScan laser_scan;\n    laser_scan.header.frame_id = \"laser_link\";\n    laser_scan.angle_min = 0;\n    laser_scan.angle_max = 2 * M_PI;\n    laser_scan.angle_increment = (laser_scan.angle_max - laser_scan.angle_min) / points_size;\n    laser_scan.range_min = laser_min_range;\n    laser_scan.range_max = laser_max_range;\n    laser_scan.ranges.resize(points_size);\n    std::fill(laser_scan.ranges.begin(), laser_scan.ranges.end(), std::numeric_limits<float>::infinity()); // 全部填充为无限远\n    laser_scan.intensities.resize(points_size, 127);                                                       // 假设强度值为127\n\n    std::string lidar_str_data;\n\n    while (ros::ok())\n    {\n        ros::spinOnce();\n\n        // 读取雷达数据\n        ret = ReadData(lidar_str_data);\n        if (ret < 0) // 报错，则重新读取\n        {\n            if (ret != -1) // 雷达断电后会返回-1\n                ROS_WARN(\"read_lidar_data ret=%d\", ret);\n            continue;\n        }\n\n        // 校验数据长度\n        if (lidar_str_data.size() < PKG_LEN_MIN || lidar_str_data.size() > PKG_LEN_MAX)\n        {\n            ROS_WARN(\"lidar_str_data size %ld error!\", lidar_str_data.size());\n            continue;\n        }\n\n        // 拷贝进数据包结构体\n        memcpy(&lidar_data_, lidar_str_data.data(), lidar_str_data.size());\n\n        // 每圈起始点，发布上一圈的数据\n        if (lidar_data_.points_type == 1)\n        {\n            if (start_cnt < 10) // 前10圈数据丢弃\n            {\n                start_cnt++;\n                continue;\n            }\n\n            laser_scan.header.stamp = ros::Time::now();\n            // 发布Lidat Scan消息\n            lidar_pub_.publish(laser_scan);\n            ROS_INFO_ONCE(\"Published LaserScan OK\");\n\n            // 必须给每个点刷入无效数据，防止下一圈产生重影, 全部填充为无限远\n            std::fill(laser_scan.ranges.begin(), laser_scan.ranges.end(), std::numeric_limits<float>::infinity());\n        }\n\n        // 开始解析数据包结构体中的数据\n        float start_angle0 = (lidar_data_.start_angle >> 1) / 64.0;\n        float end_angle0 = (lidar_data_.end_angle >> 1) / 64.0;\n        // float start_angle = start_angle0-ang_corr_1;\n        // float end_angle = end_angle0-ang_corr_n;\n\n        float ang_corr_i, distance_mm_i, angle_i;\n        for (int i = 0; i < lidar_data_.points_num; i++)\n        {\n            // 解析距离：单位mm\n            distance_mm_i = lidar_data_.data[i] >> 2;\n\n            // 根据距离来求修正角度\n            ang_corr_i = (distance_mm_i == 0) ? 0 : atan(19.16 * (distance_mm_i - 90.15) / (90.15 * distance_mm_i)) * 180.0 / M_PI;\n\n            if (lidar_data_.points_num != 1) // 分母不能为0\n                angle_i = start_angle0 + (end_angle0 - start_angle0) / (lidar_data_.points_num - 1) * i - ang_corr_i;\n            else\n                angle_i = start_angle0 - ang_corr_i;\n\n            angle_i = 180.0 - (angle_i + 12.0); // 12度是雷达手册中写的固有偏差，180是和雷达安装朝向有关\n\n            // 角度限制在[0,360]度之间\n            angle_i = fmod(angle_i, 360.0);                        // 使用fmod函数计算角度对360的余数\n            angle_i = (angle_i < 0) ? (angle_i + 360.0) : angle_i; // 如果结果是负数，则加上360使其变为正数\n\n            // printf(\"%.2f(%.2f)\\n\",distance_mm_i,angle_i);\n\n            // 考虑到角度修正之后填充，并且插值到800点\n            int new_i = angle_i / 360.0 * (points_size - 1) + 0.5; // 索引最大不能到points_size，而是points_size-1\n            laser_scan.ranges[new_i] = distance_mm_i / 1000.0;     // 填充到LaserScan消息中\n        }\n    }\n}\n~~~\n\nmain.cpp\n\n~~~ cpp\n#include <ros/ros.h>\n#include \"m1c1_mini.h\"\n\nint main(int argc, char *argv[])\n{\n    // 防止ROS_INFO中文乱码\n    setlocale(LC_CTYPE, \"zh_CN.utf8\");\n\n    // 下位机控制节点\n    ros::init(argc, argv, \"lidar_node\");\n\n    // 通信串口\n    Uart lidar_uart(\"/dev/ttyS5\");\n    lidar_uart.Open(115200, 8, 'N', 1);\n\n    // 下位机控制节点\n    Lidar lidar(lidar_uart);\n    lidar.Run();\n\n    return 0;\n}\n~~~\n\n\n\n> 雷达消息话题名一般默认为：`/scan`\n\n## 3.6 雷达数据处理\n\n\n\n\n\n创建一个新的软件包`lidar_handle_pkg`\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs/src$ catkin_create_pkg lidar_handle_pkg roscpp rospy sensor_msgs\nCreated file lidar_handle_pkg/package.xml\nCreated file lidar_handle_pkg/CMakeLists.txt\nCreated folder lidar_handle_pkg/include/lidar_handle_pkg\nCreated folder lidar_handle_pkg/src\nSuccessfully created files in /home/haozi/work/develop/TspCarWs/src/lidar_handle_pkg. Please adjust the values in package.xml.\n~~~\n\n\n\n暂时只创建一个main文件，测试接收到的激光雷达发送的数据，并判断前方障碍物的距离。\n\nmain.cpp\n\n~~~ cpp\n#include <ros/ros.h>\n#include <sensor_msgs/LaserScan.h>\n\nvoid LidarCallback(const sensor_msgs::LaserScan msg)\n{\n    float fMidDist = msg.ranges[180];\n    ROS_INFO(\"前方距离：ranges[180] = %f 米\", fMidDist);\n}\n\nint main(int argc, char *argv[])\n{\n    // 防止ROS_INFO中文乱码\n    setlocale(LC_CTYPE, \"zh_CN.utf8\");\n\n    // 下位机控制节点\n    ros::init(argc, argv, \"lidar_handle_node\");\n\n    ros::NodeHandle nh_;                                                     // 节点管理工具\n    ros::Subscriber lidar_sub_ = nh_.subscribe(\"/scan\", 10, &LidarCallback); // 订阅雷达数据\n\n    ros::spin();\n\n    return 0;\n}\n~~~\n\n\n\n添加避障逻辑方法，判断当障碍物距离过近时，发送速度消息，控制小车避开。\n\n~~~ cpp\n#include <ros/ros.h>\n#include <sensor_msgs/LaserScan.h>\n#include <geometry_msgs/Twist.h> // 速度消息\n\nros::Publisher vel_pub;\n\nvoid LidarCallback(const sensor_msgs::LaserScan msg)\n{\n    float fMidDist = msg.ranges[180];\n    ROS_INFO(\"前方距离：ranges[180] = %f 米\", fMidDist);\n\n    geometry_msgs::Twist vel_cmd;\n    if (fMidDist < 1.5)\n    {\n        vel_cmd.angular.z = 0.5;\n    }\n    else\n    {\n        vel_cmd.linear.x = 0.05;\n    }\n\n    vel_pub.publish(vel_cmd);\n}\n\nint main(int argc, char *argv[])\n{\n    // 防止ROS_INFO中文乱码\n    setlocale(LC_CTYPE, \"zh_CN.utf8\");\n\n    // 下位机控制节点\n    ros::init(argc, argv, \"lidar_handle_node\");\n\n    ros::NodeHandle nh_;                                                     // 节点管理工具\n    ros::Subscriber lidar_sub_ = nh_.subscribe(\"/scan\", 10, &LidarCallback); // 订阅雷达数据\n\n    vel_pub = nh_.advertise<geometry_msgs::Twist>(\"/cmd_vel\", 10);\n\n    ros::spin();\n\n    return 0;\n}\n~~~\n\n\n\n## 3.7 栅格地图\n\n创建一个软件包`map_pkg`，用来发布地图数据。\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs/src$ catkin_create_pkg map_pkg roscpp rospy nav_msgs\nCreated file map_pkg/package.xml\nCreated file map_pkg/CMakeLists.txt\nCreated folder map_pkg/include/map_pkg\nCreated folder map_pkg/src\nSuccessfully created files in /home/haozi/work/develop/TspCarWs/src/map_pkg. Please adjust the values in package.xml.\n~~~\n\n\n\n只创建一个main文件，发布一个固定的地图。\n\nmain.cpp\n\n~~~ cpp\n#include <ros/ros.h>\n#include <nav_msgs/OccupancyGrid.h>\n\nint main(int argc, char *argv[])\n{\n    // 防止ROS_INFO中文乱码\n    setlocale(LC_CTYPE, \"zh_CN.utf8\");\n\n    // 下位机控制节点\n    ros::init(argc, argv, \"map_pub_node\");\n\n    ros::NodeHandle nh_;                                                            // 节点管理工具\n    ros::Publisher map_pub_ = nh_.advertise<nav_msgs::OccupancyGrid>(\"/map\", 10); // 发布地图数据\n\n    // 每秒一次\n    ros::Rate r(1);\n\n    while (ros::ok())\n    {\n        nav_msgs::OccupancyGrid msg;\n\n        msg.header.frame_id = \"map\";\n        msg.header.stamp = ros::Time::now();\n\n        msg.info.origin.position.x = 0;\n        msg.info.origin.position.y = 0;\n        msg.info.resolution = 1.0; // 栅格分辨率（每个格子1米）\n        msg.info.width = 4;        // 地图宽度（格子数）\n        msg.info.height = 2;       // 地图高度（格子数）\n\n        msg.data.resize(4 * 2); // 地图数据\n        msg.data[0] = 100;\n        msg.data[1] = 100;\n        msg.data[2] = 0;\n        msg.data[3] = -1;\n\n        map_pub_.publish(msg);\n        r.sleep();\n    }\n    return 0;\n}\n~~~\n\n\n\n将软件包运行起来。\n\n然后启动rviz工具，查看发布的栅格地图。\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs$ rviz\n~~~\n\n启动rviz之后，添加一个地图原点`Axes`，添加一个地图`map`，并将地图消息类型`Topic`修改为`/map`，就可以看到发布的测试消息了。\n\n![测试栅格地图](./ros1/测试栅格地图.jpg)\n\n\n\n\n\n## 3.8 SLAM\n\n地图创建流程为：\n\n1. 激光雷达节点，发布雷达数据`/scan`\n2. SLAM节点，接收雷达数据`/scan`，发送地图数据`/map`\n3. 其他节点，接收地图数据`/map`\n\n也就是，SLAM节点接收雷达数据后，经过处理就可以得到地图数据了。\n\n\n\n其中SLAM节点有现成的软件包可以用，比如`Hector_Mapping`\n\n\n\n### 3.8.1 Hector_Mapping\n\n安装软件包\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs$ sudo apt install ros-noetic-hector-mapping\n~~~\n\n运行Hector_Mapping节点\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs$ rosrun hector_mapping hector_mapping\n~~~\n\nrviz查看建图数据\n\n~~~ sh\nhaozi@haozi:~$ rosrun rviz rviz\n~~~\n\n\n\n创建一个新的软件包`slam_pkg`\n\n~~~ sh\nhaozi@haozi:~/work/develop/TspCarWs/src$ catkin_create_pkg slam_pkg roscpp rospy std_msgs\nCreated file slam_pkg/package.xml\nCreated file slam_pkg/CMakeLists.txt\nCreated folder slam_pkg/include/slam_pkg\nCreated folder slam_pkg/src\nSuccessfully created files in /home/haozi/work/develop/TspCarWs/src/slam_pkg. Please adjust the values in package.xml.\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["ROS","ROS1"],"categories":["Linux应用"]},{"title":"充电桩国标协议解析","url":"/2025/06/01/10. 国际标准/充电桩国标/","content":"\n\n\n# 1. 国标概述\n\n> 以2015国标（新国标）为主进行记录，对于2011国标（老国标）中有不同的地方进行补充。\n\n国标充电文件主要有以下几个：\n\n* `GBT_18487.1-2015`：主要描述了充电桩与车辆之间的**电气连接方式（连接方式C常用）**、**充电控制引导电路原理和信号编号、充电过程中状态和流程图**。\n* `GBT20234.1-2015`：主要是电气连接设备通用要求，包含**充电流程描述、控制时序、直流充电电压最大1000V，电流最大400A**。\n* `GBT20234.2-2015`：交流充电接口规定。\n* `GBT20234.3-2015`：直流充电接口规定，**包含充电插座中线的信号定义**。\n\n> 目前，最大电压电流分别为1000V、400A，然后根据充电枪线的限制，来做软件上的最大电流限制。\n\n* `GBT27930-2015`：充电机和车辆之间的通信协议规定，**软件重点**。\n\n\n\n# 2. 充电流程\n\n1. 物理接连完成\n2. 低压辅助上电\n3. 充电握手阶段\n4. 充电参数配置阶段\n5. 充电阶段\n6. 充电结束阶段\n7. 结束充电\n\n\n\n# 3. 通信协议\n\n总则：\n\n* 使用CAN2.0B通信协议\n* CAN协议采用`SAE J1939-21`协议\n* CANID使用扩展帧数据格式\n  * 数据传输有两个节点，充电机、BMS\n* 数据传输采用低字节在前格式\n  * 电流正数代表放电，电流负数表示充电（TODO???）\n\n**ID数据格式**\n\nID使用29位扩展帧格式。\n\n地址定义：\n\n* **充电机：0x56**（十进制86）\n* **BMS：0xF4**（十进制244）\n\n~~~ c\n/*\nSA：源地址\nPS：目标地址\nPF：命令码（PGN）\nDP：数据页，固定0\nR：保留，固定0\nP：优先权\n*/\n\ntypedef union _can_id\n{\n    uint32_t id;\n    struct\n    {\n        // 从低到高\n        uint32_t sa : 8; // 源地址\n        uint32_t ps : 8; // 目标地址\n        uint32_t pf : 8; // puu格式，确定数据域参数组编号（PGN的第二个字节）\n        uint32_t dp : 1; // 数据页，固定为0\n        uint32_t r : 1;  // 保留位，固定为0\n        uint32_t p : 3;  // 优先权\n        uint32_t : 3;\n    } bits;\n} can_id_t;\n~~~\n\n\n\n## 3.1 物理连接\n\n当充电枪与车辆连接完成后，充电枪上的按键S闭合，R2和R4并联后和R1串联，供电电源12V最终分压为4V。\n\n即：**充电机检测到`CC1`电压为`4V`时，表示充电枪与车辆连接完成**。\n\n\n\n\n\n![车辆连接完成](./充电桩国标/车辆连接完成.jpg)\n\n## 3.2 低压辅助上电\n\n检测到车辆连接完成后，闭合继电器`K3、K4`，通过充电枪线上的`A+、A-`两根线给BMS低压辅助上电。\n\n此时，才能和车辆进行CAN通信。\n\n![低压辅助供电](./充电桩国标/低压辅助供电.jpg)\n\n\n\n\n\n## 3.3 充电握手\n\n充电握手分为两个阶段。\n\n**阶段一：握手启动**\n\n1. 充电机给BMS发送充电握手报文`CHM`，周期250ms\n2. 车辆回应充电机车辆握手报文`BHM`，周期250ms\n\n| 报文代号 | 描述       | PGN      | 优先权 | 源地址 | 目标地址 | 数据长度 | 数据（从低到高） |\n| -------- | ---------- | -------- | ------ | ------ | -------- | -------- | ---------------- |\n| CHM      | 充电机握手 | 0x002600 | 6      | 充电机 | BMS      | 3        | 0x01, 0x01, 0x00 |\n| BHM      | 车辆握手   | 0x002700 | 6      | BMS    | 充电机   | 2        | 0x58, 0x1B       |\n\n其中：\n\n* CHM数据部分表示：充电机通信协议版本，一般为1.1\n* BHM数据部分表示：电池最高允许电压，单位`0.1V`，比如上述0x1B58表示最高允许电压为700V\n\n\n\n**绝缘检测** \n\n开始绝缘检测，可以使用最高允许的电压进行。等待绝缘检测完成。\n\n\n\n**阶段二：握手参数辨识**\n\n1. 充电机给BMS发送充电机辨识报文`CRM`，周期250ms\n2. 车辆回应充电机车辆辨识报文`BRM`，周期250ms\n\n\n| 报文代号 | 描述       | PGN      | 优先权 | 源地址 | 目标地址 | 数据长度 | 数据 |\n| -------- | ---------- | -------- | ------ | ------ | -------- | -------- | ---- |\n| CRM      | 充电机辨识 | 0x000100 | 6      | 充电机 | BMS      | 8        |      |\n| BRM      | BMS辨识    | 0x000200 | 7      | BMS    | 充电机   | 41       |      |\n\n其中\n\n* CRM数据部分：\n  1. 字节1：未辨识到BMS报文前0x00，收到BMS辨识报文后0xAA；\n  2. 字节2-5：充电机编号，范围0到0xFFFFFFFF；\n  3. 字节6-8：充电机所在的区域编码，ASCII编码。（非必须）\n* BRM数据部分（超过8字节，需要进行多帧发送）：\n  1. 字节1-3：BMS协议版本号，同CHM部分；\n  2. 字节4：电池类型，枚举。\n  3. 字节5-6：电池额定容量\n  4. 字节7-8：电池额定总电压\n  5. 字节9-12：厂商名称，ASCII编码（非必须）\n  6. 字节13-16：电池组序号（非必须）\n  7. 字节17：电池生产日期，年，偏移1985（非必须）\n  8. 字节18：电池生产日期，月，偏移0（非必须）\n  9. 字节19：电池生产日期，日，偏移0（非必须）\n  10. 字节20-22：电池充电次数（非必须）\n  11. 字节23：电池组产权（非必须）\n  12. 字节24：预留（非必须）\n  13. 字节25-41：VIN，车辆识别码（非必须）\n  14. 字节42-49：BMS软件号（非必须）\n\n\n\n## 3.4 充电参数配置阶段\n\n握手完成后进入充电参数配置。\n\n充电机向BMS发送最大输出能力，BMS判断是否能够充电。\n\n| 报文代号 | 描述               | PGN      | 优先权 | 源地址 | 目标地址 | 数据长度 | 数据 |\n| -------- | ------------------ | -------- | ------ | ------ | -------- | -------- | ---- |\n| BCP      | 电池充电参数       | 0x000600 | 7      | BMS    | 充电机   | 13       |      |\n| CTS      | 时间同步信息       | 0x000700 | 6      | 充电机 | BMS      | 7        |      |\n| CML      | 充电机最大输出能力 | 0x000800 | 6      | 充电机 | BMS      | 8        |      |\n| BRO      | 电池就绪状态       | 0x000900 | 4      | BMS    | 充电机   | 1        |      |\n| CRO      | 充电机就绪状态     | 0x000A00 | 4      | 充电机 | BMS      | 1        |      |\n\n* BCP数据部分：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["充电桩国标","CAN"],"categories":["标准"]},{"title":"qt学习笔记","url":"/2025/01/01/06. 上位机开发/qt/","content":"\n\n\n\n\n# 1. 布局管理器（layouts）\n\n**用于管理控件在窗口中的排列和布局，直接需要对齐的空间直接拖入对应的区域即可，属性中可选择左右对齐或居中**\n\n## 1.1. Vertical Layout\n\n* 作用：将子控件垂直排列。\n\n* 使用场景：适用于需要将控件按列排列的场景，如表单输入、垂直按钮组等。\n\n## 1.2. Horizontal Layout\n\n* 作用：将子控件水平排列。\n* 使用场景：适用于需要将控件按行排列的场景，如工具栏、按钮行等。\n\n## 1.3. Grid Layout\n\n* 作用：将子控件按网格排列。\n* 使用场景：适用于需要将控件按行列排列的场景，如表单布局、计算器键盘布局等。\n\n## 1.4. Form Layout\n\n* 作用：将子控件按表单布局排列，每行通常包含一个标签和一个输入控件。\n* 使用场景：适用于需要创建表单的场景，如用户注册界面、设置对话框等。\n\n\n\n# 2. 按钮（Buttons）\n\n\n## 2.1. Push Button\n\n* 功能：通用的可点击按钮，用户可以通过点击按钮触发特定操作。\n* 使用场景：适用于所有需要触发操作的场景，如提交表单、启动某个功能等。\n\n## 2.2. Tool Button\n\n* 功能：类似于 QPushButton，但设计用于工具栏和工具栏按钮，通常带有图标和文本。\n* 使用场景：适用于工具栏中的按钮或需要图标的按钮，如文本编辑器中的格式化工具栏按钮。\n\n## 2.3. Radio Button\n\n* 功能：单选按钮，用户可以在一组选项中选择一个。\n* 使用场景：适用于需要用户在一组选项中选择一个的场景，如表单中的性别选择。\n\n## 2.4. Check Box\n\n* 功能：用于表示二选一的状态（选中或未选中）。\n* 使用场景：适用于需要用户选择是或否的场景，如同意条款、选择偏好设置。\n\n## 2.5. Command Link Button\n\n* 功能：扩展了 QPushButton，提供了更丰富的界面元素，包括图标、大文本和描述文本。\n* 使用场景：适用于需要更多信息来描述按钮功能的场景，如安装向导中的步骤按钮。\n\n## 2.6. Dialog Button Box\n\n* 功能：标准对话框按钮的容器，提供了常用按钮（如 OK、Cancel）的一致布局和行为。\n* 使用场景：适用于需要标准对话框按钮的场景，如确认对话框、设置对话框等。\n\n\n\n# 3. 项目视图组件（Item Views）\n\n\n## 3.1. List View\n\n* 功能：用于显示简单的列表，列表中的每一项可以包含文本、图标或自定义小部件。\n* 使用场景：适用于需要显示简单列表的场景，如文件列表、联系人列表等。\n\n## 3.2. Tree View\n\n* 功能：用于显示树状结构的数据，支持多列数据。\n* 使用场景：适用于需要显示层次结构的场景，如文件系统视图、组织结构图等。\n\n## 3.3. Table View\n\n* 功能：用于显示表格数据，每个单元格可以包含文本、图标或自定义小部件。\n* 使用场景：适用于需要显示二维网格数据的场景，如电子表格、数据库表等。\n\n## 3.4. Column View\n\n* 功能：用于显示分级数据，类似于 macOS Finder 中的列视图。\n* 使用场景：适用于需要分级显示数据的场景，如文件系统浏览器。\n\n## 3.5. Undo View\n\n* 功能：QUndoView 显示撤销和重做堆栈中的命令列表，用户可以通过点击视图中的条目来执行撤销或重做操作。\n* 使用场景：适用于需要提供撤销和重做功能的应用程序，如文本编辑器、绘图应用等。\n\n\n\n# 4. 显示和管理数据的控件（Item Widgets）\n\n\n## 4.1. List Widget\n\n* 功能：用于显示一组项目（项），每个项目可以包含文本和图标。\n* 使用场景：适用于需要显示简单列表的场景，如文件列表、联系人列表等。\n\n## 4.2. Tree Widget\n\n* 功能：用于显示层次结构的项目（项），每个项目可以包含子项目。\n* 使用场景：适用于需要显示树状结构的场景，如文件系统视图、组织结构图等。\n\n## 4.3. Table Widget\n\n* 功能：用于显示表格数据，每个项目可以包含文本和图标。\n* 使用场景：适用于需要显示网格状数据的场景，如电子表格、数据库表等。\n\n参数/属性\n\n* currentTabText：修改显示的标签名\n* currentTabName：修改控件名\n* font：修改字体大小\n\n~~~ c++\n// 设置选项卡的形状 默认圆形Rounde 三角形Triangular\nui->tabWidget->setTabShape(QTabWidget::Triangular);\n~~~\n\n```c++\n// 设置字体颜色\nui->tabWidget->tabBar()->setTabTextColor(0,QColor(0,0,255));\n```\n\n\n\n# 5. 容器组件（Containers）\n\n## 5.1. Group Box\n\n* 功能：QGroupBox 是一个分组框，可以包含多个控件，并带有标题。\n* 使用场景：适用于需要对控件进行逻辑分组的场景，如表单中的分节。\n\n## 5.2. Scroll Area\n\n* 功能：QScrollArea 是一个滚动区域，可以包含一个大于其显示区域的控件，并提供滚动条。\n* 使用场景：适用于需要显示超过可见区域内容的场景，如图片查看器、长表单。\n\n## 5.3. Tab Widget\n\n* 功能：QTabWidget 是一个选项卡容器，可以包含多个选项卡，每个选项卡包含一个子控件。\n* 使用场景：适用于需要分多个页面显示内容的场景，如设置界面。\n\n## 5.4. Stacked Widget\n\n* 功能：QStackedWidget 是一个堆叠容器，可以在多个子控件之间切换。\n* 使用场景：适用于需要在不同视图之间切换的场景，如向导对话框。\n\n## 5.5. Widget\n\n* 功能：QWidget 是所有用户界面对象的基类，它可以作为一个简单的容器，包含和管理子控件。\n* 使用场景：适用于任何需要基本容器的场景，通常作为窗口或对话框的基础。\n\n\n\n# 6. 输入控件（Intput Widgets）\n\n## 6.1. Line Edit\n\n* 功能：用于单行文本输入。\n* 使用场景：适用于获取单行文本输入的场景，如用户名、密码、搜索框。\n\n## 6.2. Text Edit\n\n* 功能：用于多行文本输入，可以包含富文本。\n* 使用场景：适用于获取多行文本输入的场景，如备注、文章编辑器。\n\n## 6.3. PlainText Edit\n\n* 功能：用于多行纯文本输入，不支持富文本。\n* 使用场景：适用于获取多行纯文本输入的场景，如代码编辑器、日志查看器。\n\n## 6.4. Spin Box\n\n* 功能：用于输入整数，可以通过箭头按钮增加或减少值。\n* 使用场景：适用于需要输入整数的场景，如数量、年龄。\n\n## 6.5. Double Spin Box\n\n* 功能：用于输入浮点数，可以通过箭头按钮增加或减少值。\n* 使用场景：适用于需要输入浮点数的场景，如价格、权重。\n\n## 6.6. Date Edit\n\n* 功能：用于输入日期，可以通过日历选择器选择日期。\n* 使用场景：适用于需要输入日期的场景，如生日、预约日期。\n\n## 6.7. Time Edit\n\n* 功能：用于输入时间。\n* 使用场景：适用于需要输入时间的场景，如会议时间、闹钟时间。\n\n## 6.8. DateTime Edit\n\n* 功能：用于输入日期和时间。\n* 使用场景：适用于需要同时输入日期和时间的场景，如事件时间戳。\n\n## 6.9. Combo Box\n\n* 功能：用于显示下拉列表，用户可以从中选择一项。\n* 使用场景：适用于需要用户从预定义选项中选择的场景，如选择国家、选择颜色。\n\n## 6.10. Slider\n\n* 功能：用于显示和选择范围值，可以是水平或垂直滑动条。\n* 使用场景：适用于需要显示和选择范围值的场景，如亮度调节、音量调节。\n\n## 6.11. Dial\n\n* 功能：用于显示和选择范围值，类似于旋钮。\n* 使用场景：适用于需要显示和选择范围值的场景，如音量控制、速度控制。\n\n\n\n# 7.显示控件（Display Widgets）\n## 7.1. Label\n\n* 功能：用于显示文本或图像。\n* 使用场景：适用于需要显示静态文本、图像或其他内容的场景，如标签、标题。\n\n## 7.2. Text Browser\n\n* 功能：用于显示富文本，支持超链接和 HTML。\n* 使用场景：适用于需要显示复杂富文本内容的场景，如帮助文档、显示网页内容。\n\n## 7.3. Calendar Widget\n\n* 功能：用于显示日历，可以选择日期。\n* 使用场景：适用于需要显示和选择日期的场景，如日期选择器。\n\n## 7.4. LCD Number\n\n* 功能：用于显示数字，类似于 LCD 显示屏。\n* 使用场景：适用于需要显示数值的场景，如计时器、计数器。\n\n\n\n\n\n\n\n","tags":["QT"],"categories":["上位机开发"]},{"title":"ros2学习笔记","url":"/2024/01/01/04. Linux应用/ros2/","content":"\n\n\n# 1. 环境准备\n\n## 1.1 Linux\n\n* 这里使用的`ubuntu 20.04.3`\n\n* 镜像名称：ubuntu-20.04.6-desktop-amd64.iso（文件大小：4.05G）\n\n* 下载地址：http://mirrors.ustc.edu.cn/ubuntu-releases/\n\n* 安装方法：参考【正点原子】I.MX6U嵌入式Linux C应用编程指南V1.4。**第一章**\n\n* 配置方法：参考【正点原子】I.MX6U嵌入式Linux C应用编程指南V1.4。**第四章**（按需配置）\n\n  * ubuntu下的ftp服务\n\n    ~~~ sh\n    # 1 安装服务\n    sudo apt-get install vsftpd\n    # 2 修改配置文件\n    sudo vi /etc/vsftpd.conf\n    # 打开下面两行的注释\n    local_enable=YES\n    write_enable=YES\n    \n    # 3 重启服务\n    sudo /etc/init.d/vsftpd restart\n    ~~~\n\n    \n\n> 这里配置了：\n>\n> 1. ubuntu下的ftp服务\n> 2. 电脑端安装MobaXterm软件\n\n## 1.2 Ros2\n\n* 这里使用的是`foxy版本`。\n\n* 安装方式1：https://fishros.com/d2lros2/#/\n\n~~~ sh\nwget http://fishros.com/install -O fishros && bash fishros\n~~~\n\n> ROS2入门篇 -> 动手安装ROS2 -> 一键安装ROS2。\n\n* 安装方式2：手动安装\n\n~~~ sh\n# 下载密钥\nsudo apt install curl gnupg2 -y\n\ncurl -s https://gitee.com/ohhuo/rosdistro/raw/master/ros.asc | sudo apt-key add -\n\n# 导出到系统\necho \"deb [arch=$(dpkg --print-architecture)] https://repo.huaweicloud.com/ros2/ubuntu/ $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null\n\n# 更新\nsudo apt update\n\n# 安装\nsudo apt install ros-foxy-desktop\n\n# 安装额外依赖\nsudo apt install python3-argcomplete -y\n\n# 配置环境变量\necho \"source /opt/ros/foxy/setup.bash\" >> ~/.bashrc\n\n# 添加源\nsource /opt/ros/foxy/setup.bash\n# 查看结果\nros2\n~~~\n\n* 卸载方式\n\n~~~ sh\nsudo apt remove ros-foxy-* && sudo apt autoremove\n~~~\n\n\n\n## 1.3 VScode\n\n1. 下载安装包 地址：https://code.visualstudio.com/\n\n   软件包名称：code_1.85.1-1702462158_amd64.deb\n\n2. 传输安装包到ubuntu\n\n3. 安装（在安装包目录下输入）\n\n   ~~~ sh\n   sudo dpkg -i code_1.85.1-1702462158_amd64.deb \n   ~~~\n\n> 上面的一键安装还可以，也可以自己装。\n\n\n\n# 2. 命令行\n\n## 2.1 案例\n\n**自带案例**\n\n~~~ sh\n# 格式 #\nros2 run <package_name> <executable_name>  # 启动包下面的节点\n\n# 1.启动一只海龟 #\nros2 run turtlesim turtlesim_node\t\t# 创建一个海龟(shell 1)\nros2 run turtlesim turtle_teleop_key\t# 添加一个控制程序(shell 2)\n\n# 2. 节点相关 #\nros2 node\t\t\t# 查看此命令帮助信息\nros2 node list\t\t# 查看当前节点列表(shell 3)\n#结果如下\n/teleop_turtle\n/turtlesim\nros2 node info /teleop_turtle\t# 查看节点信息(最后是节点名)(shell 3)\n\n# 3. 话题相关 #\nros2 topic \t\t\t# 查看此命令帮助信息\nros2 topic list\t\t# 查看当前话题列表(shell 3)\n#结果如下\n/parameter_events\n/rosout\n/turtle1/cmd_vel    # turtle1是默认的海龟名字\n/turtle1/color_sensor\n/turtle1/pose\t\t# 海龟的姿势\nros2 topic echo /turtle1/pose\t# ehco:订阅该话题,不断收到位置信息(shell 3)\nros2 topic pub --rate  1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear:{x: 2.0, y: 0.0, z: 0.0}, angular:{x: 0.0, y: 0.0, z: 1.8}}\"\npublisher: beginning loop\t\t# 发布话题控制海龟做圆周运动(shell 3)\n#停止后，继续下面操作\nros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: \"abc\"}\"  # 创建一只新海龟(shell 3)\n#停止后，继续下面操作\nros2 topic list\t # 再次查看话题(shell 3)\n/abc/cmd_vel\t# 多了abc海龟的\n/abc/color_sensor\n/abc/pose\n/parameter_events\n/rosout\n/turtle1/cmd_vel\n/turtle1/color_sensor\n/turtle1/pose\nros2 topic pub --rate  1 /abc/cmd_vel geometry_msgs/msg/Twist \"{linear:{x: 2.0, y: 0.0, z: 0.0}, angular:{x: 0.0, y: 0.0, z: 1.8}}\"  # 控制abc海龟圆周运动\n\n#停止后，继续下面操作\n# 3. 记录 #\nros2 bag\t\t\t\t\t\t\t# 查看命令帮助信息\nros2 bag record /turtle1/cmd_vel\t# 记录turtle1的速度信息\n# 结束之后会保存到当前shell的目录下\nros2 bag play rosbag2_2023_11_02-17_14_36/  # 复现刚刚记录的路径信息（最后是保存的文件夹名称）\n~~~\n\n## 2.3 总结\n\n~~~ sh\n# 运行节点(常用)\nros2 run <package_name> <executable_name>\n# 查看节点列表(常用)：\nros2 node list\n# 查看节点信息(常用)：\nros2 node info <node_name>\n~~~\n\n\n\n\n\n# 3. 开始编程\n\n## 3.1 简单概念\n\n* 工作空间：存放项目开发相关文件的文件夹。\n* 功能包：功能源码。ROS软件中的基本单元，包含节点源码、配置文件、数据定义等\n* 节点：工作细胞。执行单元。\n* 话题：节点间传递数据的桥梁。异步通信。发布者/订阅者模型。多对多。用于数据传输。\n* 服务：节点间的你问我答。同步通信。客户端/服务器模型。一对多。多用逻辑处理。\n* 通信接口：数据传递的标准结构。\n* 参数：机器人系统的全局字典。\n* 动作：完整行为的流程管理\n* 分布式通信：多计算平台的任务分配\n* DDS：机器人的神经网络\n\n## 3.2 文件结构\n\n* WorkSpace\n\n  * src：代码空间，源代码，功能包\n\n  * install：安装\n  * build：编译\n  * log：日志\n\n## 3.3 编译工具\n\n（可能）用到的工具，也不知道啥时候用到，反正都装上就行了。\n\n~~~ sh\n# g++\nsudo apt install g++\n# 编译指令\ng++ hello_world.cpp\n\n# make\nsudo apt install make\n# 编译指令（在Makefile同级目录）\nmake build\n\n# Cmake\nsudo apt install cmake\n# 先不用\n\n# colcon 功能包构建工具\nsudo apt-get install python3-colcon-common-extensions\n# 编译指令\ncolcon build\n~~~\n\n## 3.4 创建ROS节点\n\n1. 建立工作空间文件夹\n\n~~~ sh\n# ros2文件夹存放所有的ros工程（可以不要）\nhaozi@haozi-machine:~/ros2$ pwd\n/home/haozi/ros2\n# 创建工作空间\nhaozi@haozi-machine:~/ros2$ mkdir test_ws\n# test_ws文件夹就是一个工作空间\nhaozi@haozi-machine:~/ros2$ ls\ntest_ws\n~~~\n\n2. 创建src文件夹\n\n~~~ sh\n# 进入工作空间\nhaozi@haozi-machine:~/ros2$ cd test_ws\n# 创建src文件夹\nhaozi@haozi-machine:~/ros2/test_ws$ mkdir src\nhaozi@haozi-machine:~/ros2/test_ws$ ls\nsrc\n~~~\n\n3. 创建一个功能包\n\n~~~ sh\n# 先进入src文件夹\nhaozi@haozi-machine:~/ros2/test_ws$ cd src/\n# 创建example_cpp功能包，使用ament-cmake作为编译类型，并为其添加rclcpp依赖。\nhaozi@haozi-machine:~/ros2/test_ws/src$ ros2 pkg create example_cpp --build-type ament_cmake --dependencies rclcpp\ngoing to create a new package\npackage name: example_cpp\ndestination directory: /home/haozi/ros2/test_ws/src\npackage format: 3\nversion: 0.0.0\ndescription: TODO: Package description\nmaintainer: ['haozi <haozi@todo.todo>']\nlicenses: ['TODO: License declaration']\nbuild type: ament_cmake\ndependencies: ['rclcpp']\ncreating folder ./example_cpp\ncreating ./example_cpp/package.xml\ncreating source and include folder\ncreating folder ./example_cpp/src\ncreating folder ./example_cpp/include/example_cpp\ncreating ./example_cpp/CMakeLists.txt\n# src文件夹下多出 example_cpp 文件夹\nhaozi@haozi-machine:~/ros2/test_ws/src$ ls\nexample_cpp\n~~~\n\n> - pkg create 是创建包的意思\n> - --build-type 用来指定该包的编译类型，一共有三个可选项`ament_python`、`ament_cmake`、`cmake`\n> - --dependencies 指的是这个功能包的依赖，这里是ros2的C++客户端接口`rclcpp`\n\n此时的目录就会变成这个样子\n\n* test_ws\n  * src\n    * example_cpp\n      * Cmakelists.txt\n      * include\n        * example_cpp\n      * package.xml\n      * src\n\n4. 创建节点\n\n在test_ws/src/example_cpp/src文件夹下创建 node.cpp 文件，方法任意。\n\n~~~ sh\nhaozi@haozi-machine:~/ros2/test_ws/src/example_cpp/src$ pwd\n/home/haozi/ros2/test_ws/src/example_cpp/src\nhaozi@haozi-machine:~/ros2/test_ws/src/example_cpp/src$ ls\nnode.cpp\n~~~\n\n文件内容如下：\n\n~~~ c++\n#include \"rclcpp/rclcpp.hpp\"\n\nint main(int argc, char **argv)\n{\n    /* 初始化rclcpp  */\n    rclcpp::init(argc, argv);\n    /*产生一个node的节点*/\n    auto node = std::make_shared<rclcpp::Node>(\"node\");\n    // 打印一句自我介绍\n    RCLCPP_INFO(node->get_logger(), \"node节点已经启动.\");\n    /* 运行节点，并检测退出信号 Ctrl+C*/\n    rclcpp::spin(node);\n    /* 停止运行 */\n    rclcpp::shutdown();\n    return 0;\n}\n~~~\n\n完成后目录如下：\n\ntest_ws\n\n* src\n  * example_cpp\n    * Cmakelists.txt\n    * include\n      * example_cpp\n    * package.xml\n    * src\n      * node.cpp\n\n5. 修改CmakeLists\n\n在 CMakeLists.txt 的最后添加如下代码，将其添加为可执行文件，并使用`install`指令将其安装到`install`目录。\n\n~~~ cmake\n# 添加可执行目标node, 参数为node.cpp\nadd_executable(node src/node.cpp)\nament_target_dependencies(node rclcpp)\n\ninstall(TARGETS\n  node\n  DESTINATION lib/${PROJECT_NAME}\n)\n~~~\n\n6. 编译节点\n\n~~~ sh\n# cd回到工作空间目录\nhaozi@haozi-machine:~/ros2/test_ws$ pwd\n/home/haozi/ros2/test_ws\n# 执行编译（上面修改的文件一定要点保存之后再编译）\nhaozi@haozi-machine:~/ros2/test_ws$ colcon build\nStarting >>> example_cpp\nFinished <<< example_cpp [4.87s]                  \n\nSummary: 1 package finished [8.85s]\n# 编译完成可以看到多出来几个文件夹\nhaozi@haozi-machine:~/ros2/test_ws$ ls\nbuild  install  log  src\n~~~\n\n7. source环境\n\n~~~ sh\nhaozi@haozi-machine:~/ros2/test_ws$ source install/setup.bash\n~~~\n\n8. 运行节点\n\n~~~ sh\nhaozi@haozi-machine:~/ros2/test_ws$ ros2 run example_cpp node\n[INFO] [1698995834.649833335] [node]: node节点已经启动.\n~~~\n\n9. 测试\n\n另开一个窗口，查看现有节点。\n\n~~~ sh\nhaozi@haozi-machine:~/ros2/test_ws$ ros2 node list\n/node\n~~~\n\n> 如果`ros2 node list`显示不出来，就使用`ros2 node list --no-daemon`。理由未知。\n\n至此，自己编写代码的流程就结束了。每次修改完成之后，需要重新编译，添加资源。\n\n\n\n补充：\n\n~~~ sh\n# 只编译一个包\ncolcon build --packages-select YOUR_PKG_NAME \n\n# 允许通过更改src下的部分文件来改变install（重要）（不知道啥意思）\n# 每次调整 python 脚本时都不必重新build了\ncolcon build --symlink-install\n~~~\n\n\n\n# 4. 四大通信\n\n通信方式：**话题**、**服务**、动作、参数\n\n媒介：**接口**\n\n> 本章节所有代码都将在一个工作空间下完成\n\n![目录案例](./ros2/目录案例.jpg)\n\n## 4.1 话题\n\n> 同一个话题，发布者和订阅者都可以有多个。\n>\n> 一对一、多对一、一对多、多对多，都可以。\n\n### 4.1.1 自带案例\n\n~~~ shell\n# 运行ros自带的两个案例\nhaozi@haozi-machine:~$ ros2 run demo_nodes_cpp talker\nhaozi@haozi-machine:~$ ros2 run demo_nodes_py listener\n\n# 查看节点关系图\nrqt_graph\n\n# 话题相关指令\nros2 topic -h\n\nros2 topic list\t\t# 返回系统中当前活动的所有主题的列表\nros2 topic list -t\t# 增加消息类型\nros2 topic echo /chatter\t# 打印实时话题内容\nros2 topic info /chatter\t# 查看主题信息\nros2 interface show std_msgs/msg/String\t# 查看消息类型\nros2 topic pub /chatter std_msgs/msg/String 'data: \"123\"'\t# 手动发布消息\n~~~\n\n\n\n### 4.1.2 自定义案例\n\n**新建一个包：example_topic，在这里面编写话题测试案例**\n\n![目录案例](./ros2/topic目录.jpg)\n\n\n\n创建话题发布者程序流程\n\n1. 导入相关接口（若有）\n2. 编程接口初始化\n3. 创建节点并初始化\n4. 创建发布者对象\n5. 创建并填充话题消息\n6. 发布话题消息\n7. 销毁节点并关闭接口\n\n创建话题订阅者程序流程\n\n1. 导入相关接口（若有）\n2. 编程接口初始化\n3. 创建节点并初始化\n4. 创建订阅者对象\n5. 回调函数处理话题数据\n6. 销毁节点并关闭接口\n\n\n\n第一步：在包下的src文件夹中新建文件：`pub.cpp`，在这个文件中编写发布者代码。\n\n~~~ c++\n#include \"rclcpp/rclcpp.hpp\"\n// 消息类型头文件\n#include \"std_msgs/msg/string.hpp\"\n#include \"std_msgs/msg/u_int32.hpp\"\n\n// 定义一个类\nclass TopicPublisher : public rclcpp::Node\n{\nprivate:\n    // 声名定时器指针\n    rclcpp::TimerBase::SharedPtr timer_;\n    // 声明话题发布者指针\n    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr command_publisher_;\n    // 定时器回调函数\n    void timer_callback()\n    {\n        // 创建消息\n        std_msgs::msg::String message;\n        message.data = \"text\";\n        // 日志打印\n        RCLCPP_INFO(this->get_logger(), \"Publishing: '%s'\", message.data.c_str());\n        // 发布消息\n        command_publisher_->publish(message);\n    }\n\npublic:\n    // 构造函数,有一个参数为节点名称\n    TopicPublisher(std::string name) : Node(name)\n    {\n        RCLCPP_INFO(this->get_logger(), \"大家好，我是%s.\", name.c_str());\n        // 创建发布者（发布话题名称为：sexy_girl）\n        command_publisher_ = this->create_publisher<std_msgs::msg::String>(\"sexy_girl\", 10);\n        // 创建定时器，500ms为周期，定时发布消息\n        timer_ = this->create_wall_timer(std::chrono::milliseconds(500), std::bind(&TopicPublisher::timer_callback, this));\n    }\n};\n\nint main(int argc, char **argv)\n{\n    rclcpp::init(argc, argv);\n    /*产生一个节点*/\n    auto node = std::make_shared<TopicPublisher>(\"pub\");\n    /* 运行节点，并检测退出信号*/\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}\n~~~\n\n第二步：在包下的src文件夹中新建文件：`sub.cpp`，在这个文件中编写订阅者代码。\n\n~~~ c++\n#include \"rclcpp/rclcpp.hpp\"\n// 消息类型头文件\n#include \"std_msgs/msg/string.hpp\"\n#include \"std_msgs/msg/u_int32.hpp\"\n\nusing std::placeholders::_1;\nusing std::placeholders::_2;\n\n// 定义一个类\nclass TopicSublisher : public rclcpp::Node\n{\nprivate:\n    // 声明一个订阅者（成员变量）,用于订阅小说\n    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr sub_novel;\n\n    // 声明一个发布者（成员变量）,用于给钱\n    rclcpp::Publisher<std_msgs::msg::UInt32>::SharedPtr pub_money;\n\n    // 收到话题数据的回调函数\n    void topic_callback(const std_msgs::msg::String::SharedPtr msg)\n    {\n        // 新建一张人民币\n        std_msgs::msg::UInt32 money;\n        money.data = 10;\n        // 发送人民币\n        pub_money->publish(money);\n\n        RCLCPP_INFO(this->get_logger(), \"朕已阅：'%s'，打赏：%d 元稿费\", msg->data.c_str(), money.data);\n    };\n\npublic:\n    // 构造函数,有一个参数为节点名称\n    TopicSublisher(std::string name) : Node(name)\n    {\n        // 打印一句自我介绍\n        RCLCPP_INFO(this->get_logger(), \"大家好，我是%s.\", name.c_str());\n        // 创建一个订阅者来订阅小说，通过名字sexy_girl\n        sub_novel = this->create_subscription<std_msgs::msg::String>(\"sexy_girl\", 10, std::bind(&TopicSublisher::topic_callback, this, _1));\n        // 创建发布者\n        pub_money = this->create_publisher<std_msgs::msg::UInt32>(\"sexy_girl_money\", 10);\n    }\n};\n\nint main(int argc, char **argv)\n{\n    rclcpp::init(argc, argv);\n    /*产生一个节点*/\n    auto node = std::make_shared<TopicSublisher>(\"sub\");\n    /* 运行节点，并检测退出信号*/\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}\n~~~\n\n第三步：添加`CMakeLists.txt`配置。\n\n~~~ cmake\n# add by user. 让编译器编译sub.cpp这个文件\nadd_executable(sub src/sub.cpp)\nament_target_dependencies(sub rclcpp)\n# add by user. 让编译器编译pub.cpp这个文件\nadd_executable(pub src/pub.cpp)\nament_target_dependencies(pub rclcpp)\n\n# add by user. 需要手动将编译好的文件安装到 install/example_cpp/lib/example_cpp 下\ninstall(TARGETS\n  sub\n  pub\n  DESTINATION lib/${PROJECT_NAME}\n)\n~~~\n\n编译运行即可。\n\n\n\n## 4.2 接口\n\n**三种接口形式**\n\n话题接口格式：`xxx.msg`\n\n~~~ sh\nint64 num\n~~~\n\n 服务接口格式：`xxx.srv`\n\n```\nint64 a\nint64 b\n---\nint64 sum\n```\n\n动作接口格式：`xxx.action`\n\n```\nint32 order\n---\nint32[] sequence\n---\nint32[] partial_sequence\n```\n\n**数据类型**\n\n基本类型，9类，每个后面都可以加`[]`将其变为数组。\n\n~~~ txt\nbool\nbyte\nchar\nfloat32, float64\nint8, uint8\nint16, uint16\nint32, uint32\nint64, uint64\nstring\n~~~\n\n扩展类型，上述类型的套娃。\n\n**接口常用命令**\n\n~~~ sh\n# 查看当前环境下接口列表\nros2 interface list\n# 查看所有接口包\nros2 interface packages\n# 查看某一个包下所有接口\nros2 interface package std_msgs\n# 查看某一个接口详细内容\nros2 interface show std_msgs/msg/String\n# 输出某一个接口所有属性\nros2 interface proto sensor_msgs/msg/Image\n\n~~~\n\n### 4.2.1 自定义消息接口\n\n**新建一个包：example_interface，在这里面编写自定义消息测试案例**\n\n![目录案例](./ros2/interface目录.jpg)\n\n\n\n第一步：在包下新建一个文件夹（不是src目录下，和src是同级目录）：`msg`\n\n第二步：在msg文件夹下新建一个消息文件：`Novel.msg`（首字母必须大写），内容如下\n\n~~~ msg\n# 直接使用ROS2原始的数据类型\nstring content\n\n# 图像消息，调用sensor_msgs下的Image类型\nsensor_msgs/Image image\n~~~\n\n第三步：添加`CMakeLists.txt`配置。\n\n~~~ cmake\n# add by user.查找sensor_msgs库\nfind_package(sensor_msgs REQUIRED)\nfind_package(rosidl_default_generators REQUIRED)\n# add by user.添加消息文件和依赖\nrosidl_generate_interfaces(${PROJECT_NAME}\n  \"msg/Novel.msg\"\n   DEPENDENCIES sensor_msgs\n )\n~~~\n\n第四步：添加`package.xml`配置。\n\n~~~ xml\n  <build_depend>sensor_msgs</build_depend>\n  <build_depend>rosidl_default_generators</build_depend>\n  <exec_depend>rosidl_default_runtime</exec_depend>\n  <member_of_group>rosidl_interface_packages</member_of_group>\n~~~\n\n编译后，验证。\n\n~~~ sh\nhaozi@computer:~/ros_place/study$ source install/setup.bash \nhaozi@computer:~/ros_place/study$ ros2 interface package example_interface\nexample_interface/msg/Novel\nhaozi@computer:~/ros_place/study$ ros2 interface show example_interface/msg/Novel\n# 直接使用ROS2原始的数据类型\nstring content\n\n# 图像消息，调用sensor_msgs下的Image类型\nsensor_msgs/Image image\nhaozi@computer:~/ros_place/study$ ros2 interface proto example_interface/msg/Novel\n\"content: ''\nimage:\n  header:\n    stamp:\n      sec: 0\n      nanosec: 0\n    frame_id: ''\n  height: 0\n  width: 0\n  encoding: ''\n  is_bigendian: 0\n  step: 0\n  data: []\n\"\n~~~\n\n\n\n### 4.2.2 自定义服务接口\n\n**还在包：example_interface，下进行**\n\n创建服务自定义接口，步骤如下（4.3小节后面用）：\n\n- 新建`srv`文件夹，并在文件夹下新建`xxx.srv`\n- 在`xxx.srv`下编写服务接口内容并保存\n- 在`CmakeLists.txt`添加依赖和srv文件目录\n- 在`package.xml`中添加`xxx.srv`所需的依赖\n- 编译功能包即可生成`python`与c++头文件\n\n还在上面这个包里添加\n\n第一步：在包下新建一个文件夹：`srv`\n\n第二步：在srv文件夹下新建一个服务接口文件：`BorrowMoney.srv`（首字母必须大写），内容如下\n\n~~~ msg\n# 输入参数\nstring name\nuint32 money\n---\n# \nbool success\nuint32 money\n~~~\n\n第三步：添加`CMakeLists.txt`配置（比上面多添加了一行）。\n\n~~~ cmake\n# add by user.查找sensor_msgs库\nfind_package(sensor_msgs REQUIRED)\nfind_package(rosidl_default_generators REQUIRED)\n# add by user.添加消息文件和依赖\nrosidl_generate_interfaces(${PROJECT_NAME}\n  #---msg---\n  \"msg/Novel.msg\"\n  #---srv---\n  \"srv/BorrowMoney.srv\"\n  DEPENDENCIES sensor_msgs\n )\n~~~\n\n第四步：添加`package.xml`配置，前面添加过了这里就不需要了。\n\n编译后，验证\n\n~~~ sh\nhaozi@computer:~/ros_place/study$ source install/setup.bash \nhaozi@computer:~/ros_place/study$ ros2 interface package example_interface\nexample_interface/msg/Novel\nexample_interface/srv/BorrowMoney\nhaozi@computer:~/ros_place/study$ ros2 interface show example_interface/srv/BorrowMoney\n# 输入参数\nstring name\nuint32 money\n---\n# 返回参数\nbool success\nuint32 money\nhaozi@computer:~/ros_place/study$ ros2 interface proto example_interface/srv/BorrowMoney \n\"name: ''\nmoney: 0\n\"\n~~~\n\n\n\n同理，再添加一个服务接口：SellNovel.srv\n\n~~~ srv\nuint32 money\n---\nstring[] novels\n~~~\n\nCMakeLists.txt（比上面又多了一行）\n\n~~~ cmake\nrosidl_generate_interfaces(${PROJECT_NAME}\n  #---msg---\n  \"msg/Novel.msg\"\n  #---srv---\n  \"srv/BorrowMoney.srv\"\n  \"srv/SellNovel.srv\"\n   DEPENDENCIES sensor_msgs\n )\n~~~\n\n同样，编译即可。\n\n\n\n## 4.3 服务\n\n### 4.3.1 自带案例\n\n~~~ sh\n# 运行自带的加法器服务\nhaozi@haozi-machine:~$ ros2 run examples_rclpy_minimal_service service\n# 手动调用服务\nros2 service call /add_two_ints example_interfaces/srv/AddTwoInts \"{a: 5,b: 10}\"\n\n\n# 查看服务列表\nhaozi@haozi-machine:~$ ros2 service list\n# 查看服务接口类型\nhaozi@haozi-machine:~$ ros2 service type /add_two_ints\n# 查找使用某一接口的服务\nhaozi@haozi-machine:~$ ros2 service find example_interfaces/srv/AddTwoInts\n~~~\n\n创建服务服务端的程序流程\n\n1. 导入相关接口（若有）\n2. 编程接口初始化\n3. 创建节点并初始化\n4. 创建客户端对象\n5. 创建并发送请求数据\n6. 等待服务器端应答数据\n7. 销毁节点并关闭接口\n\n创建服务客户端的程序流程\n\n1. 导入相关接口（若有）\n2. 编程接口初始化\n3. 创建节点并初始化\n4. 创建客户端对象\n5. 创建并发送请求数据\n6. 等待服务器端应答数据\n7. 销毁节点并关闭接口\n\n\n\n### 4.3.2 自定义服务端\n\n**新建一个包：example_service，在这里面编写服务端测试案例**\n\n![目录案例](./ros2/service目录.jpg)\n\n程序步骤：\n\n1. 导入服务接口\n2. 创建服务端回调函数\n3. 声明并创建服务端\n4. 编写回调函数逻辑处理请求\n\n\n\n第一步：`package.xml`，等会需要用到这个接口\n\n~~~ xml\n  <depend>example_interface</depend>\n~~~\n\n第二步：`CMakeLists.txt`\n\n~~~ cmake\n# find dependencies\nfind_package(ament_cmake REQUIRED)\nfind_package(rclcpp REQUIRED)\n# add by user.自定义接口\nfind_package(example_interface REQUIRED)\n# add by user.\nadd_executable(serv src/serv.cpp)\nament_target_dependencies(serv rclcpp example_interface)\n\n# add by user. 需要手动将编译好的文件安装到 install/example_cpp/lib/example_cpp 下\ninstall(TARGETS\n  serv\n  DESTINATION lib/${PROJECT_NAME}\n)\n~~~\n\n第三步：在包下的src文件夹中新建文件：`serv.cpp`，在这个文件中编写服务代码。\n\n~~~ c++\n#include \"rclcpp/rclcpp.hpp\"\n// 消息类型头文件\n#include \"std_msgs/msg/string.hpp\"\n#include \"std_msgs/msg/u_int32.hpp\"\n// 自定义消息类型头文件\n#include \"example_interface/srv/sell_novel.hpp\"\n// 队列\n#include <queue>\n\nusing std::placeholders::_1;\nusing std::placeholders::_2;\n\n/*\n    创建一个类节点，名字叫做Serv,继承自Node.\n*/\nclass Serv : public rclcpp::Node\n{\n\npublic:\n    // 构造函数\n    Serv() : Node(\"wang2\")\n    {\n        // 打印一句自我介绍\n        RCLCPP_INFO(this->get_logger(), \"大家好，我是单身汉王二.\");\n        // 创建一个订阅者来订阅李四写的小说，通过名字sexy_girl\n        sub_ = this->create_subscription<std_msgs::msg::String>(\"sexy_girl\", 10, std::bind(&Serv::topic_callback, this, _1));\n        // 创建发布者\n        pub_ = this->create_publisher<std_msgs::msg::UInt32>(\"sexy_girl_money\", 10);\n        // 实例化回调组\n        callback_group_service_ = this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);\n        // 实例化卖二手书的服务\n        server_ = this->create_service<example_interface::srv::SellNovel>(\"sell_novel\",\n                                                                          std::bind(&Serv::sell_book_callback, this, _1, _2),\n                                                                          rmw_qos_profile_services_default,\n                                                                          callback_group_service_);\n    }\n\nprivate:\n    // 声明一个服务回调组\n    rclcpp::CallbackGroup::SharedPtr callback_group_service_;\n\n    // 声明一个订阅者（成员变量）\n    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr sub_;\n\n    // 声明一个发布者（成员变量）\n    rclcpp::Publisher<std_msgs::msg::UInt32>::SharedPtr pub_;\n\n    // 创建一个小说章节队列\n    std::queue<std::string> novels_queue;\n\n    // 声明一个服务端\n    rclcpp::Service<example_interface::srv::SellNovel>::SharedPtr server_;\n\n    // 收到话题数据的回调函数\n    void topic_callback(const std_msgs::msg::String::SharedPtr msg)\n    {\n        // 新建一张人民币\n        std_msgs::msg::UInt32 money;\n        money.data = 10;\n\n        // 发送人民币给李四\n        pub_->publish(money);\n        RCLCPP_INFO(this->get_logger(), \"王二：我收到了：'%s' ，并给了李四：%d 元的稿费\", msg->data.c_str(), money.data);\n\n        // 将小说放入novels_queue中\n        novels_queue.push(msg->data);\n    };\n\n    // 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据\n    void sell_book_callback(const example_interface::srv::SellNovel::Request::SharedPtr request,\n                            const example_interface::srv::SellNovel::Response::SharedPtr response)\n    {\n        RCLCPP_INFO(this->get_logger(), \"收到一个买书请求，一共给了%d钱\", request->money);\n        unsigned int novelsNum = request->money * 1; // 应给小说数量，一块钱一章\n\n        // 判断当前书库里书的数量是否满足张三要买的数量，不够则进入等待函数\n        if (novels_queue.size() < novelsNum)\n        {\n            RCLCPP_INFO(this->get_logger(), \"当前艳娘传奇章节存量为%d：不能满足需求,开始等待\", novels_queue.size());\n\n            // 设置rate周期为1s，代表1s检查一次\n            rclcpp::Rate loop_rate(1);\n\n            // 当书库里小说数量小于请求数量时一直循环\n            while (novels_queue.size() < novelsNum)\n            {\n                // 判断系统是否还在运行\n                if (!rclcpp::ok())\n                {\n                    RCLCPP_ERROR(this->get_logger(), \"程序被终止了\");\n                    return;\n                }\n                // 打印一下当前的章节数量和缺少的数量\n                RCLCPP_INFO(this->get_logger(), \"等待中，目前已有%d章，还差%d章\", novels_queue.size(), novelsNum - novels_queue.size());\n\n                // rate.sleep()让整个循环1s运行一次\n                loop_rate.sleep();\n            }\n        }\n        // 章节数量满足需求了\n        RCLCPP_INFO(this->get_logger(), \"当前艳娘传奇章节存量为%d：已经满足需求\", novels_queue.size());\n\n        // 一本本把书取出来，放进请求响应对象response中\n        for (unsigned int i = 0; i < novelsNum; i++)\n        {\n            response->novels.push_back(novels_queue.front());\n            novels_queue.pop();\n        }\n    }\n};\n\nint main(int argc, char **argv)\n{\n    rclcpp::init(argc, argv);\n    /*产生一个Wang2的节点*/\n    auto node = std::make_shared<Serv>();\n    /* 运行节点，并检测退出信号*/\n    rclcpp::executors::MultiThreadedExecutor exector;\n    exector.add_node(node);\n    exector.spin();\n    rclcpp::shutdown();\n    return 0;\n}\n~~~\n\n编译运行即可。\n\n\n\n### 4.3.3 自定义客户端\n\n**新建一个包：example_client，在这里面编写客户端测试案例**\n\n![目录案例](./ros2/client目录.jpg)\n\n程序步骤：\n\n1. 导入服务接口\n2. 创建请求结果接收回调函数\n3. 声明并创建客户端\n4. 编写结果接收逻辑\n5. 调用客户端发送请求\n\n\n\n第一步：`package.xml`，等会需要用到这个接口\n\n~~~ xml\n  <depend>example_interface</depend>\n~~~\n\n第二步：`CMakeLists.txt`\n\n~~~ cmake\n# find dependencies\nfind_package(ament_cmake REQUIRED)\nfind_package(rclcpp REQUIRED)\n# add by user.自定义接口\nfind_package(example_interface REQUIRED)\n# add by user.添加可执行文件\nadd_executable(clie src/clie.cpp)\n# add by user.\nament_target_dependencies(clie\n  rclcpp \n  example_interface\n)\n\ninstall(TARGETS\n  clie\n  DESTINATION lib/${PROJECT_NAME}\n)\n~~~\n\n第三步：在包下的src文件夹中新建文件：`clie.cpp`，在这个文件中编写服务代码。\n\n~~~ c++\n#include \"rclcpp/rclcpp.hpp\"\n#include \"example_interface/srv/sell_novel.hpp\"\n\nusing std::placeholders::_1;\nusing std::placeholders::_2;\n\n/*\n    创建一个类节点，名字叫做Clie,继承自Node.\n*/\nclass Clie : public rclcpp::Node\n{\n\npublic:\n    Clie() : Node(\"wang2\")\n    {\n        // 打印一句自我介绍\n        RCLCPP_INFO(this->get_logger(), \"大家好，我是得了穷病的张三.\");\n        client_ = this->create_client<example_interface::srv::SellNovel>(\"sell_novel\");\n    }\n\n    void buy_novel()\n    {\n        RCLCPP_INFO(this->get_logger(), \"买小说去喽\");\n        while (!client_->wait_for_service(std::chrono::seconds(1)))\n        {\n            if (!rclcpp::ok())\n            {\n                RCLCPP_ERROR(this->get_logger(), \"等待服务的过程中被打断...\");\n                return;\n            }\n            RCLCPP_INFO(this->get_logger(), \"等待服务端上线中\");\n        }\n        // 构造请求的钱\n        auto request = std::make_shared<example_interface::srv::SellNovel_Request>();\n        // 先来五块钱的看看好不好看\n        request->money = 5;\n        // 发送异步请求，然后等待返回，返回时调用回调函数\n        client_->async_send_request(request, std::bind(&Clie::novels_callback, this, _1));\n    };\n    // 创建接收到小说的回调函数\n    void novels_callback(rclcpp::Client<example_interface::srv::SellNovel>::SharedFuture response)\n    {\n        auto result = response.get();\n        RCLCPP_INFO(this->get_logger(), \"收到%d章的小说，现在开始按章节开读\", result->novels.size());\n        for (std::string novel : result->novels)\n        {\n            RCLCPP_INFO(this->get_logger(), \"%s\", novel.c_str());\n        }\n        RCLCPP_INFO(this->get_logger(), \"小说读完了，好刺激，写的真不错，好期待下面的章节呀！\");\n    }\n\nprivate:\n    // 创建一个客户端\n    rclcpp::Client<example_interface::srv::SellNovel>::SharedPtr client_;\n};\n\nint main(int argc, char **argv)\n{\n    rclcpp::init(argc, argv);\n    /*产生一个Wang2的节点*/\n    auto node = std::make_shared<Clie>();\n    node->buy_novel();\n    /* 运行节点，并检测退出信号*/\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}\n~~~\n\n编译运行即可。\n\n\n\n把客户端、服务端、话题发布者同时运行起来即可看到效果。\n\n\n\n## 4.4 参数（用到了再看）\n\n参数：由键值对组成。\n\n* 键：字符串\n* 值：\n  * bool 和 bool[]，布尔类型用来表示开关，比如我们可以控制雷达控制节点，开始扫描和停止扫描。\n  * int64 和 int64[]，整形表示一个数字，含义可以自己来定义\n  * float64 和 float64[]，浮点型，可以表示小数类型的参数值\n  * string 和 string[]，字符串，可以用来表示雷达控制节点中真实雷达的ip地址\n  * byte[]，字节数组，这个可以用来表示图片，点云数据等信息\n\n~~~ sh\n# 查看参数列表\nros2 param list\n\n# 查看参数描述信息\nros2 param describe <node_name> <param_name>\n\n# 查看键对应的值\nros2 param get <node_name> <param_name>\n\n# 设置键的值\nros2 param set <node_name> <parameter_name> <value>\n\n# 给节点的参数保存一份快照（在当前目录下，yaml格式）\nros2 param dump <node_name>\n\n# 恢复节点参数\nros2 param load <node_name> <file_name>\n# 如：ros2 param load  /turtlesim ./turtlesim.yaml\n\n# 直接使用参数文件启动\nros2 run <package_name> <executable_name> --ros-args --params-file <file_name>\n# 如：ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml\n~~~\n\n\n\n## 4.5 动作（用到了再看）\n\n* Action的三大组成部分目标、反馈和结果。\n  * 目标：即Action客户端告诉服务端要做什么，服务端针对该目标要有响应。解决了不能确认服务端接收并处理目标问题\n  * 反馈：即Action服务端告诉客户端此时做的进度如何（类似与工作汇报）。解决执行过程中没有反馈问题\n  * 结果：即Action服务端最终告诉客户端其执行结果，结果最后返回，用于表示任务最终执行情况。\n\n> Action是由话题和服务共同构建出来的（一个Action = 三个服务+两个话题）\n>\n> 三个服务分别是：1、目标传递服务。2、结果传递服务。3、取消执行服务\n>\n> 两个话题：1、反馈话题（服务发布，客户端订阅） 2、状态话题（服务端发布，客户端订阅）\n\n\n\n~~~ sh\n# 继续运行小乌龟\nros2 run turtlesim turtlesim_node\nros2 run turtlesim turtle_teleop_key\n\n\n# 该命令用于获取目前系统中的action列表。\nros2 action list\n/turtle1/rotate_absolute\n\n# 顺便查看Action使用的接口类型\nros2 action list -t\n/turtle1/rotate_absolute [turtlesim/action/RotateAbsolute]\n\n# 查看接口定义\nros2 interface show turtlesim/action/RotateAbsolute\n\n# 查看Action信息（action客户端和服务段的数量以及名字）\nros2 action info /turtle1/rotate_absolute \n\n# 发送请求到服务端\nros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 1.6}\"\n# 发送请求到服务端，并查看反馈\n~~~\n\n\n\n\n\n# 5. ament_cmake\n\n一个功能包的构建信息包含在\n\n- `CMakeLists.txt`：描述了如何构建此功能包\n- `package.xml`：包含该功能包的依赖信息，它可以帮助编译工具colcon确定多个功能包编译的顺序\n\n## 5.1 CmakeLists.txt\n\nROS2的构建系统叫做`ament_cmake`，它是基于`CMake`改进而来的。接下来介绍一下`ament_cmake`常用的一些命令：\n\n找一个比较全的，自己的包找找一样的命令即可。\n\n~~~ cmake\n# 指定cmake的最低版本(3.5)\ncmake_minimum_required(VERSION 3.5)\n# 功能包的名字\nproject(nav2_costmap_2d)\n\n# 查找ament_cmake包\nfind_package(ament_cmake REQUIRED)\n# 查找依赖构建此功能包所需要的依赖（ROS2自带的）\nfind_package(rclcpp REQUIRED)\nfind_package(geometry_msgs REQUIRED)\nfind_package(laser_geometry REQUIRED)\nfind_package(map_msgs REQUIRED)\nfind_package(message_filters REQUIRED)\nfind_package(nav2_common REQUIRED)\nfind_package(nav2_msgs REQUIRED)\nfind_package(nav2_util)\nfind_package(nav2_voxel_grid REQUIRED)\nfind_package(nav_msgs REQUIRED)\nfind_package(pluginlib REQUIRED)\nfind_package(rclcpp REQUIRED)\nfind_package(rclcpp_lifecycle REQUIRED)\nfind_package(rmw REQUIRED)\nfind_package(sensor_msgs REQUIRED)\nfind_package(std_msgs REQUIRED)\nfind_package(std_srvs REQUIRED)\nfind_package(tf2_geometry_msgs REQUIRED)\nfind_package(tf2 REQUIRED)\nfind_package(tf2_ros REQUIRED)\nfind_package(tf2_sensor_msgs REQUIRED)\nfind_package(visualization_msgs REQUIRED)\nfind_package(angles REQUIRED)\n# 查找依赖构建此功能包所需要的依赖（非ROS2自带的）\nfind_package(Eigen3 REQUIRED)\ninclude_directories(\n  include\n  ${EIGEN3_INCLUDE_DIRS}\n)\n\n# 使用add_library构建库\nadd_library(nav2_costmap_2d_core SHARED\n  src/array_parser.cpp\n  src/costmap_2d.cpp\n  src/layer.cpp\n  src/layered_costmap.cpp\n  src/costmap_2d_ros.cpp\n  src/costmap_2d_publisher.cpp\n  src/costmap_math.cpp\n  src/footprint.cpp\n  src/costmap_layer.cpp\n  src/observation_buffer.cpp\n  src/clear_costmap_service.cpp\n  src/footprint_collision_checker.cpp\n  plugins/costmap_filters/costmap_filter.cpp\n)\n\n# 设置变量dependencies，这里主要添加的是ROS2功能包\nset(dependencies\n  geometry_msgs\n  laser_geometry\n  map_msgs\n  message_filters\n  nav2_msgs\n  nav2_util\n  nav2_voxel_grid\n  nav_msgs\n  pluginlib\n  rclcpp\n  rclcpp_lifecycle\n  sensor_msgs\n  std_msgs\n  std_srvs\n  tf2\n  tf2_geometry_msgs\n  tf2_ros\n  tf2_sensor_msgs\n  visualization_msgs\n  angles\n)\n\n# 通过ament_target_dependencies添加ROS2功能包依赖，它将依赖的库、头文件以及自身依赖添加到目标中\n# 即nav2_costmap_2d_core是依赖${dependencies}的（前面定义了变量）\nament_target_dependencies(nav2_costmap_2d_core\n  ${dependencies}\n)\n\n# 通过add_executable构建可执行文件，同时也需要使用ament_target_dependencies添加相关依赖\n# 构建nav2_costmap_2d_markers可执行文件，参数为：src/costmap_2d_markers.cpp\nadd_executable(nav2_costmap_2d_markers src/costmap_2d_markers.cpp)\ntarget_link_libraries(nav2_costmap_2d_markers\n  nav2_costmap_2d_core\n)\n# nav2_costmap_2d_markers是依赖${dependencies}的（前面定义了变量）\nament_target_dependencies(nav2_costmap_2d_markers\n  ${dependencies}\n)\n\nadd_executable(nav2_costmap_2d_cloud src/costmap_2d_cloud.cpp)\ntarget_link_libraries(nav2_costmap_2d_cloud\n  nav2_costmap_2d_core\n)\n\nadd_executable(nav2_costmap_2d src/costmap_2d_node.cpp)\nament_target_dependencies(nav2_costmap_2d\n  ${dependencies}\n)\n\ntarget_link_libraries(nav2_costmap_2d\n  nav2_costmap_2d_core\n  layers\n  filters\n)\n\n# 安装库\ninstall(TARGETS\n  nav2_costmap_2d_core\n  layers\n  filters\n  nav2_costmap_2d_client\n  ARCHIVE DESTINATION lib\n  LIBRARY DESTINATION lib\n  RUNTIME DESTINATION bin\n)\n\n# 安装可执行文件，注意这里的可执行文件路径为： lib/${PROJECT_NAME}而不是bin\ninstall(TARGETS\n  nav2_costmap_2d\n  nav2_costmap_2d_markers\n  nav2_costmap_2d_cloud\n  RUNTIME DESTINATION lib/${PROJECT_NAME}\n)\n\n# 导出头文件\ninstall(DIRECTORY include/\n  DESTINATION include/\n)\n\n# 导出launch和参数文件\ninstall(\n  DIRECTORY launch params\n  DESTINATION share/${PROJECT_NAME}\n)\n\n# 通过ament_export_include_directories导出该功能包的头文件，以便其他功能包依赖此功能包时，能够找到对应的头文件\nament_export_include_directories(include)\n\n# 通过ament_export_libraries导出该功能包构建的库，以便其他功能包能够顺利链接到\nament_export_libraries(layers filters nav2_costmap_2d_core nav2_costmap_2d_client)\n\n# 通过ament_export_dependencies导出此功能包所有的ROS相关的依赖，依赖其他功能包依赖此功能包时，不必再通过find_package重复添加这些依赖\nament_export_dependencies(${dependencies})\n~~~\n\n\n\n## 5.2 package.xml\n\n~~~ xml\n<!-- 编译的工具依赖 -->\n<buildtool_depend>ament_cmake</buildtool_depend>\n\n<!-- 依赖的ROS2功能包 -->\n<depend>geometry_msgs</depend>\n<depend>laser_geometry</depend>\n<depend>map_msgs</depend>\n<depend>message_filters</depend>\n<depend>nav2_msgs</depend>\n<depend>nav2_util</depend>\n<depend>nav2_voxel_grid</depend>\n<depend>nav_msgs</depend>\n<depend>pluginlib</depend>\n<depend>rclcpp</depend>\n<depend>rclcpp_lifecycle</depend>\n<depend>sensor_msgs</depend>\n<depend>std_msgs</depend>\n<depend>std_srvs</depend>\n<depend>tf2</depend>\n<depend>tf2_geometry_msgs</depend>\n<depend>tf2_ros</depend>\n<depend>tf2_sensor_msgs</depend>\n<depend>visualization_msgs</depend>\n<depend>angles</depend>\n\n\n<!-- 导出依赖 -->\n<export>\n    <build_type>ament_cmake</build_type>\n</export>\n~~~\n\n\n\n\n\n# 6. 工具\n\n## 6.1 Launch\n\n\n\n\n\n\n\n\n\n\n\n# 补充：\n\n安装配套支持\n\n~~~ shell\n#首先切换到工作空间下的src目录下，然后执行下面操作\nsudo apt install python3-pip\t\t# python包管理工具\n\nsudo pip3 install rosdepc\t\t# 安装ros依赖工具\n\nsudo resdepc init & rosdepc update\t\t# 更新\n\n#切回工作空间目录下，然后执行下面操作\nrosdepc install -i --from-path src --rosdistro foxy -y # 自动添加依赖\n\n#如果报如下错误，是缺少依赖（最后括号里面的）\nERROR: the following packages/stacks could not have their rosdep keys resolved\nto system dependencies:\nlearning_urdf: Cannot locate rosdep definition for [joint_state_publisher_gui]\nlearning_tf: Cannot locate rosdep definition for [tf_transformations]\n#解决办法：缺啥安装啥，如第一个（ros-foxy-依赖名字）\nudo apt-get install ros-foxy-joint_state_publisher_gui\n#如果报错就把_换成-\n#所有的都安装完了之后，重新执行\nrosdepc install -i --from-path src --rosdistro foxy -y # 自动添加依赖\n\n\nsudo apt install python3-colcon-ros # 安装编译器\n\ncolcon build\t# 编译当前工程指令\n\n\n#编译完成之后，工作空间就有了\n#build、install、log文件夹\n#src（原来就有）文件夹\n\n\n#配置环境变量\n#在install文件夹中有 local_setup.sh文件\nsource install/local_setup.sh\n\n#添加环境变量\n#在用户home文件夹，ctrl + H 显示隐藏文件\n#找到 .bashrc 文件，在文件末尾添加 （最后有个空格！）\nsource ~/ROS2_Sapce/0_dev_ws/install/local_setup.sh \n~~~\n\n\n\n功能包\n\n~~~ shell\nros2 pkg create --build-type <build-type><package_name>\n#创建功能包\ncd ~/dev_ws/src\nros2 pkg create --build-type ament_cmake learning_pkg_c\t# c++\nros2 pkg create --build-type ament_python learning_pkg_python # python\n#编译功能包\ncd ~/dev_ws/src\ncolcon build\nsource install/local_setup.bash\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["ROS","ROS2"],"categories":["Linux应用"]},{"title":"CanOpen","url":"/2023/07/01/07. 通信协议/canopen/","content":"\n\n\n# 1. CAN协议\n\n* 和串口、I2C、SPI、485、232等通讯协议一样，CAN也是种传送数据的方式。\n\n## 1.1 物理接线\n\n* CAN通信需要两根线，`CAN_H`、`CAN_L`，两根线采用双绞线的方式缠绕。\n* 每个通讯节点的`CAN_H`接在一起，`CAN_L`接在一起。\n* 两端接两个120欧的电阻。\n\n\n\n![CAN接线方式](./canopen/CAN接线方式.jpg)\n\n\n\n## 1.2 信号传输\n\n* 线上的电位采用差分信号进行判别，抗干扰能力强。\n* 电平判断\n  * CAN_H - CAN_L < 0.5V 时候为隐性的，逻辑信号表现为\"逻辑1\"- 高电平。\n  * CAN_H - CAN_L > 0.9V 时候为显性的，逻辑信号表现为\"逻辑0\"- 低电平。\n\n![CAN信号电平](./canopen/CAN信号电平.jpg)\n\n> CAN总线在电平传输上，具有仲裁判断逻辑，优先级为：显性（低电平）>隐形（高电平）！\n\n\n\n## 1.3 协议规定\n\nCAN规定了5种不同的数据帧（发送一次数据就是一帧数据，类似于串口发送一个字节数据？）。\n\n* **数据帧（重要）**：向接受单元传送数据用的。\n* 遥控帧：向远端节点请求数据用的。\n* 错误帧：当检测出错误是向其他单元通知错误。\n* 过载帧：接收单元通知其未做好准备。\n* 帧间隔：用于将数据帧和遥控真与前面的分离开。\n\n> 主要掌握数据帧，遥控帧基本上已经不用了。其他的先知道即可。 \n\n\n\n对于数据帧和遥控帧，帧结构都由以下7个段组成。\n\n![帧结构](./canopen/CAN帧结构.jpg)\n\n该结构有两种格式：**标准格式**和**扩展格式**。可以看出，两种格式的区别仅在于仲裁段和控制段不同。\n\n每个段都有自己的格式，用户需要关注的段为：**仲裁段**、**数据段**。更具体的说是，**仲裁段的 ID**和**数据段**。\n\n![CAN帧格式](./canopen/CAN帧格式.jpg)\n\n仲裁段有一套仲裁机制，当总线上的各个节点同时发送设备时，根据ID优先级判断哪个节点的信息有效。**ID 越小，优先级越高**。\n\n> 更具体的仲裁机制还需要根据不同的段做出不同的反应，比如退出竞争、产生错误等。这里就不详细说了，有兴趣的可以再去详细了解。\n\n数据段中是每次要发送的数据，其长度为 0-8 个字节。\n\n作为写应用的，我们只需要关注这两部分即可。\n\n比如 RT-Thread 中的 CAN 发送函数（[来源](https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/device/can/can?id=can-%e8%ae%be%e5%a4%87%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b)）。需要我们注意的有`ID`、`格式`、`帧类型`、`数据`、`长度`。\n\n~~~ c\nstruct rt_can_msg msg = {0};\n\nmsg.id = 0x78;              /* ID 为 0x78 */\nmsg.ide = RT_CAN_STDID;     /* 标准格式 */\nmsg.rtr = RT_CAN_DTR;       /* 数据帧 */\nmsg.len = 8;                /* 数据长度为 8 */\n/* 待发送的 8 字节数据 */\nmsg.data[0] = 0x00;\nmsg.data[1] = 0x11;\nmsg.data[2] = 0x22;\nmsg.data[3] = 0x33;\nmsg.data[4] = 0x44;\nmsg.data[5] = 0x55;\nmsg.data[6] = 0x66;\nmsg.data[7] = 0x77;\n/* 发送一帧 CAN 数据 */\nsize = rt_device_write(can_dev, 0, &msg, sizeof(msg));\n~~~\n\n而相关的内容，API 都已经封装好了，就不用我们管了。\n\n~~~ c\nstruct rt_can_msg\n{\n    rt_uint32_t id  : 29;\n    rt_uint32_t ide : 1;\n    rt_uint32_t rtr : 1;\n    rt_uint32_t rsv : 1;\n    rt_uint32_t len : 8;\n    rt_uint32_t priv : 8;\n    rt_int32_t hdr : 8;\n    rt_uint32_t reserved : 8;\n    rt_uint8_t data[8];\n};\ntypedef struct rt_can_msg *rt_can_msg_t;\n~~~\n\n接收也是一样的封装好了，我们只需要取出我们需要的 ID 和数据即可。\n\n~~~ c\n/* 从 CAN 读取一帧数据 */\nrt_device_read(can_dev, 0, &rxmsg, sizeof(rxmsg));\n/* 打印数据 ID 及内容 */\nrt_kprintf(\"ID:%x\", rxmsg.id);\nfor (i = 0; i < 8; i++)\n{\n    rt_kprintf(\"%2x\", rxmsg.data[i]);\n}\n~~~\n\n至此，CAN 的使用需要了解的应该就够了。\n\n> 如果想了解的更详细，别人的文章，上面有水印的图就是他的。[知乎文章](https://zhuanlan.zhihu.com/p/538834760)\n\n\n\n# 2. CANopen概念\n\n从上面可以看出，CAN 总线确定了一种数据传输的物理和数据方式。即，用什么设备传输数据、怎么传输数据、格式是什么。\n\n但是，在我们写应用的时候，数据传输时每个人对于 ID 或者数据都有自己的规定，不统一。即，在这个层面上缺乏一个统一的标准去规定不同**ID**和**数据**的含义是什么。\n\n因此，CANopen做的就是这个工作。\n\n## 2.1 通信特点\n\nCANopen规定的报文特点：\n\n* 报文传输采用 CAN **标准帧**格式。即 11bit 的 ID 域，以尽量减小传输时间；\n* 网络控制报文均采用数据最小字节数。比如心跳报文，只有1个字节数据；\n* 实时更新的**过程数据无需接收方报文应答**。即采用生产消费模型，降低总线负载；\n* 需要接收方确认的配置参数一般都是采用快速单字传输。即1个报文最多传送1个32字节的参数变量，避免了分帧引起的实时性降低。\n\n> 规定上述特点的原因是，CAN通信具有可以突发发送的实时性优势，但是多个节点下，突发具有较大的冲突可能性。因此，上述特点可以尽可能保证实时性。\n\n\n\nCANopen 协议通常分为用户应用层、**对象字典**以及**通信**三个部分。\n\n* 用户应用层：用户根据实际的需求编写的应用对象。\n* 对象字典：最核心的部分，描述了应用对象和 CANopen 报文之间的关系。\n* 通信：很重要的部分，定义了 CANopen 协议通信规则以及与CAN控制器驱动之间对应关系，掌握这部分才能让我们写自己的应用对象。\n\n前面我们说了，CAN通信中，我们需要关注的就是`CAN-ID`和`DATA`。\n\n在CANopen中也是一样的，我们需要知道这两部分是怎么设置的，分别有什么含义。\n\n\n\n## 2.2 对象字典(OD)\n\nCANopen 对象字典（OD: Object Dictionary）是 CANopen 协议最为核心的概念。\n\n对象字典就是一个有序的对象组，描述了对应 CANopen 节点的所有参数，包括通讯数据的存放位置也列入其索引，这个表变成可以传递形式就叫做**EDS文件**（电子数据文档 Electronic Data Sheet）。\n\n其中，每个对象采用一个 16 位的索引值来寻址，这个索引值通常被称为**索引**，其范围在**0x0000**到**0xFFFF**之间。为了避免数据大量时无索引可分配，所以在某些索引下也定义了一个8 位的索引值，这个索引值通常被称为**子索引**，其范围是**0x00**到**0xFF**之间。每个索引内具体的参数，最大用**32**位的变量来表示，四个字节。\n\n如下图是某遵循 CANopen 协议的电机的 EDS 文件。\n\n![EDS文件示例](./canopen/EDS文件示例.jpg)\n\n> EDS 文件是每个节点都有的，采用字典的形式保存了该节点的参数等信息。其他节点可以通过索引等信息访问或者修改这些信息。\n\n理解：\n\n对于某个设备而言，预定义了各个节点通信需要收发的信息都有什么，表现形式上就是如上图的一个表格。**每一行就是一个对象**，每个对象中存放的是什么内容可以自定（有些条目是固定的）。CANopen的收发就是在收发这些对象。\n\n## 2.3 数据传输(PDO、SDO)\n\n\n\n### 2.3.1 对象分类\n\n说数据传输之前先说两种数据收发模型：\n\n* 生产消费模型：生产者向外发送数据，不指定对象，消费者消费数据。即，==生产者并不会得到回复==。\n* 服务器客户端模型：客户端向服务器发送数据请求，服务器回复请求的数据。即，==客户端会得到数据回复==。其中，从服务器读取的动作是**上传**，向服务器写入的动作是**下载**（可以看出该动作是相对于服务器而言的）。\n\n\n\n在 CANopen 中配置信息或应用信息的传输是通过两种对象进行传输的：**过程数据对象 PDO**（Process data object）、**服务数据对象 SDO**（Service data object），其中：\n\n* PDO：属于过程数据，即单向传输，无需接收节点回应 CAN 报文来确认，即，生产消费模型。\n* SDO：属于服务数据，有指定被接收节点的地址（Node-ID），并且需要指定的接收节点回应 CAN 报文来确认已经接，如果超时没有确认，则发送节点将会重新发送原报文。即服务器客户端模型。\n\n> 即，把上面的那些对象分为两类，PDO、SDO，第一类表示发过去无需回复。第二类表示发送过去之后需要接收方进行回复的对象。\n\n对于 PDO 对象：由于需要区分每个 CANopen 节点的输入和输出，所以 PDO 分为 TPDO（发送PDO）和 RPDO（接收PDO），发送和接收是以 CANopen 从站节点为参考（如果CAN主站就相反）。TPDO 和 RPDO 分别有4个数据对象，每种数据对象就是1条CAN报文封装，这些都是数据收发的容器。\n\n* TPDO1（发送PDO）：从站主动传输TXPDO数据给主站，从站发送。\n* RPDO1（接收PDO）：主站主动传输RxPDO数据给从站，从站接收。\n* TPDO2\n* RPDO2\n* TPDO3\n* RPDO3\n* TPDO4\n* RPDO5\n\n可以看到这个RT是站在从站的角度看的。\n\n> 另外，不同类别对象的索引，是有规定的，不是随便定的。\n\n### 2.3.2 对象编号\n\nCANopen 预定义了强制性的缺省标识符（CAN-ID）分配表，该分配表是基于11 位CAN-ID 的标准帧格式。将其划分为**4 位的功能码（Function-ID）**和**7 位的节点号（Node-ID）**。\n\n![PDO和SDO的预定义连接ID分配](./canopen/PDO和SDO的预定义连接ID分配.jpg)\n\n从这张图中，要搞清楚一个概念。\n\n* 节点号：一个网络中的每个节点都有一个自己的编号，用 7bit 表示，即，一个网络中最多能有127个通讯节点（0不行）。\n\n* 通信对象编号（COB-ID）：在 CANopen 中就是 CAN-ID，可以看出，节点号被包含在 COB-ID 中。\n\n\n\n# 3. 数据通信\n\n前面提到，不管是CAN还是CANopen需要我们关注的都是`CAN-ID`和`DATA`。\n\n\n\n## 3.1 服务数据对象SDO\n\n特性：SDO 主要用于 CANopen 主站对从节点的参数配置。**服务确认是**SDO的最大的特点，为每个消息都生成一个应答，确保数据传输的准确性。\n\n在收发 SDO 对象时比较简单固定。一般在 CANopen 网络中，只有 NMT 主机能发起 SDO 通讯，进行节点参数配置或者关键性参数的传递。当然从节点也可以对其他从节点发起SDO通讯。\n\n> NMT主机后面会介绍，这里只需要知道，主机（主动方）可以发起SDO通讯就行了。\n\n### 3.1.1 ID设置\n\n* 发送方（客户端）：发送 CAN-ID 为`600h + Node-ID`的报文，其中 Node-ID 为接收方（服务器）的节点地址，数据长度均为8字节；\n\n* 接收方（服务器）：成功接收后，回应 CAN-ID 为`580h + Node-ID`的报文。这里的 Node-ID 也是是接收方（刚刚的发送方）的节点地址，数据长度均为8字节。\n\n\n\n![SDO通讯原则](./canopen/SDO通讯原则.jpg)\n\n\n\n如下图中的最后两行，为 CANopen 预定义报文的 SDO 报文中的 ID 分类。\n\n![PDO与SDO的CAN-ID定义](./canopen/PDO与SDO的CAN-ID定义.jpg)\n\n\n\n### 3.1.2 数据设置\n\n在发送数据时分为两类，`快速SDO协议`、`普通SDO协议`。\n\n**快速SDO协议**（常用）\n\n最常用最常见的 SDO 协议是快速 SDO，快速，就是1次来回就搞定。前提是读取和写入的值不能大于 32 位。如图所示，为快速 SDO 协议的示意图。命令中直接包含了要读写的索引、子索引、数据。可谓直接命中。\n\n![快速SDO示意图](./canopen/快速SDO示意图.jpg)\n\n通过快速 SDO，可以直接对 CANopen 节点的对象字典中的值进行读取和修改，所以在做参数配置之外，也经常作为关键性数据传输之用。比如 CANopen 控制机器人的电机转动角度时，就使用 SDO 来传输，保证可靠。\n\n---\n\n举个例子，保利时电机将电机设置为转矩模式。\n\n需要发送的数据为：\n\n* ID：`0x00 00 06 02`，其中0x2是要发送给（接收方）的节点号。（可以对照3.1.1小节的图）\n* DATA：`0x2F 60 60 00 04 00 00 00`，其中0x2F为命令符，0x60 60为索引，0x00为子索引，0x04 00 00 00为要发送的数据。\n\n接收到的回复为：\n\n* ID：`0x00 00 05 82`，其中0x2表示是谁给出的回复。（参考2.3小节最后）\n* DATA：`0x60 60 60 00 00 00 00 00`，其中0x60表示成功，0x60 60为索引，0x00为子索引，0x00 00 00 00为回复的数据。\n\n这就是一个发送SDO对象的案例。这里更改的对象为：索引为0x60 60，子索引为0x00，对象含义为电机的运行模式。\n\n---\n\n**普通SDO协议**（了解）\n\n当需要传输的值超过 32 位时，就不能使用快速 SDO 传输。必须使用普通 SDO 进行分帧传输。在应用中较少用到。\n普通 SDO 协议难点在于分包逻辑与 CS 命令符的变化。依然难以记忆。\n当然普通 SDO 的 CAN 帧 ID 与快速 SDO 相同，依然发送方（客户端）发送的报文CAN-ID为`600h + Node-ID`，接收方（服务器）成功接收后，回应CAN-ID为`580h + Node-ID`的报文。\n\n**下载协议download protocol**\n\n![下载协议](./canopen/下载协议.jpg)\n\n**上传协议upload protocol**\n\n![上传协议](./canopen/上传协议.jpg)\n\n\n\n## 3.2 过程数据对象PDO\n\nPDO 属于过程数据，用来传输实时数据，即单向传输，无需接收节点回应 CAN 报文来确认，属于“生产消费”模型 PDO。数据长度被限制为1~8 字节。最多只要1帧就可以把一条信息或者一个变量传递结束。\n\n但是PDO的收发不只是简单的设置ID和DATA的问题，这个相对来说有点麻烦。\n\n### 3.2.1 ID设置\n\n* 发送方：根据自己属于哪一类对象 PDO 对象决定自己的 ID。比如，发送 CAN-ID 为`180h + Node-ID`的报文，其中 Node-ID 为发送方（自己）的节点地址，用于告诉是谁发送出去的。数据长度 1 - 8 字节。\n\n如下图中的前面 8 行，为 CANopen 预定义报文的 PDO 报文中的 ID 分类。\n\n![PDO与SDO的CAN-ID定义](./canopen/PDO与SDO的CAN-ID定义.jpg)\n\n当然，如果某个节点需要传递的资源特别多，则有出现例如 TPDO5 之类的数据对象，而它们的 CAN-ID 定义就需要打破预定义的规则，比如我们可以定义Node-ID为1的节点中 TPDO5 是 182h，这里的 PDO 的 COB-ID 中的低 7 位不再是表示 Node-ID。其实所有的 PDO 的 COB-ID 与 Node-ID 无必然规则上的联系。\n\n---\n\n也举个例子，保利时电机驱动器接通后，会一直循环上报编码器位置。\n\n上位机接收到的数据为：\n\n* ID：`0x01 82`，其中0x2是驱动器自己的节点号。（0x01 80 可以对照到上图中的TPDO1）。\n* DATA：`0x2F 60 60 00`，为编码器的读数。\n\n![上位机接收到的PDO](./canopen/上位机接收到的PDO.jpg)\n\n这就是一个上位机接收PDO对象的案例。这里主要是为了看这个ID，数据先不用在意，等会看后面。\n\n---\n\n\n\n### 3.2.2 传输方式\n\nPDO的两种传输方式：同步传输和异步传输。如图所示，1、2为异步传输，3、4为同步传输。\n\n![PDO的传输形式](figures/PDO的传输形式.jpg)\n\n上面的例子中，就是用的第一种异步传输的方式。\n\n\n\n### 3.2.3 数据设置\n\nPDO 的通信数据中，定义了该设备所使用的 COB-ID、传输类型、定时周期等。\n\n其中，RPDO通讯参数位于对象字典索引的 1400h to 15FFh，TPDO通讯参数位于对象字典索引的 1800h to 19FFh。\n\n> 前面说过，不同类别对象的索引，是有规定的，不是随便定的。这里就看到了。\n\n每条索引代表一个PDO的通信参数集，其中的子索引分别指向具体的各种参数。如表所示。\n\n![PDO的通讯参数](./canopen/PDO的通讯参数.jpg)\n\n* Number of entries 参数条目数量：即本索引中有几条参数；\n* COB-ID：即这个PDO发出或者接收的对应CAN帧ID；\n* 发送类型：即这个PDO发送或者接收的传输形式，通常使用循环同步和异步 制造商特定事件较多；\n* Inhibit time生产禁止约束时间(1/10ms)：约束PDO发送的最小间隔，避免导致总线负载剧烈增加，比如数字量输入过快，导致状态改变发送的TPDO频繁发送，总线负载加大，所以需要一个约束时间来进行“滤波”，这个时间单位为0.1ms；\n* Event timer事件定时器触发的时间(单位ms)：定时发送的PDO，它的定时时间，如果这个时间为0，则这个PDO为事件改变发送。\n* SYNC start value同步起始值：同步传输的PDO，收到诺干个同步包后，才进行发送，这个同步起始值就是同步包数量。比如设置为2，即收到2个同步包后才进行发送。\n\n\n\n### 3.2.4 PDO映射参数（难）\n\nPDO 对象并不是和 SDO 一样直接看着表使用`ID + DATA`发送出去的。\n\nPDO 所携带的实时数据类型和内容是由设备对象字典中所规定的该 PDO 映射结构决定。\n\n\n\nPDO映射参数，包含了一个对象字典中的对象列表，这些对象映射到相应的PDO，其中包括数据的长度（单位，位），对于生产者和消费者都必须要知道这个映射参数，才能够正确的解释PDO内容。就是将通信参数、应用数据和具体CAN报文中数据联系起来。\n\n* RPDO 通讯参数 1400h to 15FFh，映射参数 1600h to 17FFh，数据存放为 2000h 之后厂商自定义区域；\n* TPDO 通讯参数 1800h to 19FFh，映射参数 1A00h to 1BFFh，数据存放为 2000h 之后厂商自定义区域。\n\n有点懵逼哈，整个例子，看下图。\n\n![PDO在对象字典的映射关系](figures/PDO在对象字典的映射关系.jpg)\n\n解释一下这张图：\n\n* 第一个表：从 Index 索引可以看出这是个 TPDO 对象。子索引和对应的对象内容，定义了该对象的ID、发送类型等。\n* 第二个表：从 Index 索引可以看出，这是上面那个 TPDO 对象的映射对象。\n  * 子索引 01h 的内容为 0x2000 01 08，表示索引为 0x1800 的 TPDO 对象的前 8 位值为：索引为2000h、子索引为 0x01 的对象的值。\n  * 子索引 02h 的内容为 0x2003 03 10，表示索引为 0x1800 的 TPDO 对象的接着 16 位值为：索引为2003h、子索引为 0x03 的对象的值。（注意，低位在前）\n  * 子索引 03h 的内容为 0x2003 01 08，表示索引为 0x1800 的 TPDO 对象的接着 8 位值为：索引为2003h、子索引为 0x01 的对象的值。\n* 第三个表，从 Index 可以看出，这里是厂商自定义区域。\n* 第四个表，我们实际发送的内容\n  * ID：0x181。（从第一个表看）\n  * DATA：就是按照上面映射得到的值。\n\n\n\n另外，前面说对象的索引不是能随便定义的。\n\n* 分配对象：索引为0x1cxx\n* 映射对象：索引为0x16xx、0x1Axx\n* 应用对象：索引为0x6xxx、0x7xxx\n\n比如，3.1小节的案例中，发送的对象的索引为0x6060，就是一个应用对象。这里的映射对象的索引也是确定的。\n\n\n\n### 3.2.5 设置步骤\n\nPDO报文用来传输有实时性要求的过程数据，传输类型可以是事件类型、同步传输、周期传输。PDO报文基于生产者消费者模式，所以使用之前需要先配置好生产者和消费者，这些在映射参数（1600h+n）和通信参数（1400h+n）里面完成。具体分以下三步完成。注：n 为设备地址。\n\n**接收型 RPDO**\n\n1. 在索引`1400h + n`，子索引 01 确定的变量里写入`COB-ID`(4字节)\n\n2. 在索引`1400h + n`，子索引 02 里面写入传输类型`t`（1字节）t = 1--240，表示设备每收到 t 个同步报文发送一次 PDO；t = 253，表示每收到一个远程（RTR = 1）PDO 请求后方可发送；t = 254，表示事件触发传输模式（制造商特定事件）；t = 255，事件触发传输模式（设备子协议CiA 401特定事件），即利用设备自身内部的定时器，定时发送一条 PDO 报文。\n\n3. 在索引`1600h + n`下面定义映射关系，子索引 00：定义其后面的总子索引数目，在该例子中为2；\n\n4. 在索引`1600h + n`下面定义映射关系，子索引 01：写入第一个变量的映射地址，按以下格式写：\n\n   索引（2字节）- 子索引（1字节）- 数据类型（1字节）。例如将1号通道的模拟量值定义为映射变量，它的索引为6401h，子索引为01，数据类型为2字节16位，代号为10h，连起来即64010110h；\n\n5. 在索引`1600h + n`下面定义映射关系，子索引 02：这里定义 1-8 通道的数字量输入（索引6000h：01）为映射变量，故其内容为60000108h。至此已完成配置。\n\n**发送型 PDO**\n\n1. 在索引`1800h + n`，子索引 01 写入 COB-ID；\n2. 在其对应子索引 02 写入传输类型，同 RPDO；\n3. 在索引`1A00h + n`配置映射，具体同 RPDO。\n\n\n\n\n\n# 4. 补充\n\n这也是很关键的部分，但是为了防止影响理解上面的PDO、SDO，后说这部分。\n\n## 4.1 NMT网络管理\n\n在 CAN 通讯中，所有节点通信地位平等，运行时允许自行发送报文。\n\n但，CANopen 网络为了稳定可靠可控。在一个通讯网络中需要设置：\n\n* 一个网络管理主机**NMT-Master（Network Management-Master）**。一般是 CANopen 网络中具备监控的 PLC 或者 PC。也称为 CANopen 主站。\n* 剩下的一个或多个为从机**NMT-slaves**。\n\n\n\nNMT主机和NMT从机之间通讯的报文就称为**NMT网络管理报文**。管理报文负责层管理、网络管理和ID分配服务。例如，初始化、配置和网络管理（其中包括节点保护）。\n\n另外，为了**协调各个节点的同步、心跳、时间、错误提示**等通讯控制，CANopen还定义了一系列**特殊协议**（Special protocols）报文。\n\n![NMT报文和特殊协议报文](./canopen/NMT报文和特殊协议报文.jpg)\n\n上图中，绿色底纹的常用。\n\n每个**CANopen从节点**的 CANopen 协议栈中，必须具备 NMT 管理的相应代码。这是节点具备 CANopen 协议的最基本的要素。\n\n## 4.2 NMT节点状态\n\nNMT管理涉及到一个CANopen节点从上电开始的6钟状态，包括：\n\n1. 初始化（Initializing）：节点上电后对功能部件包括 CAN 控制器进行初始化；\n2. 应用层复位(Application Reset）：节点中的应用程序复位(开始），比如开关量输出模拟量输出模拟量输出的初始值；\n3. 通讯复位（Communication reset）：节点的 CANopen 通讯复位（开始），从这个时刻，此节点就可以进行  CANopen 通讯了；\n4. 预操作状态（Pre-operational）：节点的 CANopen 通讯处于操作就绪状态，此时此节点不能进行 PDO 通信，而可以进行 SDO 进行参数配置和 NMT 网络管理的操作；\n5. 操作状态（operational）：节点收到 NMT 主机发来的启动命令后，CANopen 通讯被激活，PDO 通信启动后，按照对象字典里面规定的规则进行传输，同样 SDO 也可以对节点进行数据传输和参数修改；\n6. 停止状态（Stopped）：节点收到 NMT 主机发来的停止命令后，节点的 PDO 通信被停止，但 SDO 和 NMT 网络管理依然可以对节点进行操作；\n\n除了初始化状态，NMT 主机通过 NMT 命令可以让网络中任意一个的 CANopen 节点进行其他5种状态的切换。当然 CANopen 节点也可以程序自动完成这些状态的切换。\n\n![NMT管理状态转换图](./canopen/NMT管理状态转换图.jpg)\n\n\n\n## 4.3 NMT节点报文\n\n* 节点上线报文：任何一个 CANopen 从站上线后，为了提示主站它已经加入网络（便于热插拔），或者避免与其他从站 Node-ID 冲突。这个从站必须发出**节点上线报文（boot-up）**，节点上线报文的**ID为 700h + Node-ID**，**数据为1个字节0**。生产者为 CANopen 从站。\n\n> 简单来说，一个从节点上线需要先发送个报文，告诉主机我上线了。\n\n* 心跳报文：为了监控 CANopen 节点是否在线与目前的节点状态。从站需要定时发送状态报文（心跳报文）。ID与节点上线报文相同为**700h + Node-ID**，**数据为1个字节**，代表节点目前的状态，04h为停止状态，05h为操作状态，7Fh为预操作状。\n\n> CANopen 从站按其对象字典中 1017h 中填写的心跳生产时间（ms）进行心跳报文的发送，而 CANopen 主站（NMT主站）则会按其 1016h 中填写的心跳消费时间进行检查，假设超过诺干次心跳消费时间没有收到从站的心跳报文，则认为从站已经离线或者损坏。\n\n* 节点守护：在早期 CANopen 应用中，可以通过轮询模式监视从站状态的节点守护模式，它与心跳报文模式二者不能并存。通过节点守护，MNT主机可以检查每个节点的当前状态。很少用了。\n\n* NMT节点状态切换命令：NMT网络管理中，最核心的就是NMT节点状态切换命令，这是NMT主站所进行网络管理的“命令”报文。\n  * CAN-ID 均为 000h，具备最高的 CAN 优先级。数据为2个字节：\n    * 第1个字节代表命令类型：\n      * 01h 为启动命令（让节点进入操作状态）；\n      * 02h 为停止命令（让节点进入停止状态）；\n      * 80h 为进入预操作状态（让节点进入预操作状态）；\n      * 81h 为复位节点应用层（让节点的应用恢复初始状态，比如列车门都恢复打开状态）；\n      * 82h 为复位节点通讯（让节点的 CAN 和 CANopen 通讯重新初始化，一般用于总线收到干扰，导致节点总线错误被动，或者总线关闭时）。\n    * 第二个字节代表被控制的节点 Node-ID，如果要对整个网络所有节点同时进行控制，则这个数值为0即可。\n\n另外还有\n\n* 同步协议（Syncprotocol）\n* 时间戳协议（Time-stamp protocol）：CAN-ID 为 100h，数据长度为 6，数据为当前时刻与1984年1月1日0时的时间差。\n* 紧急报文协议（Emergency protocol）：其 CAN-ID 存储在 1014h 的索引中，一般会定义为`0x080 + Node-ID`，数据包含8个字节。\n","tags":["Can","CanOpen"],"categories":["通信协议"]},{"title":"Modbus","url":"/2023/01/01/07. 通信协议/modbus/","content":"\n\n\n# 1. 简介\n\n特点\n\n* 免费\n* 简单\n* 接口：Modbus协议只是一种规约，属于应用层的协议，因此不仅可以应用在串口（485/232/422），也可以在以太网、光纤、蓝牙、无线上传输。\n\n\n\n# 2. Modbus 思路\n\n## 2.1 存储区分类\n\n我们想要制定一个协议，我们首先要明确，协议的目的是为了数据传输。\n\n把数据分类：\n\n* 布尔数据（线圈，即只有开断的概念，也就是值只有0/1）\n* 非布尔数据（寄存器，即各种不同的数据，一般为16位）\n\n这些数据按照输入还是输出，还可以继续分类。\n\n* 输入意味着该存储区里的值必须由外部设备接入，是`只读`的。\n* 输出表示输出结果给外部设备，是`可读可写`的。\n\n因此，进一步分类之后得到：\n\n| 序号 | 读写 | 存储类型 | 存储区名称 |\n| :--: | :--: | :------: | :--------: |\n|  1   | 只读 |   线圈   |  输入线圈  |\n|  2   | 读写 |   线圈   |  输出线圈  |\n|  3   | 只读 |  寄存器  | 输入寄存器 |\n|  4   | 读写 |  寄存器  | 保持寄存器 |\n\n## 2.2 存储区代号\n\nModbus 用数字给这些存储区取了一个代号，就有了下面的存储区代号的规定：\n\n| 序号 | 读写 | 存储类型 | 存储区名称 | 存储区代号 |\n| :--: | :--: | :------: | :--------: | :--------: |\n|  1   | 只读 |   线圈   |  输入线圈  |    1区     |\n|  2   | 读写 |   线圈   |  输出线圈  |    0区     |\n|  3   | 只读 |  寄存器  | 输入寄存器 |    3区     |\n|  4   | 读写 |  寄存器  | 保持寄存器 |    4区     |\n\n## 2.3 存储区范围\n\nModbus 规定，每个存储区的最大范围是 65536。那么，访问一个数据，我们需要知道它在哪个存储区、它在这个存储区的索引是什么。\n\n这里我们按照绝对地址、相对地址的概念来理解：\n\n我们把：\n\n* `存储区编号` + `地址索引` 理解为**绝对地址**。\n* 后面的地址索引 理解为**相对地址**。\n\n那么对于 Modbus：绝对地址 = 区号 + 相对地址\n\n---\n\n| 存储区名称 | 存储区代号 |  绝对地址范围   | 相对地址范围 |\n| :--------: | :--------: | :-------------: | :----------: |\n|  输入线圈  |    1区     | 100001 - 165536 |  0 - 65535   |\n|  输出线圈  |    0区     | 000001 - 065536 |  0 - 65535   |\n| 输入寄存器 |    3区     | 300001 - 365536 |  0 - 65535   |\n| 保持寄存器 |    4区     | 400001 - 465535 |  0 - 65535   |\n\n> 以保持型寄存器为例，可以看到，第一个绝对地址是400001，这个地方不是400000，这个是由 Modbus 规约决定的，其它存储区也是类似。\n\n但在实际使用中，我们一般用不了这么多地址，一般情况下，10000 以内就已经足够我们使用了，因此，为了方便起见，我们有一种短的地址模型，如下：\n\n| 存储区名称 | 存储区代号 | 绝对地址范围  | 相对地址范围 |\n| :--------: | :--------: | :-----------: | :----------: |\n|  输入线圈  |    1区     | 10001 - 19999 |   0 - 9998   |\n|  输出线圈  |    0区     | 00001 - 09999 |   0 - 9998   |\n| 输入寄存器 |    3区     | 30001 - 39999 |   0 - 9998   |\n| 保持寄存器 |    4区     | 40001 - 49999 |   0 - 9998   |\n\n\n\n## 2.4 功能码\n\n我们的初衷是，传输数据，即读取或者写入数据。\n\n我们根据数据的类型已经分好区域了，只需对其读写就好了。那么，我们怎么表示我们是要读还是写呢？这个动作就是功能码。好了，继续分类。\n\n数据（存储区）有四种，读写这个动作是两种，但是有两种数据是只读的，没有写动作。因此一共有六种行为。\n\n| 行为序号 |      行为      |\n| :------: | :------------: |\n|    1     |  读取输入线圈  |\n|    2     |  读取输出线圈  |\n|    3     | 读取输入寄存器 |\n|    4     | 读取保持寄存器 |\n|    5     |  写入输出线圈  |\n|    6     | 写入保持寄存器 |\n\n但是，Modbus 规约将写入输出线圈和写入保持寄存器这 2 种行为，又进一步做了细分，包括写入单个和写入多个，因此原来的 6 种行为就变成了 8 种行为，同时给每种行为设置一个代号，就形成了下表所示的功能码列表：\n\n| 功能码 |    功能说明    |\n| :----: | :------------: |\n|  0x01  |  读取输出线圈  |\n|  0x02  |  读取输入线圈  |\n|  0x03  | 读取保持寄存器 |\n|  0x04  | 读取输入寄存器 |\n|  0x05  |  写入单个线圈  |\n|  0x06  | 写入单个寄存器 |\n|  0x0F  |  写入多个线圈  |\n|  0x10  | 写入多个寄存器 |\n\n> Modbus 规约中的功能码其实不止这 8 个，还有一些功能码是用于诊断或异常码，但是一般很少使用，这 8 种功能码是最主要的核心功能码。\n\n\n\n## 2.5 协议分类\n\nModbus 严格来说，是一个标准化的规约，而不是一个具体协议。我们常说的设备A和设备B之间通过 Modbus 协议来通信，这句话其实是不严谨的。\n\nModbus 规约上有三种不同的协议：\n\n* ModbusRtu\n* ModbusAscii\n* ModbusTcp\n\n一般来说，ModbusRtu 和 ModbusAscii 是运行在串口上的协议，ModbusTcp 是运行是以太网上的协议，但是这并非绝对的，我们也可以将 ModbusRtu、ModbusAscii 运行在以太网或光纤上使用，同样的，在串口网络里，我们也可以使用 ModbusTcp 的协议，因为协议只是一种规范，并不限制通信介质。\n\n\n\n## 2.6 报文格式\n\n* ModbusRtu 的报文格式如下（经常需要自己实现）：\n  * 第一部分：从站地址，占1个字节\n  * 第二部分：功能码，占1个字节\n  * 第三部分：数据部分，每个数据2字节（高字节在前）\n  * 第四部分：校验部分，CRC校验，占2个字节（校验前面的所有数据，结果低字节在前）\n\n* ModbusAscii 的报文格式如下：\n  * 第一部分：开始字符（:）\n  * 第二部分：从站地址，占2个字节\n  * 第三部分：功能码，占2个字节\n  * 第四部分：数据部分，占N个字节\n  * 第五部分：校验部分，LRC校验，占2个字节\n  * 第六部分：结束字符（CR LF）\n\n* ModbusTcp 的报文格式如下：\n  * 第一部分：事务处理标识符，占2个字节\n  * 第二部分：协议标识符，占2个字节\n  * 第三部分：长度，占2个字节\n  * 第四部分：单元标识符，占1个字节\n  * 第五部分：功能码，占1个字节\n  * 第六部分：数据部分，占N个字节\n\n\n\n# 3. 协议补充\n\n前面 Modbus 协议建立的过程中，没有丝毫提及通信应该用几根线、用什么样的线。\n\n可以看出，跟串口、IIC、SPI、CAN之类的协议不同，这里定义的只是一种**消息结构**。而不管你是用哪种方式通信的。\n\n\n\n## 3.1 主从模式\n\n前面可以看出，数据收发需要`一个节点（主节点）`主动向`另一个节点（从节点）`发起请求，然后从节点进行回复。这种数据收发模式叫**单播模式**。\n\n也可以，`主节点`向`所有从节点`发送请求，从节点无需发送应答，只需要执行相应的动作就可以了。这种模式叫**广播模式**。\n\n> 一个网络中可以有一个主节点、一个或多个从节点。\n\n\n\n## 3.2 ADU、PDU\n\n每次 Modbus 发送的报文为：地址域 + 功能码 + 数据 + 差错校验\n\n* 地址域：要发送给的从节点（0 广播地址，1-247 从节点地址，248-255 保留地址）。\n* 功能码：要执行的动作。前面表格里说过了。\n* 数据域：要发送的数据。\n* 校验码：校验。\n\n其中：\n\nADU（应用数据单元）= 地址域 + 功能码 + 数据 + 差错校验\n\nPDU（协议数据单元）= 功能码 + 数据\n\n\n\n另外，ADU 的最大长度为：256 字节。\n\n而 PDU 的最大长度要看使用的通信方式。\n\n* 如果使用RS232、RS485通信\n\nADU = 地址域（1字节）+ PDU（）+ CRC（2字节）= 256字节。\n\n即 PDU 最大为 253 字节。\n\n* 如果使用以太网口通信，其是再TCP/IP协议中又封装了一层 modbus 协议。\n\nADU = MBAP（7字节）+ PDU（）= 256字节。\n\n即 PDU 最大为 249 字节。\n\n\n\n# 4. 手写代码实现\n\n实际使用中，在linux编程中，如果使用modbus，基本上都可以直接使用现成的库。\n\n而如果使用单片机进行通信，一般用的最多的是**ModbusRtu**，因为串口（485）是比较经济的通信方式，同时为了方便，大多都是对寄存器数据的操作。\n\n这里需要自己可以实现此种通信方式，主要需要实现以下接口（从发送和接收方都需要会实现）：\n\n* 写单个寄存器\n* 读多个寄存器\n\n\n\n**读寄存器命令：**\n\n1. 字节0：从机地址\n2. 字节1：命令，读为0x04\n3. 字节2-3：要读的寄存器地址，高字节在前\n4. 字节4-5：要读的寄存器个数\n5. 字节6-7：CRC校验码（低字节在前）\n\n**响应读寄存器命令：**\n\n1. 字节0：从机地址\n2. 字节1：功能码，还是04（原样回复）\n3. 字节2：数据长度（一个寄存器16位，则长度为 寄存器个数*2）\n4. 字节3-4：寄存器1数据\n5. 字节5-6：寄存器2数据\n6. ...\n7. 最后两个字节数据：CRC\n\n**写寄存器命令：**\n\n1. 字节0：从机地址\n2. 字节1：命令，写为0x06\n3. 字节2-3：要写的寄存器地址，高字节在前\n4. 字节4-5：要写的寄存器值，高字节在前\n5. 字节6-7：CRC校验码（低字节在前）\n\n**响写寄存器命令：**\n\n1. 字节0：从机地址\n2. 字节1：命令，写为0x06\n3. 字节2-3：写的寄存器地址，高字节在前\n4. 字节4-5：写的寄存器值，高字节在前\n5. 字节6-7：CRC校验码（低字节在前）\n\n\n\n## 4.1 发送方（读 或 写的一方）\n\n~~~ c\n#include \"mlcp.h\"\n#include \"mlcp_def.h\"   // modbus地址定义\n#include <string.h>     // 内存比较函数\n#include \"Tool.h\"       // 日志输出接口\n#include \"serial.h\"     // 串口接口\n\n// ==================================================== modbus操作接口 ==================================================== //\n\ntypedef enum _MODBUS_STATUS\n{\n    MODBUS_OK = 0x01,\n    MODBUS_SEND_FAILED = 0x01,\n    MODBUS_RECV_TIMEOUT = 0x02,\n    MODBUS_ADDR_ERROR = 0x03,\n    MODBUS_CRC_ERROR = 0x04,\n} MODBUS_STATUS;\n\n// 计算modbus校验码\nstatic uint16_t modbus_crc16(uint8_t *data, uint8_t len)\n{\n    uint16_t crc = 0xffff;\n\n    for (uint8_t num = 0; num < len; num++)\n    {\n        crc = (*data++) ^ crc;\n        for (uint8_t x = 0; x < 8; x++)\n        {\n            if (crc & 0x0001)\n            {\n                crc = crc >> 1;\n                crc = crc ^ 0xA001;\n            }\n            else\n            {\n                crc = crc >> 1;\n            }\n        }\n    }\n    return crc;\n}\n\n// 读寄存器操作\n// reg_addr: 要读的寄存器地址。reg_num: 要读的寄存器数量。reg_data: 读到的寄存器值\nstatic MODBUS_STATUS modbus_read_reg(uint16_t reg_addr, uint16_t reg_num, uint16_t *reg_data)\n{\n    // 先清空缓冲区中的数据\n    uint8_t temp_tx_buf[1];\n    while (SerialReceive(MLCP_UART_PORT, temp_tx_buf, 1) > 0)\n    {\n    }\n\n    // 发送读寄存器命令\n    uint8_t tx_message[8] = {0};\n    tx_message[0] = DEFAULT_MLCP_ADDR;      // 下位机地址\n    tx_message[1] = 0x03;                   // 读数据\n    tx_message[2] = (reg_addr >> 8) & 0xFF; // 寄存器地址（高位）\n    tx_message[3] = (reg_addr >> 0) & 0xFF; // 寄存器地址（低位）\n    tx_message[4] = (reg_num >> 8) & 0xFF;  // 寄存器个数（高位）\n    tx_message[5] = (reg_num >> 0) & 0xFF;  // 寄存器个数（低位）\n    uint16_t crc16_tx = modbus_crc16(tx_message, 6);\n    tx_message[6] = (crc16_tx >> 0) & 0xFF; // CRC校验码（低位）\n    tx_message[7] = (crc16_tx >> 8) & 0xFF; // CRC校验码（高位）\n\n    // 发送数据\n    if (0 != SerialSend(MLCP_UART_PORT, tx_message, 8))\n    {\n        return MODBUS_SEND_FAILED;\n    }\n\n    // 等待返回数据（返回的数据会存到缓冲区中）\n    task_delay(30);\n\n    // 从缓冲区中接收返回的数据，数据长度 = 设备地址1 + 功能码1 + 数据长度1 + 返回数据reg_num*2 + CRC校验2 = 5 + reg_num * 2\n    uint16_t recv_data_len = 5 + reg_num * 2;\n    uint8_t rx_message[100] = {0};      // 串口缓冲区也就这么大，最大支持47个寄存器\n    if (recv_data_len != SerialReceive(MLCP_UART_PORT, rx_message, recv_data_len))\n    {\n        return MODBUS_RECV_TIMEOUT;\n    }\n    \n    if ((rx_message[0] == DEFAULT_MLCP_ADDR) && // 从机地址正确\n        (rx_message[1] == 0x03) &&              // 功能码正确\n        (rx_message[2] == (reg_num * 2)))       // 数据长度正确\n    {\n        // 计算CRC\n        uint16_t crc_rx = modbus_crc16(rx_message, reg_num * 2 + 3);\n        uint8_t crc_rx_h = crc_rx >> 8;\n        uint8_t crc_rx_l = crc_rx & 0xFF;\n        \n        if ((rx_message[reg_num * 2 + 3] == crc_rx_l) && (rx_message[reg_num * 2 + 3 + 1] == crc_rx_h))\n        {\n            // 数据，高字节在前\n            uint8_t i = 0;\n            while (i < reg_num)\n            {\n                reg_data[i] = ((rx_message[3 + i * 2] << 8) | (rx_message[3 + i * 2 + 1]));\n                i++;\n            }\n            \n            return MODBUS_OK;\n        }\n        else\n        {\n            return MODBUS_CRC_ERROR;\n        }\n    }\n    \n    return MODBUS_ADDR_ERROR;\n}\n\n// 写寄存器操作\n// reg_addr: 要写的寄存器地址。reg_data: 要写入到寄存器的值\nstatic MODBUS_STATUS modbus_write_reg(uint16_t reg_addr, uint16_t reg_data)\n{\n    // 先清空缓冲区中的数据\n    uint8_t temp_tx_buf[1];\n    while (SerialReceive(MLCP_UART_PORT, temp_tx_buf, 1) > 0)\n    {\n    }\n\n    // 发送写寄存器命令\n    uint8_t tx_message[8] = {0};\n    tx_message[0] = DEFAULT_MLCP_ADDR;      // 下位机地址\n    tx_message[1] = 0x06;                   // 写数据\n    tx_message[2] = (reg_addr >> 8) & 0xFF; // 寄存器地址（高位）\n    tx_message[3] = (reg_addr >> 0) & 0xFF; // 寄存器地址（低位）\n    tx_message[4] = (reg_data >> 8) & 0xFF; // 待写入寄存器的值（高位）\n    tx_message[5] = (reg_data >> 0) & 0xFF; // 待写入寄存器的值（低位）\n    uint16_t crc16_tx = modbus_crc16(tx_message, 6);\n    tx_message[6] = (crc16_tx >> 0) & 0xFF; // CRC校验码（低位）\n    tx_message[7] = (crc16_tx >> 8) & 0xFF; // CRC校验码（高位）\n\n    // 发送数据\n    if (0 != SerialSend(MLCP_UART_PORT, tx_message, 8))\n    {\n        return MODBUS_SEND_FAILED;\n    }\n\n    // 等待返回数据（返回的数据会存到缓冲区中）\n    task_delay(30);\n\n    // 从缓冲区中接收返回的数据，数据长度 = 设备地址1 + 功能码1 + 数据长度1 + 返回数据reg_num*2 + CRC校验2 = 5 + reg_num * 2\n    uint8_t rx_message[10] = {0};\n    if (8 != SerialReceive(MLCP_UART_PORT, rx_message, 8))\n    {\n        return MODBUS_RECV_TIMEOUT;\n    }\n    \n    // 写数据时，发送的数据和返回的数据相同\n    if (0 == memcmp(tx_message, rx_message, 8))\n    {\n        return MODBUS_OK;\n    }\n    \n    return MODBUS_ADDR_ERROR;\n}\n\n// ==================================================== app应用读取接口 ==================================================== //\n\nmlcp_data_t mlcp;\n\nstatic void mlcp_read_version(void)\n{\n    MODBUS_STATUS status;\n    uint16_t table[1];\n\n    status = modbus_read_reg(SOFTWARE_VERSION_REGISTER, 1, table);\n    \n    if (MODBUS_OK == status)\n    {\n        mlcp.version = table[0];\n        Log_DebugOut(\"[MLCP] mlcp version is %d \\r\\n\", mlcp.version);\n    }\n    else\n    {\n        Log_DebugOut(\"[MLCP] mlcp read version failed, status = %d \\r\\n\", status);\n        mlcp.err_count++;\n    }\n}\n\nstatic void mlcp_read_status(void)\n{\n    MODBUS_STATUS status;\n    uint16_t table[33];\n\n    status = modbus_read_reg(WORKING_MODE_REGISTER, 33, table);\n    \n    if (MODBUS_OK == status)\n    {\n        mlcp.now_work_mode = (MLCP_MODE)table[0]; // 当前工作状态\n        mlcp.error_info = table[1];               // 故障信息\n        mlcp.warnning_info = table[2];            // 预警信息\n        mlcp.temp_in = (float)table[3] / 10 - 40;   // 进液温度\n        mlcp.temp_out = (float)table[4] / 10 - 40;  // 出液温度\n        mlcp.temp_env = (float)table[6] / 10 - 40;  // 环境温度\n        mlcp.press_in = table[20];                // 进液压力\n        mlcp.press_out = table[21];               // 出液压力\n        mlcp.fan1_speed = table[23];              // 风机1转速\n        mlcp.fan2_speed = table[24];              // 风机2转速\n        mlcp.fan3_speed = table[25];              // 风机3转速\n        mlcp.fan4_speed = table[26];              // 风机4转速\n        mlcp.fan5_speed = table[27];              // 风机5转速\n        mlcp.fan6_speed = table[28];              // 风机6转速\n        mlcp.fan7_speed = table[29];              // 风机7转速\n        mlcp.io_input_status = table[32];         // IO输入状态\n\n        mlcp.err_count = 0;\n    }\n    else\n    {\n        Log_DebugOut(\"[MLCP] mlcp read status failed, status = %d \\r\\n\", status);\n        mlcp.err_count++;\n    }\n}\n\nstatic void mlcp_write_mode(void)\n{\n    // 如果目标模式和实际模式不一致\n    if (mlcp.now_work_mode != mlcp.need_work_mode)\n    {\n        MLCP_MODE set_mode = SHUTDOWN_MODE;\n\n        // 如果当前没有故障\n        if (mlcp.error_info == 0)\n        {\n            set_mode = (uint16_t)(mlcp.need_work_mode);\n        }\n\n        // 写 \n        if (MODBUS_OK != modbus_write_reg(WORK_MODE_REGISTER, set_mode))\n        {\n            mlcp.err_count++;\n        }\n    }\n\n    // 风机转速\n    if (MODBUS_OK != modbus_write_reg(FAND_SPEED_CTRL_REGISTER, mlcp.need_fan_speed))\n    {\n        mlcp.err_count++;\n    }\n}\n\nstatic void mlcp_offline_recovery()\n{\n    // 大概断开十几秒\n    if (mlcp.err_count >= 50)\n    {\n        // 防止溢出\n        mlcp.err_count = 50;\n\n        SerialClose(MLCP_UART_PORT);\n\n        task_delay(5);\n\n        SerialOpen(MLCP_UART_PORT, 115200);\n\n        mlcp.now_work_mode = ERROR_MODE;\n    }\n}\n\n// modbus读取任务\nvoid mlcp_task_func(void *arg)\n{\n    // 打开串口\n    while (1)\n    {\n        if (0 == SerialOpen(MLCP_UART_PORT, 115200))\n        {\n            Log_DebugOut(\"[MLCP] mlcp open uart%d success! \\r\\n\", MLCP_UART_PORT);\n            break;\n        }\n        else\n        {\n            Log_DebugOut(\"[MLCP] mlcp open uart%d failed! \\r\\n\", MLCP_UART_PORT);\n            task_delay(1000);\n        }\n    }\n\n    // 获取版本信息\n    mlcp_read_version();\n    \n    for (;;)\n    {\n        task_delay(200);\n        \n        mlcp_read_status();\n\n        task_delay(200);\n        \n        mlcp_write_mode();\n\n        task_delay(200);\n\n        mlcp_offline_recovery();\n    }\n}\n\nvoid mlcp_init(void)\n{\n    memset(&mlcp, 0, sizeof(mlcp));\n\n    struct task_struct *mlcp_task = NULL;\n\n    mlcp_task = task_create(mlcp_task_func,\n                            \"mlcp_task\",\n                            (uint16_t)4096,\n                            NULL,\n                            (unsigned long)5);\n    if (mlcp_task != NULL)\n    {\n        Log_DebugOut(\"[MLCP] Creat mlcp_task success! \\r\\n\");\n    }\n    else\n    {\n        Log_DebugOut(\"[MLCP] Creat mlcp_task faild  %08x ! \\r\\n\", (uint32_t)mlcp_task);\n    }\n}\n\n// 设置当前工作模式\nuint8_t mlcp_set_work_status(MLCP_MODE mode)\n{\n    if ((mode == SHUTDOWN_MODE) || (mode == WORKING_MODE))\n    {\n        mlcp.need_work_mode = mode;\n        return 0;\n    }\n\n    return 1;\n}\n\n// 获取当前工作模式\nMLCP_MODE mlcp_get_work_status(void)\n{\n    return mlcp.now_work_mode;\n}\n\n// 设置风机转速\nuint8_t mlcp_set_fan_speed(uint8_t speed)\n{\n    if (speed <= 100)\n    {\n        mlcp.need_fan_speed = speed;\n\n        return 0;\n    }\n\n    return 1;\n}\n~~~\n\n\n\n## 4.2 接收方（创建寄存器/被读或写的一方）\n\n\n\n~~~ c\n/*\n * upper_modbus_task.c\n *\n *  Created on: 2024年9月9日\n *      Author: ZhangJinhao\n */\n\n/* 功能码 */\n#define READ_REGISTER 0x03  // 读寄存器\n#define WRITE_REGISTER 0x06 // 读寄存器\n#define ERROR_BACK 0x80     // 读寄存器(0x80+异常码)\n\n// 计算modbus校验码\nstatic uint16_t modbus_crc16(uint8_t *data, uint8_t len)\n{\n\tuint16_t crc = 0xffff;\n\n\tfor (uint8_t num = 0; num < len; num++)\n\t{\n\t\tcrc = (*data++) ^ crc; // 把数据与16位的CRC寄存器的低8位相异或，结果存放于CRC寄存器\n\t\tfor (uint8_t x = 0; x < 8; x++)\n\t\t{\n\t\t\t// 判断最低位为：“1”\n\t\t\tif (crc & 0x0001)\n\t\t\t{\n\t\t\t\tcrc = crc >> 1;\t\t// 先右移\n\t\t\t\tcrc = crc ^ 0xA001; // 再与0xA001异或\n\t\t\t}\n\t\t\telse // 判断最低位为：“0”\n\t\t\t{\n\t\t\t\tcrc = crc >> 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn crc;\n}\n\n// crc校验,0成功，1失败\nstatic uint8_t modbus_crc_check(uint8_t *data)\n{\n\tuint16_t result = 0;\n\tuint8_t crc_h, crc_l;\n\n\tresult = modbus_crc16(data, 6);\n\n\tcrc_h = (uint8_t)(result >> 8);\n\tcrc_l = (uint8_t)(result & 0xFF);\n\n\tif (crc_l == data[6] && crc_h == data[7])\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn 1;\n\t}\n}\n\n// 上位机读数据，板卡回复\nvoid upper_modbus_read_register(upper_uart_ptr dev, uint8_t *data)\n{\n\tuint16_t register_addr = 0;\n\tuint16_t register_len = 0;\n\tuint8_t respond_data[400] = {0};\t// 存储回应回去的数据\n\n\t// 解析命令\n\tregister_addr = (data[2] << 8) | data[3];\t// 目标寄存器地址\n\tregister_len = (data[4] << 8) | data[5];\t// 想要读取的寄存器个数\n\n\t// 拼接回应数据\n\trespond_data[0] = data[0];    //从机ID\n\trespond_data[1] = data[1];    //功能码\n\trespond_data[2] = (uint8_t)(register_len * 2);    \t// 获取总的字节数\n\tfor(uint16_t i = 0; i <= register_len; i++)\t\t\t// 读取的寄存器的值\n\t{\n\t\tuint16_t temp_addr = register_addr + i;\n\n\t\tuint16_t temp_data = 0;\n\t\tuint8_t data_h = 0, data_l = 0;\n\n        // 根据地址，填需要回复的数据\n\t\tswitch(temp_addr)\n\t\t{\n\t\t/* part 1 */\n\t\tcase MODUBLE_ADDR_REGISTER:\t\t\t// 从机地址信息\n\t\t\ttemp_data = upper_uart.board_addr;\n\t\t\tbreak;\n\t\tcase SOFTWARE_VERSION_REGISTER:\t\t// 软件版本信息\n\t\t\ttemp_data = SOFT_WARE_VERSION;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttemp_data = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t// 计算高低位\n\t\tdata_h = temp_data >> 8;\n\t\tdata_l = temp_data & 0x00FF;\n\n\t\t// 赋值\n\t\trespond_data[3 + 2 * i] = data_h;\n\t\trespond_data[3 + 2 * i + 1] = data_l;\n\t}\n    // 计算crc\n\tuint16_t crc_temp = modbus_crc16(respond_data, respond_data[2] + 3);\n\trespond_data[respond_data[2] + 3] = crc_temp & 0xFF;\n\trespond_data[respond_data[2] + 3 + 1] = crc_temp >> 8;\n\n\t// 发送回应\n\tupper_uart_send(dev, respond_data, respond_data[2] + 3 + 2);\n}\n\n// 上位机发送写命令，板卡处理\nvoid upper_modbus_write_register(upper_uart_ptr dev, uint8_t *data)\n{\n\tuint16_t register_addr = 0;\n\tuint16_t register_data = 0;\n\n\t// 回应上位机的写命令（原样发回去）\n\tupper_uart_send(dev, data, 8);\n\n\t// 解析命令\n\tregister_addr = (data[2] << 8) | data[3];\t// 目标寄存器地址\n\tregister_data = (data[4] << 8) | data[5];\t// 待写入寄存器的值\n\n    // 根据地址执行动作\n\tif(register_addr == WORK_MODE_REGISTER)\n\t{\n\t}\n\telse if(register_addr == MOTOR_SPEED_CTRL_REGISTER)\n\t{\n\t}\n}\n\n/*\n *\n */\nvoid upper_modbus_task(void)\n{\n\tuint8_t temp_recv_data[8] = {0};\n\tmemset(temp_recv_data, 0, 8);\n\n\t// modbus数据格式,最少八个字节\n\t// 设备地址(1)、功能码(1)、寄存器地址(2,高字节在前)、寄存器个数(2,高字节在前)、CRC校验(2,低字节在前)\n\t// modbus返回数据格式\n\t// 设备地址(1)、功能码(1)、返回数据长度(1)、返回数据(N)、CRC校验(2,低字节在前)\n\n\t// 如果当前缓冲区数据够一帧modbus\n\tif(upper_uart_buf_len(&upper_uart) >= 8)\n\t{\n\t\t// 获取一个字节数据\n\t\tif(upper_uart_recv(&upper_uart, &(temp_recv_data[0])) == 1)\n\t\t{\n\t\t\t// 判断是否是modbus数据头(本设备ID或广播ID)\n\t\t\tif((temp_recv_data[0] == upper_uart.board_addr) || (temp_recv_data[0] == 0xFF))\n\t\t\t{\n//\t\t\t\tuart_port_printf(&debug_uart, \"temp_recv_data[0]=%d, addr=%d \\r\\n\", temp_recv_data[0], upper_uart.board_addr);\n\n\t\t\t\t// 获取紧邻的7个字节\n\t\t\t\tfor(uint8_t i = 1; i < 8; i++)\n\t\t\t\t{\n\t\t\t\t\tupper_uart_recv(&upper_uart, &(temp_recv_data[i]));\n\t\t\t\t}\n\n\t\t\t\t// CRC校验\n\t\t\t\tif(modbus_crc_check(temp_recv_data) == 0)\n\t\t\t\t{\n\t\t\t\t\t// 上位机要读数据，这里需要返回\n\t\t\t\t\tif(temp_recv_data[1] == 0x03)\n\t\t\t\t\t{\n\t\t\t\t\t\tupper_modbus_read_register(&upper_uart, temp_recv_data);\n\t\t\t\t\t}\n\t\t\t\t\t// 上位机要写数据，这里需要处理\n\t\t\t\t\telse if(temp_recv_data[1] == 0x06)\n\t\t\t\t\t{\n\t\t\t\t\t\tupper_modbus_write_register(&upper_uart, temp_recv_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n~~~\n\n\n\n# 5. 测试软件\n\n模拟 Modbus 协议有电脑即可，无需任何硬件。用于查看协议报文格式。\n\n* Modbus Slave\n* Modbus Poll\n* Configure Virtual Serial Port Driver\n\n三个软件都是傻瓜式操作，安装即可。\n\n在弹出激活码的时候，把压缩包中的激活码填进去即可。\n\n\n\n# 6. 测试步骤\n\n## 6.1 添加虚拟串口\n\n打开 VSPD 软件，添加虚拟串口。\n\n![VSPD添加串口](./modbus/VSPD添加串口.jpg)\n\n添加完成之后，就可以看到添加的串口了，可以认为这是两个连接在一起的串口。\n\n![虚拟串口](./modbus/虚拟串口.jpg)\n\n\n\n## 6.2 设置主机\n\n打开 ModBus Poll 软件，点击`Setup -> Read/Write Definition`，\n\n设置要通讯的参数，然后点击OK。\n\n![Poll通讯设置](./modbus/Poll通讯设置.jpg)\n\n然后点击`Connection -> Connect`\n\n![Poll连接串口](./modbus/Poll连接串口.jpg)\n\n> 连接上之后，左上角会显示连接超时，正常，毕竟从机还没连接呢。\n\n\n\n## 6.3 设置从机\n\n打开 ModBus Slave 软件，点击`Setup -> Slave Definition`，\n\n设置要通讯的参数，注意从机地址要和刚刚主机设置的一样，然后点击OK。\n\n![Slave通讯设置](./modbus/Slave通讯设置.jpg)\n\n然后点击`Connection -> Connect`\n\n![Slave连接串口](./modbus/Slave连接串口.jpg)\n\n\n\n## 6.4 传输数据\n\n双击从机寄存器的格子，往里面填入任意值，可以看到主机这边会读取到。\n\n主机上面的 Tx=2271，是发送了2271次；Err=241，是失败了241次。\n\n![数据传输效果](./modbus/数据传输效果.jpg)\n\n\n\n## 6.5 RTU报文解析\n\n在主机端，点击`Display communication traffic`可看到主机发送出去和接收到的回复报文。\n\n![收发的报文](./modbus/收发的报文.jpg)\n\n发送报文：Tx：01 03 00 00 00 04 44 09\n\n* 01：从机地址\n* 03：功能码\n* 00 00：寄存器地址\n* 00 04：读取数据个数，4个\n* 44 09：CRC校验\n\n接收报文：Rx：01 03 08 00 01 00 08 00 10 00 14 65 1C\n\n* 01：从机地址\n* 03：功能码\n* 08：返回的字节数（16进制），8个字节。\n* 00 01：第一个数据，1\n* 00 08：第二个数据，8\n* 00 10：第三个数据，16\n* 00 14：第四个数据，20\n* 65 1C：CRC校验\n\n可以看到，就是 ModbusRtu 的报文格式（在第二步中，我们设置的就是 RTU ）。\n\n\n\n## 6.6 TCP报文解析\n\n如果我们不用串口，而使用TCP进行连接。\n\n在主机端，连接时选择如下：\n\n![Poll连接TCP](./modbus/Poll连接TCP.jpg)\n\n在从机端，连接时选择如下：\n\n![Slave连接TCP](./modbus/Slave连接TCP.jpg)\n\n此时，数据通讯的报文如下：\n\n发送报文：Tx：04 44 00 00 00 06 01 03 9C 4A 00 04\n\n* 04 44：事务标识符，可以解释为报文的序列号，由于我们测试使用的Modbus Poll客户端是一直发送数据，所以每发送一次数据标识符就加一。服务器接收时会把这个数据原封返回。\n* 00 00：Modbus TCP协议\n* 00 06：后面有 6 字节长度的数据\n* 01：单元标识符，相当于设备的地址。01\n* 03：功能码\n* 9C 4A：寄存器地址，从这里开始读数据\n* 00 04：读取数据个数，4个\n\n接收报文：Rx：04 44 00 00 00 0B 01 03 08 00 01 00 08 00 10 00 14\n\n* 04 44：事务标识符，可以解释为报文的序列号，由于我们测试使用的Modbus Poll客户端是一直发送数据，所以每发送一次数据标识符就加一。服务器接收时会把这个数据原封返回。\n* 00 00：Modbus TCP协议\n* 00 0B：后面有 11 字节长度的数据\n* 01：单元标识符，相当于设备的地址。01\n* 03：功能码\n* 08：返回的字节数（16进制），8个字节\n* 00 01：第一个数据，1\n* 00 08：第二个数据，8\n* 00 10：第三个数据，16\n* 00 14：第四个数据，20\n\n> MBAP（报文头）= 事务标识符 + 协议表示 + 长度 + 单元表示符\n>\n> PDU（帧结构）= 功能码 + 数据\n\n\n\n---\n\n补充，如果读的功能码为01，即读线圈。\n\n请求：00 01 00 00 00 06 01 01 00 02 00 04（客户端）\n\n* 00 01：事务标识符\n* 00 00：Modbus TCP协议\n* 00 06：后面有00 06个字节数据\n* 01：单元标识符\n* 01：功能码（读线圈）\n* 00 02：开始读的数据的地址。从00 02开始读数据。\n* 00 04：读00 04个数据。\n\n回应：00 01 00 00 00 04 01 01 01 0E（服务器）\n\n* 00 01：事务标识符\n* 00 00：Modbus TCP协议\n* 00 04：后面有00 04个字节数据\n* 01：单元标识符\n* 01：功能码\n* 01：后面有01个字节的数据\n* 0E：表示所读地址的线圈全是2的位置是0，其余是1。说明：线圈是只有00和01两种格式，所以图中从2的位置开始读到的4位数据是：1110（二进制），转化为十六进制就是0E。\n\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Uart","Modbus"],"categories":["通信协议"]},{"title":"Ymodem","url":"/2023/01/01/07. 通信协议/ymodem/","content":"\n\n\n# 1. 交互流程\n\n> 这里是以BootLoader为目的写的。\n>\n> 很多Shell工具都有自带的Xmodem、Ymodem传输文件的功能。这里以**SecureCRT 9.2**软件为例进行分析。不同的软件实际上可能有些许差异。\n\n\n\n![交互流程](./ymodem/交互流程.png)\n\n至此，流程结束。\n\n\n\n# 2. STM32示例\n\n这里已经将Ymodem协议接收部分已经封装好了。\n\n* 头文件\n\n~~~ c\n/*\n * ymodem.h\n *\n *  Created on: 2024年9月23日\n *      Author: ZhangJinhao\n */\n\n#ifndef PROTOCOL_YMODEM_H_\n#define PROTOCOL_YMODEM_H_\n\n#include \"stdint.h\"\n\n/* 此协议流程参考：SecureCRT 9.2, Ymodem协议，其他上位机未经过测试 */\n\n// 一包数据格式为：帧命令 + 索引 + 索引反码 + 数据(128/1024) + CRC16校验码\n// 帧命令\n#define YMODEM_SOH (0x01)    // 128字节数据命令\n#define YMODEM_STX (0x02)    // 1024字节数据命令\n#define YMODEM_EOT (0x04)    // 发送结束命令\n#define YMODEM_ACK (0x06)    // 接收正确应答命令\n#define YMODEM_NAK (0x15)    // 接收错误应答命令\n#define YMODEM_CA (0x18)     // 取消传输\n#define YMODEM_C (0x43)      // 开始发送命令\n#define YMODEM_ABORT1 (0x41) /* 'A' == 0x41, abort by user */\n#define YMODEM_ABORT2 (0x61) /* 'a' == 0x61, abort by user */\n// 长度定义\n#define YMODEM_PACKET_HEADER_LEN (3)                                                  // 包头长度(命令+索引+索引反码)\n#define YMODEM_PACKET_SIZE (128)                                                      // Ymodem包长度\n#define YMODEM_PACKET_1K_SIZE (1024)                                                  // Ymodem-1K包长度\n#define YMODEM_PACKET_TRAILER_LEN (2)                                                 // 包尾长度(CRC16)\n#define YMODEM_PACKET_OVERHEAD (YMODEM_PACKET_HEADER_LEN + YMODEM_PACKET_TRAILER_LEN) // 除去数据外，另外的长度\n\n// 一包数据中，索引和索引反码所处的位置\n#define YMODEM_PACKET_SEQNO_INDEX (1)\n#define YMODEM_PACKET_SEQNO_COMP_INDEX (2)\n\n// 文件信息帧中文件长度\n#define YMODEM_FILE_NAME_LENGTH (80) // 文件名长度\n#define YMODEM_FILE_SIZE_LENGTH (16) // 文件大小长度\n\n// 超时时间定义\n#define NAK_TIMEOUT (5000) // 5秒\n\ntypedef struct _ymodem\n{\n    uint8_t file_name[128];                                      // 需要接收的文件名\n    uint32_t file_size;                                          // 需要接收的文件大小（单位：字节）\n    uint8_t buf[YMODEM_PACKET_1K_SIZE + YMODEM_PACKET_OVERHEAD]; // 最大：帧命令 + 索引 + 索引反码 + 数据(128/1024) + CRC16校验码 = 1029字节\n    uint8_t pack_cnt;                                            // 下一包需要接收的索引号（0-FF之间循环）\n    uint8_t info_done;                                           // 收到文件信息\n    uint8_t file_done;                                           // 收到了文件数据\n    uint8_t null_done;                                           // 收到空文件信息\n\n    uint32_t app_addr;  // app程序的起始地址\n    uint32_t app_size;  // app程序占用空间大小\n    uint32_t flash_cnt; // 已经写入到flash的字节数\n} ymodem_t;\ntypedef ymodem_t *ymodem_ptr;\n\nint32_t ymodem_receive(void);\n\n#endif /* PROTOCOL_YMODEM_H_ */\n~~~\n\n* 源文件\n\n~~~ c\n#include \"ymodem.h\"\n#include \"stdlib.h\"\n\n#include \"iap.h\"\n#include \"usart.h\"\n\n// ============================================ 以下函数需要用户做适配 ============================================ //\nymodem_t ymodem =\n    {\n        .file_name = {0},\n        .file_size = 0,\n        .buf = {0},\n        .pack_cnt = 0,\n        .info_done = 0,\n        .file_done = 0,\n        .null_done = 0,\n\n        .app_addr = 0x08004000, // APP起始地址\n        .app_size = 0x3C000,    // APP空间大小\n        .flash_cnt = 0,\n};\n\n// 发送一个字符\nstatic uint8_t ymodem_send_byte(uint8_t byte)\n{\n    HAL_UART_Transmit(&huart1, &byte, 1, 0xFF);\n\n    return 0;\n}\n\n// 接收一个字符，成功返回0，失败返回1\nstatic uint8_t ymodem_recv_byte(uint8_t *data, uint32_t timeout)\n{\n    HAL_UART_Receive(&huart1, data, 1, timeout);\n    \n\treturn 0;\n}\n\n// ymodem写flash函数，将接收到的数据写到flash中\nstatic uint8_t ymodem_flash_write(uint32_t addr, uint8_t *data, uint32_t len)\n{\n\tstm32_flash_write(addr, data, len);\n    return 0;\n}\n\n// ymodem擦除app函数，擦除app区域flash\nstatic uint8_t ymodem_flash_erase(uint32_t addr, uint32_t len)\n{\n    stm32_flash_erase(addr, len);\n}\n    \n// 调试信息输出\nstatic uint8_t ymodem_printf(const char *format, ...)\n{\n    return 0;\n}\n\n// ============================================ 以上函数需要用户做适配 ============================================ //\n\n// CRC校验函数\nstatic uint16_t CRC16_Xmodem(uint8_t *data, uint32_t len)\n{\n    uint8_t i;\n    uint16_t crc = 0x0000;\n\n    while (len--)\n    {\n        crc ^= (*data++ << 8);\n\n        for (i = 0; i < 8; i++)\n        {\n            if (crc & 0x8000)\n                crc = (crc << 1) ^ 0x1021;\n            else\n                crc = crc << 1;\n        }\n    }\n    return crc;\n}\n\n// ymodem 接收一个包的数据\n// return:\n//     -1: 接收失败（未收到 或 超时 或 错误命令 或 校验失败）\n//      0：正常成功（收到完整数据length=128/1024 或 收到结束帧length=0 或 发送方要求停止length=-1）\n//      1：主机要求取消传输\nstatic int8_t ymodem_recv_packet(uint8_t *data, uint32_t *length, uint32_t timeout)\n{\n    uint16_t i, packet_size, crc;\n    uint8_t c;\n    *length = 0;\n\n    // 接收第一个字符\n    if (ymodem_recv_byte(&c, timeout) != 0)\n    {\n        return -1;\n    }\n    // 判断命令类型\n    switch (c)\n    {\n    case YMODEM_SOH:\n        packet_size = YMODEM_PACKET_SIZE; // 128byte\n        break;\n    case YMODEM_STX:\n        packet_size = YMODEM_PACKET_1K_SIZE; // 1024byte\n        break;\n    case YMODEM_EOT:\n        return 0;\n    case YMODEM_CA:\n        if ((ymodem_recv_byte(&c, timeout) == 0) && (c == YMODEM_CA))\n        {\n            *length = -1;\n            return 0;\n        }\n        else\n        {\n            return -1;\n        }\n    case YMODEM_ABORT1:\n    case YMODEM_ABORT2:\n        return 1;\n    default:\n        return -1;\n    }\n\n    // 如果命令正确，继续接收够一包数据\n    // 第一个字节\n    *data = c;\n    // 剩下的字节\n    for (i = 1; i < (packet_size + YMODEM_PACKET_OVERHEAD); i++)\n    {\n        if (ymodem_recv_byte(data + i, timeout) != 0)\n        {\n            return -1;\n        }\n    }\n    // 校验索引和索引反码是否配对\n    if (data[YMODEM_PACKET_SEQNO_INDEX] != ((data[YMODEM_PACKET_SEQNO_COMP_INDEX] ^ 0xff) & 0xff))\n    {\n        return -1;\n    }\n\n    // 校验CRC校验码是否正确(仅计算数据区域)\n    crc = CRC16_Xmodem(&data[YMODEM_PACKET_HEADER_LEN], packet_size);\n    if (((crc >> 8) != data[YMODEM_PACKET_HEADER_LEN + packet_size]) || ((crc & 0x00FF) != data[YMODEM_PACKET_HEADER_LEN + packet_size + 1]))\n    {\n        return -1;\n    }\n\n    // 记录本包中有效数据长度\n    *length = packet_size;\n\n    return 0;\n}\n\n// 阻塞式接收，一直到接收完成后返回。\n// return:\n//      1: 发送方要求停止\n//      0: 接收成功\nint32_t ymodem_receive(void)\n{\n    uint32_t packet_length = 0;\n\n    // 擦除flash\n    ymodem_flash_erase(ymodem.app_addr, ymodem.app_size);\n\n    // 发送字符C,开始接收\n    ymodem_send_byte(YMODEM_C);\n\n    while (1)\n    {\n        // 先清空缓冲区，重新收\n        memset(ymodem.buf, 0, YMODEM_PACKET_1K_SIZE + YMODEM_PACKET_OVERHEAD);\n\n        // 接收一包数据\n        switch (ymodem_recv_packet(ymodem.buf, &packet_length, NAK_TIMEOUT))\n        {\n        // 成功接收到一包数据\n        case 0:\n            // 根据收到的数据长度判断收到的是什么命令\n            switch (packet_length)\n            {\n            // 发送方要求停止\n            case -1:\n                ymodem_send_byte(YMODEM_ACK);\n                return 1;\n            // 收到文件结束帧\n            case 0:\n                ymodem_send_byte(YMODEM_ACK);\n                ymodem_send_byte(YMODEM_C);\n                ymodem.file_done = 1;\n                ymodem.pack_cnt = 0;\n                break;\n            // 收到了正常的一包数据\n            default:\n                // 判断索引是否正确\n                if (ymodem.buf[YMODEM_PACKET_SEQNO_INDEX] != ymodem.pack_cnt)\n                {\n                \tymodem_printf(\"index err, need_cnt=%x, real_cnt=%x \\r\\n\", ymodem.pack_cnt, ymodem.buf[YMODEM_PACKET_SEQNO_INDEX]);\n\n                    // 索引不对，发送错误应答，重新接收本包数据\n                    ymodem_send_byte(YMODEM_NAK);\n                }\n                else\n                {\n                    // 索引正确\n                    // 第一包数据 和 文件数据结束之后的第一包数据 是文件信息\n                    if ((ymodem.info_done == 0) || (ymodem.file_done == 1))\n                    {\n                        // 非空文件名，是第一包数据\n                        if (ymodem.buf[YMODEM_PACKET_HEADER_LEN] != 0x00)\n                        {\n                            // 解析文件名：\n                            uint8_t file_name_len = 0;\n                            for (uint8_t i = YMODEM_PACKET_HEADER_LEN; i < YMODEM_FILE_NAME_LENGTH; i++)\n                            {\n                                if (ymodem.buf[i] == 0x00)\n                                {\n                                    file_name_len = i - 3;\n                                    memcpy(ymodem.file_name, &(ymodem.buf[3]), file_name_len);\n                                    ymodem.file_name[file_name_len] = '\\0';\n                                    ymodem_printf(\"file name = %s \\r\\n\", ymodem.file_name);\n                                    break;\n                                }\n                            }\n                            // 解析文件字节数：\n                            for (uint8_t i = YMODEM_PACKET_HEADER_LEN + file_name_len + 1; i < YMODEM_PACKET_HEADER_LEN + file_name_len + 1 + YMODEM_FILE_SIZE_LENGTH; i++)\n                            {\n                                // 遇到分隔符、非法字符\n                                if ((ymodem.buf[i] == 0x20) || (ymodem.buf[i] < '0') || (ymodem.buf[i] > '9'))\n                                {\n                                    // 打印一下信息\n                                    ymodem_printf(\"file size = %d byte.\\r\\n\", ymodem.file_size);\n                                    break;\n                                }\n                                else\n                                {\n                                    ymodem.file_size = ymodem.file_size * 10 + (ymodem.buf[i] - '0');\n                                }\n                            }\n\n                            // 解析成功\n                            ymodem.info_done = 1;\n                            ymodem.pack_cnt = 1;\n                            // 发送应答开始接收数据\n                            ymodem_send_byte(YMODEM_ACK);\n                            ymodem_send_byte(YMODEM_C);\n                        }\n                        // 空文件名是最后一帧数据\n                        else\n                        {\n                            ymodem_send_byte(YMODEM_ACK);\n                            // TODO:延时半秒\n                            ymodem_send_byte(YMODEM_ACK);\n\n                            ymodem.null_done = 1;\n                            break;\n                        }\n                    }\n                    // 文件数据\n                    else\n                    {\n                        // 将数据写入到flash\n                        ymodem_flash_write(ymodem.app_addr + ymodem.flash_cnt, &(ymodem.buf[YMODEM_PACKET_HEADER_LEN]), packet_length);\n\n                        // 记录已经写入到flash中的字节数\n                        ymodem.flash_cnt = ymodem.flash_cnt + packet_length;\n\n                        // 记录下一包应该收到的索引\n                        if (ymodem.pack_cnt == 0xFF)\n                        {\n                            ymodem.pack_cnt = 0;\n                        }\n                        else\n                        {\n                            ymodem.pack_cnt++;\n                        }\n\n                        // 发送应答，接收下一帧数据\n                        ymodem_send_byte(YMODEM_ACK);\n                    }\n                }\n            }\n            break;\n        // 主机要求取消传输\n        case 1:\n            ymodem_send_byte(YMODEM_CA);\n            ymodem_send_byte(YMODEM_CA);\n            return 1;\n        // 接收失败（校验失败、接收超时、命令不对）\n        default:\n            // 如果是在等待文件信息\n            if (ymodem.info_done == 0)\n            {\n                // 重新发送C\n                ymodem_send_byte(YMODEM_C);\n            }\n            // 如果是接收数据过程出错\n            if ((ymodem.info_done == 1) && (ymodem.file_done == 0))\n            {\n                // 发送错误应答，重新接收数据\n                ymodem_send_byte(YMODEM_NAK);\n            }\n            // 如果是等待空文件信息出错\n            if (ymodem.file_done == 1)\n            {\n                // 重新发送C\n                ymodem_send_byte(YMODEM_C);\n            }\n            break;\n        }\n\n        // 判断接收流程是否全部结束\n        if (ymodem.null_done == 1)\n        {\n        \tymodem_printf(\"recv over, need size=%d, real size=%d \\r\\n\", ymodem.file_size, ymodem.flash_cnt);\n            return 0;\n        }\n    }\n}\n~~~\n\n其中：\n\n1. 头文件可以完全不用动；\n2. 源文件用户适配部分需要根据不同的单片机和接口进行修改。\n\n\n\n* 使用案例\n\n~~~ c\nvoid main()\n{\n    // init\n    \n    while(1)\n    {\n        // 如果需要进行OTA\n        if(need_updata)\n        {\n\t\t\t// 接收app程序\n            ymodem_receive();\n            \n            // 跳转到app区域\n            jump_to_app();\n        }\n    }\n}\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Uart","Ymodem"],"categories":["通信协议"]},{"title":"rtthread_nano移植","url":"/2020/10/01/03. RTOS/rtthread_nano/","content":"\n\n\n使用的开发板：RTT&正点原子的潘多拉loT Board开发板。主控：STM32L475VET6\n\n软件：CubeMX 6.7.0、Keil 5.38、Nano 3.1.5\n\n# 第一部分：工程版本及移植\n\n移植的方式有好多种（任选一种）\n\n1. 基于 Keil MDK 的移植；（最常用的工具）\n2. 基于 CubeMX 的移植；（最常用的工具）\n3. 基于官方软件 RT-Thread Studio；（自动创建工程，比较方便）\n\n\n\n# 1. 使用 Keil MDK 移植\n\n一共需要两步：\n\n1. 创建一份裸机代码；\n2. 在 Keil 软件中安装 RT-Thread Nano Pack；\n3. 在源工程中添加 RT-Thread Nano 源代码；\n4. 适配工作，主要从 中断、时钟、内存这几个方面进行适配，实现移植；\n5. 添加LED闪烁例程进行验证；\n6. 裁剪内核，通过配置文件 rtconfig.h 实现对系统的裁剪。\n\n> 裸机代码获取：\n>\n> 1. 这里可以直接使用 CubeMX 生成一份，配置上时钟、调试接口、LED的IO口之后，直接点击生成即可。下面的案例就是使用这种方式生成的。\n>\n> 2. 也可以按照正点原子的教程，从固件包里面新建一个。\n>\n>       这两种方法在工程目录上有一点点差距，内容差不多，移植的时候找到对应的地方就可以了。\n\n## 1.1 Nano Pack 安装\n\nRT-Thread Master 的源码可以从https://github.com/RT-Thread/rt-thread下载。\n\nNano就是从里面扣出来的，去掉了一些组件和各种开发板的BSP，保留了OS的核心功能，但足够我们使用。\n\n### 方式一：手动下载安装\n\nRT-Thread 官方将抠出来的 Nano 作为一个Package放在了KEIL网站：http://www.keil.com/dd2/pack/，打开这条连接，然后拉到下面找到RealThread即可下载。\n\n![1.1.1](./rtthread_nano/1.1.jpg)\n\n下载完成之后，直接双击安装即可，路径会自动选择Keil的安装路径。\n\n安装完成之后，在：<u>E:\\Keil5 MDK\\PACK\\RealThread\\RT-Thread\\3.1.5</u> 路径(Keil的安装路径)下，即可看到下载的源码。\n\n### 方式二：在Keil中安装\n\n1. 打开Keil，点击包安装图标，点击右侧的 Pack，展开 Generic，可以找到 RealThread::RT-Thread；\n2. 点击 Action 栏对应的 Install ，就可以在线安装 Nano Pack 了。\n3. 另外，如果需要安装其他版本，则需要展开 RealThread::RT-Thread，进行选择。\n4. 图中 Remove 代表已经安装了。\n\n![1.1.2](./rtthread_nano/1.2.jpg)\n\n\n\n## 1.2 Nano 版本移植\n\n在 Manage Rum-Time Environment 里 \"Software Component\" 栏找到 RTOS，Variant 栏选择 RT-Thread，然后勾选 kernel，点击 \"OK\" 就添加 RT-Thread 内核到工程了。\n\n然后在左侧工程栏就可以看到相关代码了。\n\n![1.1.3](./rtthread_nano/1.3.jpg)\n\n其中的文件包含：\n\n**Cortex-M 芯片内核移植代码**\n\n~~~ markdown\ncontext_rvds.s\ncpuport.c\n~~~\n\n**Kernel 文件**\n\n~~~ markdown\nclock.c\ncomponents.c\ndevice.c\nidle.c\nipc.c\nirq.c\nkservice.c\nmem.c\nmempool.c\nobject.c\nscheduler.c\nthread.c\ntimer.c\n~~~\n\n**配置文件**\n\n~~~ markdown\nboard.c\nrtconfig.h\n~~~\n\n\n\n> 如果不想使用CMSIS添加源码，也可以直接把下载的源码复制到工程中，对照着上面的文件名添加进去即可。注意可能同一个文件所处的位置略微有些差异，其余的部分都是一样的。\n>\n> 在工程文件夹的 Middlewares 文件夹中创建一个 RT-Thread 文件夹。\n>\n> * Middlewares/RT-Thread\n>   * bsp\n>     * _template\n>       * board.c\n>       * rtconfig.h\n>   * components\n>     * device（都要保留，后续可能用到）\n>       * device.c\n>     * finsh（都要保留，第四章用到）\n>       * 文件都保留\n>   * include（都要保留）\n>   * libcpu\n>     * arm\n>       * cortex-m4\n>         * context_rvds.S\n>         * cpuport.c\n>   * src（都要保留）\n>\n> 剩下的没提到的都删掉。\n>\n> 然后在 Keil MDK 内添加文件和头文件即可。后续学习内核的时候，这里用的就是这种方式移植的内核（因为与RTT无关的冗余文件少）。\n\n\n\n## 1.3 适配工作\n\n### 1.3.1 中断与异常处理\n\n> RT-Thread 会接管异常处理函数 `HardFault_Handler()` 和悬挂处理函数 `PendSV_Handler()`，这两个函数已由 RT-Thread 实现，所以需要删除工程里中断服务例程文件中的这两个函数，避免在编译时产生重复定义。如果此时对工程进行编译，没有出现函数重复定义的错误，则不用做修改。\n\n在`stm32l4xx_it.c`文件中找到上述两个函数，直接注释掉即可（也可以在使用CubeMX生成代码的时候，直接不生成这部分中断代码）。\n\n\n\n### 1.3.2 系统时钟配置\n\n> 在 board.c 中实现 `系统时钟配置`（为 MCU、外设提供工作时钟）与 `os tick ` 的配置 （为操作系统提供心跳 / 节拍）。\n\n在`board.c`文件中修改如下函数，以完成系统初始化和 OS Tick 的配置。\n\n~~~ c\n#include \"main.h\"\nextern void SystemClock_Config(void); // 此函数默认是在main.c中，此处声明一下\n\n/* cortex-m 架构使用 SysTick_Handler() */\nvoid SysTick_Handler()\n{\n  rt_interrupt_enter(); /* 进入中断时必须调用 */\n\n  rt_tick_increase();  /* RT-Thread 系统时钟计数 */\n\n  rt_interrupt_leave(); /* 退出中断时必须调用 */\n}\n\n/**\n * This function will initial your board.\n */\nvoid rt_hw_board_init(void)\n{\n    /* \n     * TODO 1: OS Tick Configuration\n     * Enable the hardware timer and call the rt_os_tick_callback function\n     * periodically with the frequency RT_TICK_PER_SECOND. \n     */\n\n\t  /* 1、系统、时钟初始化 */\n\t  HAL_Init(); // 初始化 HAL 库\n\t  SystemClock_Config(); // 配置系统时钟\n\t  SystemCoreClockUpdate(); // 对系统时钟进行更新\n\t\n\t  /* 2、OS Tick 频率配置，RT_TICK_PER_SECOND = 1000 表示 1ms 触发一次中断 */\n\t  SysTick_Config(SystemCoreClock / RT_TICK_PER_SECOND);\n\t\n\t\n    /* Call components board initial (use INIT_BOARD_EXPORT()) */\n#ifdef RT_USING_COMPONENTS_INIT\n    rt_components_board_init();\n#endif\n\n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)\n    rt_system_heap_init(rt_heap_begin_get(), rt_heap_end_get());\n#endif\n}\n~~~\n\n另外，`SysTick_Handler()`函数在裸机工程中应该也有，也需要去`stm32l4xx_it.c`文件中注释掉。\n\n\n\n### 1.3.3 内存堆初始化\n\n> 系统内存堆的初始化在 board.c 中的 rt_hw_board_init() 函数中完成\n>\n> 内存堆功能是否使用取决于宏 RT_USING_HEAP 是否开启（位于`rtconfig.h`中）\n>\n> 开启系统 heap 将可以使用动态内存功能，如使用 rt_malloc、rt_free 以及各种系统动态创建对象的 API。\n>\n> 若需要使用系统内存堆功能，则打开 RT_USING_HEAP 宏定义即可，此时内存堆初始化函数 rt_system_heap_init() 将被调用。\n\n如果需要使用动态创建线程等对象，则需要配置。\n\n## 1.4 LED闪烁\n\n在`main.c`中添加如下代码（注意：LED引脚初始化的代码在源代码中已经配置过了）\n\n~~~c\n#include <rtthread.h>\t// 线程相关\n\nint main(void)\n{\n  MX_GPIO_Init();\n\n  while (1)\n  {\n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_RESET);\n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_RESET);\n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_9, GPIO_PIN_RESET);\n\t  rt_thread_mdelay(500);\n\t  \n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_SET);\n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_SET);\n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_9, GPIO_PIN_SET);\n\t  rt_thread_mdelay(500);\n  }\n}\n~~~\n\n注意\n\n1. 这里使用的延时函数是由RTT提供的，此函数引起系统调度，切换到其他线程运行。\n2. 这里的main函数中不再执行初始化动作，RTT系统启动时已经做好了。\n\n至此，将工程编译并下载，即可看到LED闪烁了。\n\n\n\n## 1.5 裁剪内核\n\n如果对内核的部分功能用不着，可以对其进行裁剪。\n\n裁剪是通过`rtconfig.h`文件进行配置的。具体参照[内核裁剪](#5. 内核配置及裁剪)\n\n先保持默认的，能用就行，后面分析阶段再说。\n\n\n\n# 2. 使用 CubeMX 移植\n\n其实和使用 Keil MDK 移植的步骤基本一样，只是添加源代码的过程不一样。\n\n1. 在 CubeMX 软件中安装 RT-Thread Nano pack 安装包；\n2. 在 CubeMX 配置界面添加 RT-Thread Nano 源码，然后生成工程；\n3. 适配工作，主要从 中断、时钟、内存这几个方面进行适配，实现移植；\n4. 添加LED闪烁例程进行验证；\n5. 裁剪，通过配置文件 rtconfig.h 实现对系统的裁剪。\n\n## 2.1 Nano Pack 安装\n\n1. 在 CubeMX 中选择完芯片后，点击 Software Packs -> Manage Software Packs；\n2. 在弹出的界面下方，点击 From Url 后，弹出新的界面；\n3. 在弹出的界面下方。点击 New；\n4. 在弹出的输入框中输入：https://www.rt-thread.org/download/cube/RealThread.RT-Thread.pdsc\n5. 然后点击 Check，等待检查通过后安装即可。\n\n![1.2.1](./rtthread_nano/2.1.jpg)\n\n\n\n## 2.2 Nano 版本移植\n\n点击 `Softwares Packages`->`Select Components`，进入组件配置界面，选择 `RealThread`， 然后根据需求选择 RT-Thread 组件，然后点击 OK 按钮。\n\n![1.2.2](./rtthread_nano/2.2.png)\n\n然后在左侧栏对组件和参数进行配置。\n\n![1.2.3](./rtthread_nano/2.3.jpg)\n\n> RT-Thread Nano 软件包中包含 kernel, shell 和 device 三个部分，仅选择 kernel 表示只使用 RT-Thread 内核，工程中会添加内核代码；选择 kernel 与 shell 表示在使用 RT-Thread Nano 的基础上使用 FinSH Shell 组件，工程中会添加内核代码与 FinSH 组件的代码，FinSH 的移植详见 [《在 RT-Thread Nano 上添加控制台与 FinSH》](https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-nano/finsh-port/an0045-finsh-port)。再选择 device 表示使用 rt-thread 的 device 框架，用户基于此框架编写外设驱动并注册后，就可以使用 device 统一接口操作外设。\n\n剩下的按照需要的功能进行配置即可（记得把串口加上，否则后面`board.c`中的串口初始化会报错，如果用不到串口可以不用配置，把其中串口初始化报错的部分注释掉就行，后面还会有用）。\n\n\n\n## 2.3 适配工作\n\n### 2.3.1 中断与异常处理\n\nRT-Thread 操作系统重定义 `HardFault_Handler`、`PendSV_Handler`、`SysTick_Handler` 中断函数，为了避免重复定义的问题，在生成工程之前，需要在中断配置中，代码生成的选项中，取消选择三个中断函数（对应注释选项是 `Hard fault interrupt`, `Pendable request`, `Time base :System tick timer`），最后点击生成代码，具体操作如下图 所示：\n\n![1.2.4](./rtthread_nano/2.4.jpg)\n\n> 和使用 Keil MDK 不同的是，这里直接不让生成就好了，而不是生成了重新注释。\n>\n> 当然，使用 Keil MDK 创建源工程的时候，也可以不生成，就不用再注释了。\n\n### 2.3.2 系统时钟配置\n\n使用 CubeMX的话，生成的代码其实已经配置好了。\n\n可以对比 1.3.2 小节的代码看一看。\n\n\n\n### 2.3.3 内存堆初始化\n\n同 1.3.3 小节。\n\n> 这里注意，生成的工程目录中有个：RT-Thread 文件夹。里面只有一个`rtconfig.h`文件。\n>\n> 但是生成的工程中，没有包含这个文件夹，所以会发现根本找不到配置文件。\n>\n> 因此需要在工程中对其进行添加，并添加头文件路径（如果有就算了），如下图所示。\n\n![1.2.5](./rtthread_nano/2.5.jpg)\n\n\n\n## 2.4 LED闪烁\n\n在`main.c`文件的while中添加如下代码（注意：LED引脚初始化的代码在源代码中已经配置过了）\n\n~~~c\nwhile (1)\n{\n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_RESET);\n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_RESET);\n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_9, GPIO_PIN_RESET);\n\t  rt_thread_mdelay(500);\n\t  \n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_SET);\n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_SET);\n\t  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_9, GPIO_PIN_SET);\n\t  rt_thread_mdelay(500);\n}\n~~~\n\n> main函数中的`HAL_Init()`、`SystemClock_Config();`在我们配置系统时钟（2.3.2小节）时已经初始化过了，因此在main函数中其实不用初始化了，可以选择注释掉，但是每次生成工程都还要重新注释。\n\n注意\n\n1. 这里使用的延时函数是由RTT提供的，此函数引起系统调度，切换到其他线程运行。\n2. 这里的main函数中不再执行初始化动作，RTT系统启动时已经做好了。\n\n至此，将工程编译并下载，即可看到LED闪烁了。\n\n\n\n## 2.5 裁剪内核\n\n如果对内核的部分功能用不着，可以对其进行裁剪。\n\n裁剪是通过`rtconfig.h`文件进行配置的。具体参照[内核裁剪](#5. 内核配置及裁剪)\n\n先保持默认的，能用就行，后面分析阶段再说。\n\n\n\n# 3. 使用 RT-Thread Studio 创建\n\n直接创建 nano 工程即可。\n\n\n\n\n\n\n\n# 4. 移植 FinSH\n\n这里移植 FinSH 主要有两种目的。\n\n1. 基础功能：实现打印，用来向控制台对接的终端输出打印信息。\n2. 移植 FinSH 组件：命令输入，用以在控制台输入命令调试系统。\n\n如果只需要第一个功能，则只需要实现两个函数，串口初始化和系统输出函数，即可完成 UART 控制台打印功能。\n\n如果还需要第二个功能，则在上述基础上还需要添加 FinSH 组件源码，并再对接一个系统输入函数即可实现。\n\n ## 4.1 打印功能\n\n如果使用的是 CubeMX 移植的代码，其实已经在`board.c`中默认配置好了（2.2小节的最后一段话有提到），如下图所示。\n\n![4.1](./rtthread_nano/4.1.jpg)\n\n> 只需要确认这里使用的串口是不是自己实际对应的串口即可。\n\n而如果使用的是 Keil 配置的 Nano，则如下图所示给预留了位置。\n\n![4.1](./rtthread_nano/4.2.jpg)\n\n把上面的抄过来就好了\n\n~~~ c\n#ifdef RT_USING_CONSOLE\n\nstatic UART_HandleTypeDef UartHandle;\nstatic int uart_init(void)\n{\n    /* TODO: Please modify the UART port number according to your needs */\n    UartHandle.Instance = USART1;\n    UartHandle.Init.BaudRate = 115200;\n    UartHandle.Init.WordLength = UART_WORDLENGTH_8B;\n    UartHandle.Init.StopBits = UART_STOPBITS_1;\n    UartHandle.Init.Parity = UART_PARITY_NONE;\n    UartHandle.Init.Mode = UART_MODE_TX_RX;\n    UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;\n    UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;\n\n    if (HAL_UART_Init(&UartHandle) != HAL_OK)\n    {\n        while (1);\n    }\n    return 0;\n}\nINIT_BOARD_EXPORT(uart_init);\n\nvoid rt_hw_console_output(const char *str)\n{\n    rt_size_t i = 0, size = 0;\n    char a = '\\r';\n\n    __HAL_UNLOCK(&UartHandle);\n\n    size = rt_strlen(str);\n\n    for (i = 0; i < size; i++)\n    {\n        if (*(str + i) == '\\n')\n        {\n            HAL_UART_Transmit(&UartHandle, (uint8_t *)&a, 1, 1);\n        }\n        HAL_UART_Transmit(&UartHandle, (uint8_t *)(str + i), 1, 1);\n    }\n}\n#endif\n~~~\n\n> 初始化函数`uart_init()`的执行，是利用的`INIT_BOARD_EXPORT(uart_init);`语句。\n>\n> 可以查看官网对自动初始化机制的介绍。\n\n\n\n然后，在main函数中添加使用到打印函数`rt_kprintf()`的语句。\n\n~~~ c\n// 这里放到了 mian 函数中的 while 之前\nrt_uint32_t count = 0;\nfor (count = 0; count < 10 ; count++)\n{\n    rt_kprintf(\"count: %d\\n\", count);\n    rt_thread_mdelay(500);\n}\n~~~\n\n编译并下载至开发板，打开串口调试工具并复位开发板，即可看到串口输出。\n\n\n\n## 4.2 移植 FinSH 组件\n\n如果需要移植 FinSH 组件，在完成打印功能之后，还需要：\n\n1. 在工程中添加 FinSH 源码。\n2. 实现函数对接。\n\n添加 FinSH 源码的方式和 添加 Nano 的方式一样，只需要把 shell 也勾选上即可。\n\n如果使用 CubeMX 添加 FinSH 源码，重新生成工程后，会在工程目录多出如下几个文件。\n\n![4.3](./rtthread_nano/4.3.jpg)\n\n然后，在`rtconfig.h`中打开**#include \"finsh_config.h\"**。\n\n> 注意：在`finsh_port.c`文件中，#error Please uncomment the line <#include \"finsh_config.h\"> in the rtconfig.h  这一行需要注释掉。\n\n而在`board.c`中可以看到，相关函数已经默认写好了。\n\n![4.4](./rtthread_nano/4.4.jpg)\n\n**但是，这里的 DR 会报错，因为有些芯片这个寄存器的名字为DR，有的为RDR。这里将 DR 改为 RDR 即可。**\n\n而如果使用的是 Keil MDK 添加的源码。则会在工程目录多出几个文件。\n\n同样的，添加之后，需要在`rtconfig.h`文件中打开**#include \"finsh_config.h\"**。\n\n然后`finsh_port.c`文件中可以看到上面的接口，也是一样的，用这种方式的话，把上面的抄过来就好了。\n\n\n\n这个是 RT-Thread 官网给的示例，直接抄上面的也行\n\n~~~ c\n#ifdef RT_USING_FINSH\nchar rt_hw_console_getchar(void)\n{\n    int ch = -1;\n\n    if (__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_RXNE) != RESET)\n    {\n        ch = UartHandle.Instance->RDR & 0xff;\n    }\n    else\n    {\n        if(__HAL_UART_GET_FLAG(&UartHandle, UART_FLAG_ORE) != RESET)\n        {\n            __HAL_UART_CLEAR_OREFLAG(&UartHandle);\n        }\n        rt_thread_mdelay(10);\n    }\n    return ch;\n}\n#endif\n~~~\n\n可以发现，其实两种方法做的事情是一样的，最后除了`rt_hw_console_getchar`函数的位置不同，其他的基本都一样。\n\n然后就可以测试了。使用串口助手。\n\n1. 不勾选发送新行，输入h，点击发送\n2. 不勾选发送新行，输入e，点击发送\n3. 不勾选发送新行，输入l，点击发送\n4. 不勾选发送新行，输入p，点击发送\n5. 什么也不输，勾选发送新行，点击发送。 \n\n\n\n![4.5](./rtthread_nano/4.5.jpg)\n\n显然，这种查询的方式很沙雕。\n\n## 4.3 更改中断方式\n\n这种查询的方式显然很不对，因此进一步将其更改为中断方式。\n\n官网有所有需要添加的代码，按照自己的习惯放到某个位置就好。\n\n~~~ c\n/* 第一部分：ringbuffer 实现部分 */\n#include <rtthread.h>\n#include <string.h>\n\n#define rt_ringbuffer_space_len(rb) ((rb)->buffer_size - rt_ringbuffer_data_len(rb))\n\nstruct rt_ringbuffer\n{\n    rt_uint8_t *buffer_ptr;\n\n    rt_uint16_t read_mirror : 1;\n    rt_uint16_t read_index : 15;\n    rt_uint16_t write_mirror : 1;\n    rt_uint16_t write_index : 15;\n\n    rt_int16_t buffer_size;\n};\n\nenum rt_ringbuffer_state\n{\n    RT_RINGBUFFER_EMPTY,\n    RT_RINGBUFFER_FULL,\n    /* half full is neither full nor empty */\n    RT_RINGBUFFER_HALFFULL,\n};\n\nrt_inline enum rt_ringbuffer_state rt_ringbuffer_status(struct rt_ringbuffer *rb)\n{\n    if (rb->read_index == rb->write_index)\n    {\n        if (rb->read_mirror == rb->write_mirror)\n            return RT_RINGBUFFER_EMPTY;\n        else\n            return RT_RINGBUFFER_FULL;\n    }\n    return RT_RINGBUFFER_HALFFULL;\n}\n\n/**\n * get the size of data in rb\n */\nrt_size_t rt_ringbuffer_data_len(struct rt_ringbuffer *rb)\n{\n    switch (rt_ringbuffer_status(rb))\n    {\n    case RT_RINGBUFFER_EMPTY:\n        return 0;\n    case RT_RINGBUFFER_FULL:\n        return rb->buffer_size;\n    case RT_RINGBUFFER_HALFFULL:\n    default:\n        if (rb->write_index > rb->read_index)\n            return rb->write_index - rb->read_index;\n        else\n            return rb->buffer_size - (rb->read_index - rb->write_index);\n    };\n}\n\nvoid rt_ringbuffer_init(struct rt_ringbuffer *rb,\n                        rt_uint8_t           *pool,\n                        rt_int16_t            size)\n{\n    RT_ASSERT(rb != RT_NULL);\n    RT_ASSERT(size > 0);\n\n    /* initialize read and write index */\n    rb->read_mirror = rb->read_index = 0;\n    rb->write_mirror = rb->write_index = 0;\n\n    /* set buffer pool and size */\n    rb->buffer_ptr = pool;\n    rb->buffer_size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);\n}\n\n/**\n * put a character into ring buffer\n */\nrt_size_t rt_ringbuffer_putchar(struct rt_ringbuffer *rb, const rt_uint8_t ch)\n{\n    RT_ASSERT(rb != RT_NULL);\n\n    /* whether has enough space */\n    if (!rt_ringbuffer_space_len(rb))\n        return 0;\n\n    rb->buffer_ptr[rb->write_index] = ch;\n\n    /* flip mirror */\n    if (rb->write_index == rb->buffer_size-1)\n    {\n        rb->write_mirror = ~rb->write_mirror;\n        rb->write_index = 0;\n    }\n    else\n    {\n        rb->write_index++;\n    }\n\n    return 1;\n}\n/**\n * get a character from a ringbuffer\n */\nrt_size_t rt_ringbuffer_getchar(struct rt_ringbuffer *rb, rt_uint8_t *ch)\n{\n    RT_ASSERT(rb != RT_NULL);\n\n    /* ringbuffer is empty */\n    if (!rt_ringbuffer_data_len(rb))\n        return 0;\n\n    /* put character */\n    *ch = rb->buffer_ptr[rb->read_index];\n\n    if (rb->read_index == rb->buffer_size-1)\n    {\n        rb->read_mirror = ~rb->read_mirror;\n        rb->read_index = 0;\n    }\n    else\n    {\n        rb->read_index++;\n    }\n\n    return 1;\n}\n\n\n/* 第二部分：finsh 移植对接部分 */\n#define UART_RX_BUF_LEN 16\nrt_uint8_t uart_rx_buf[UART_RX_BUF_LEN] = {0};\nstruct rt_ringbuffer  uart_rxcb;         /* 定义一个 ringbuffer cb */\nstatic UART_HandleTypeDef UartHandle;\nstatic struct rt_semaphore shell_rx_sem; /* 定义一个静态信号量 */\n\n/* 初始化串口，中断方式 */\nstatic int uart_init(void)\n{\n    /* 初始化串口接收 ringbuffer  */\n    rt_ringbuffer_init(&uart_rxcb, uart_rx_buf, UART_RX_BUF_LEN);\n\n    /* 初始化串口接收数据的信号量 */\n    rt_sem_init(&(shell_rx_sem), \"shell_rx\", 0, 0);\n\n    /* 初始化串口参数，如波特率、停止位等等（cubemx生成的） */\n    UartHandle.Instance = USART1;\n    UartHandle.Init.BaudRate   = 115200;\n    UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;\n    UartHandle.Init.Mode       = UART_MODE_TX_RX;\n    UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;\n    UartHandle.Init.WordLength = UART_WORDLENGTH_8B;\n    UartHandle.Init.StopBits   = UART_STOPBITS_1;\n    UartHandle.Init.Parity     = UART_PARITY_NONE;\n\n    /* 初始化串口引脚等 */\n    if (HAL_UART_Init(&UartHandle) != HAL_OK)\n    {\n        while (1);\n    }\n\n    /* 中断配置 */\n\tHAL_NVIC_SetPriority(USART1_IRQn, 1, 1);\t\t\t// 设置优先级\n\tHAL_NVIC_EnableIRQ(USART1_IRQn);\t\t\t\t\t// 开启中断\n\t__HAL_UART_ENABLE_IT(&UartHandle, UART_IT_RXNE);\t// 使能中断\n\n    return 0;\n}\nINIT_BOARD_EXPORT(uart_init);\n\n/* 移植控制台，实现控制台输出, 对接 rt_hw_console_output */\nvoid rt_hw_console_output(const char *str)\n{\n    rt_size_t i = 0, size = 0;\n    char a = '\\r';\n\n    __HAL_UNLOCK(&UartHandle);\n\n    size = rt_strlen(str);\n    for (i = 0; i < size; i++)\n    {\n        if (*(str + i) == '\\n')\n        {\n            HAL_UART_Transmit(&UartHandle, (uint8_t *)&a, 1, 1);\n        }\n        HAL_UART_Transmit(&UartHandle, (uint8_t *)(str + i), 1, 1);\n    }\n}\n\n/* 移植 FinSH，实现命令行交互, 需要添加 FinSH 源码，然后再对接 rt_hw_console_getchar */\n/* 中断方式 */\nchar rt_hw_console_getchar(void)\n{\n    char ch = 0;\n\n    /* 从 ringbuffer 中拿出数据 */\n    while (rt_ringbuffer_getchar(&uart_rxcb, (rt_uint8_t *)&ch) != 1)\n    {\n        rt_sem_take(&shell_rx_sem, RT_WAITING_FOREVER);\n    }\n    return ch;\n}\n\n/* uart 中断 */\nvoid USART1_IRQHandler(void)\n{\n    int ch = -1;\n    /* enter interrupt */\n    rt_interrupt_enter();          // 在中断中一定要调用这对函数，进入中断\n\n    if ((__HAL_UART_GET_FLAG(&(UartHandle), UART_FLAG_RXNE) != RESET) &&\n        (__HAL_UART_GET_IT_SOURCE(&(UartHandle), UART_IT_RXNE) != RESET))\n    {\n        while (1)\n        {\n            ch = -1;\n            if (__HAL_UART_GET_FLAG(&(UartHandle), UART_FLAG_RXNE) != RESET)\n            {\n                ch =  UartHandle.Instance->RDR & 0xff;\n            }\n            if (ch == -1)\n            {\n                break;\n            }\n            /* 读取到数据，将数据存入 ringbuffer */\n            rt_ringbuffer_putchar(&uart_rxcb, ch);\n        }\n        rt_sem_release(&shell_rx_sem);\n    }\n\n    /* leave interrupt */\n    rt_interrupt_leave();    // 在中断中一定要调用这对函数，离开中断\n}\n~~~\n\n之后，再次测试时，直接输入 help 并发送即可有同样的效果。\n\n> CubeMX 生成的中断处理函数中的回调函数可以屏蔽掉。\n\n\n\n# 5. 内核配置及裁剪\n\n`rtconfig.c`文件内容如下\n\n~~~ c\n/* RT-Thread config file */\n\n#ifndef __RTTHREAD_CFG_H__\n#define __RTTHREAD_CFG_H__\n\n/* ********************** 基础部分 *************************/\n/* 设置系统最大优先级，可设置范围 8 到 256，默认值 32 */\n#define RT_THREAD_PRIORITY_MAX 32\n\n/* 设置 RT-Thread 操作系统节拍，表示多少 tick 每秒 */\n/* 时钟节拍率越快，系统的额外开销就越大。常用值为 100 或 1000。 */\n#define RT_TICK_PER_SECOND 1000\n\n/* 字节对齐时设定对齐的字节个数，默认 4，常使用 ALIGN(RT_ALIGN_SIZE) 进行字节对齐 */\n#define RT_ALIGN_SIZE 4\n\n/* 设置对象名称的最大长度，默认 8 个字符，一般无需修改 */\n#define RT_NAME_MAX 8\n\n/* 设置使用组件自动初始化功能，默认需要使用，开启该宏则可以使用自动初始化功能 */\n#define RT_USING_COMPONENTS_INIT\n\n/* 开启 RT_USING_USER_MAIN 宏，则打开 user_main 功能，默认需要开启，这样才能调用 RT-Thread 的启动代码 */\n/* main 线程的栈大小可修改 */\n#define RT_USING_USER_MAIN\n#define RT_MAIN_THREAD_STACK_SIZE 1024\n\n\n/* ********************** 内核调试部分 *************************/\n/* 定义 RT_DEBUG 宏则开启 debug 模式。若开启系统调试，则在实现打印之后可以打印系统 LOG 日志。请在代码开发与调试过程中打开该项，帮助调试定位问题，在代码发布时关闭该项 */\n//#define RT_DEBUG\t\t\t\t\t// 关闭 debug\n#define RT_DEBUG_INIT 0\t\t\t\t// 启用组件初始化调试配置，设置为 1 则会打印自动初始化的函数名称\n//#define RT_USING_OVERFLOW_CHECK\t// 关闭栈溢出检查\n\n\n/* ********************** 钩子函数部分 *************************/\n/* 设置是否使用钩子函数，默认关闭 */\n//#define RT_USING_HOOK\t\t\t// 是否 开启系统钩子功能\n//#define RT_USING_IDLE_HOOK\t// 是否 开启空闲线程钩子功能\n\n\n/* ********************** 软件定时器部分 *************************/\n/* 设置是否启用软件定时器，以及相关参数的配置，默认关闭 */\n//#define RT_USING_TIMER_SOFT\t\t\t// 是否 开启软件定时器功能\n#define RT_TIMER_THREAD_PRIO 4\t\t\t// 设置软件定时器线程的优先级，默认为 4\n#define RT_TIMER_THREAD_STACK_SIZE 512\t// 设置软件定时器线程的栈大小，默认为 512 字节\n\n\n/* ********************** IPC 部分 *************************/\n/* 系统支持的 IPC 有：信号量、互斥量、事件集、邮箱、消息队列。通过定义相应的宏打开或关闭该 IPC 的使用 */\n#define RT_USING_SEMAPHORE\t\t// 设置是否使用 信号量，默认打开\n//#define RT_USING_MUTEX\t\t// 设置是否使用 互斥量\n//#define RT_USING_EVENT\t\t// 设置是否使用 事件集\n//#define RT_USING_MAILBOX\t\t// 设置是否使用  邮箱\n//#define RT_USING_MESSAGEQUEUE\t// 设置是否使用 消息队列\n\n\n/* ********************** 内存部分 *************************/\n/* RT-Thread 内存管理包含：内存池、内存堆、小内存算法。通过开启相应的宏定义使用相应的功能 */\n#define RT_USING_HEAP\t\t\t// 是否使用 内存堆\n#define RT_USING_SMALL_MEM\t\t// 是否使用 小内存管理\n//#define RT_USING_TINY_SIZE\t// 是否使用 小体积的算法，牵扯到 rt_memset、rt_memcpy 所产生的体积\n\n\n/* ********************** FinSH 部分 *************************/\n#define RT_USING_CONSOLE\t\t\t// 开启控制台功能，失能该宏则关闭控制台，不能实现打印\n#define RT_CONSOLEBUF_SIZE 128\t\t// 控制台缓冲大小（1-1024）\n/* 当系统加入 FinSH 组件源码后，需要在 rtconfig.h 中开启以下项。参考 finsh_config.h 中内容。若未加入 FinSH 组件源码，请勿开启此项。 */\n#include \"finsh_config.h\"\n\n\n/* ********************** device 部分 *************************/\n/* 当系统中加入 device 框架源码时，则需要在 rtconfig.h 中开启以下项。若未加入 device 源码，请勿开启此项 */\n//#define RT_USING_DEVICE\n\n#endif\n~~~\n\n`finsh_config.h`内容如下\n\n~~~ c\n/* FinSH config file */\n\n#ifndef __MSH_CFG_H__\n#define __MSH_CFG_H__\n\n/* 打开 FinSH 组件 */\n#define RT_USING_FINSH\n\n/* 使用 MSH 模式 */\n#define FINSH_USING_MSH\n#define FINSH_USING_MSH_ONLY\n\n/* tshell 线程的优先级与线程栈大小 */\n#define FINSH_THREAD_PRIORITY       21\t\t// 请检查系统最大优先级的值，该值必须在系统支持的优先级范围之内\n#define FINSH_THREAD_STACK_SIZE     1024\n\n/* 使用符号表，使用命令描述 */\n#define FINSH_USING_SYMTAB\n#define FINSH_USING_DESCRIPTION\n\n#endif\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["RTOS","RT-Thread"],"categories":["RTOS"]},{"title":"rtthread使用","url":"/2020/09/01/03. RTOS/rtthread_standard/","content":"\n\n\n* 开发平台：RT-Thread Studio\n* 开发板：潘多拉 STM32L475VET6、战舰板 STM32F103ZET6\n* RTThread版本：4.0.3\n* 芯片包版本：0.1.9（F1、F4、L4的都是）\n\n\n\n# 一. 创建工程及时钟\n\n## 1.1 创建工程\n\n文件 -> 新建 -> RT-Thread 项目。\n\n![1.1](./rtthread_standard/1.1.jpg)\n\n创建工程后，直接编译，无报错和警告\n\n> 如果这个时候直接编译不通过的，在包管理器中降低芯片包的版本，不要用最新的，最新的更多会适配高版本的rtthread，比如为了适配4.1.1而新发的芯片包。（L4芯片的就有这个问题）\n\n![1.2](./rtthread_standard/1.2.jpg)\n\n下载至开发板\n\n打开串口助手可以看到内容输出。\n\n![1.3](./rtthread_standard/1.3.jpg)\n\n\n\n## 1.2 时钟分析\n\n根据提示，默认使用的是内部时钟，如果需要修改，请修改`drv_clk.c`文件。\n\n分析一下，根据启动文件，可以梳理一下启动过程。\n\n![1.4](./rtthread_standard/1.4.jpg)\n\n从这里启动\n\n![1.5](./rtthread_standard/1.5.jpg)\n\n然后在 rt-thread -> src -> components.c 文件中能看到包含`int entry(void)`在内的所有初始化函数。\n\n从`int entry(void);`函数中进入`rtthread_startup();`函数，再从中进入`rt_hw_board_init();`函数，再从中进入`hw_board_init(BSP_CLOCK_SOURCE, BSP_CLOCK_SOURCE_FREQ_MHZ, BSP_CLOCK_SYSTEM_FREQ_MHZ);`函数。\n\n> 这里面传入的参数是定义在 board.h 文件中的，默认如下：\n>\n> /*-------------------------- CLOCK CONFIG BEGIN --------------------------*/\n>\n> #define BSP_CLOCK_SOURCE                  (\"HSI\")\n> #define BSP_CLOCK_SOURCE_FREQ_MHZ         ((int32_t)0)\n> #define BSP_CLOCK_SYSTEM_FREQ_MHZ         ((int32_t)80)\n>\n> /*-------------------------- CLOCK CONFIG END --------------------------*/\n>\n> 但是，继续往下翻下去，发现传入的这几个参数根本没用。\n\n再从中进去`clk_init(clock_src, clock_src_freq, clock_target_freq);`函数。这个函数就定义在`drv_clk.c`文件中。\n\n![1.6](./rtthread_standard/1.6.jpg)\n\n该函数又调用了`system_clock_config(target_freq);`函数，该函数内容如下，这里的时钟配置为默认使用的内部高速时钟。\n\n![1.7](./rtthread_standard/1.7.jpg)\n\n可以看出，最后这里是时钟初始化的地方。需要修改时钟只需要修改此函数即可。\n\n> 可以看出，board.h中的那几个宏定义在传参的过程中，最后也没传过来。（即 没用）\n\n## 1.3 时钟配置\n\n最简单的配置时钟的方法还是，使用cubemx生成一个。\n\n从左侧打开cubemx窗口，然后配置上调试接口、时钟树、**串口**，然后选择makefile，直接生成工程，其他的都没有改动。生成完毕之后，**然后关闭cubemx界面（后续都是关闭界面之后才生效，就不再写了）**，在左边可以看到cubemx文件夹。\n\n> 注意：\n>\n> 1. 串口的配置，打开就行，具体的参数可以不用管其实。\n> 2. 如果没看到这个文件夹，就鼠标在工程栏选中工程，然后右键刷新一下。\n\n![1.8](./rtthread_standard/1.8.jpg)\n\n生成完成之后还会有提示有个文件被重命名了。\n\n> 如果没弹出来，注意cubemx界面是否关掉了。一定要关掉才可以。\n>\n> 点击cubemx的时候，有时候会不小心点到多次，打开了两个cubemx界面，都要关掉才行。\n\n![1.9](./rtthread_standard/1.9.jpg)\n\n因为cubemx根据你的配置重新生成了一份配置文件，所以原有的那一份就给你换了个名字做备份。**而且后续每次使用cubemx生成代码后，该文件中的宏定义会自动打开，就不用手动打开了**。\n\n> 为什么在上面的配置中需要勾选串口，是因为，默认的配置文件中是打开了串口的定义的，但是使用cubemx重新生成的话，不勾选串口，生成的配置文件中不会自动添加使用串口的宏定义。\n\n![1.10](./rtthread_standard/1.10.jpg)\n\n\n\n另外，再次打开上面提到的`drv_clk.c`文件查看`clk_init`函数。\n\n可以发现使用cubemx生成之后，这个函数被自动更改了，提示我们这个函数现在使用的是cubemx生成的内容了。而且此时跟随`SystemClock_Config();`函数定义的位置，可以发现，它会跳到cubemx生成的那个`main.c`文件中的时钟初始化部分，即调用的是新生成的时钟初始化函数。\n\n![1.11](./rtthread_standard/1.11.jpg)\n\n而且，在cubemx生成的main.c文件中的main函数中，在定义的前面自动加了**__WEAK**标识。\n\n然后，点击编译，应该也是可以通过的，无错误无警告。\n\n> 如果有串口相关错误：检查cubemx是否打开了串口一的配置（SHELL默认用的串口一，但是实际上随便勾选一个串口，让cubemx把串口的头文件打开就行了，具体的引脚初始化函数其实没用到）\n\n\n\n# 二. 设备框架使用\n\n以下并不一定是按照从简单到麻烦的顺序来的。\n\n## 2.1 PIN设备\n\npin设备默认是开启的，直接使用即可。\n\n### 2.1.1 LED闪烁\n\n在工程中新建一个文件夹，在文件夹中新建一个`.c`文件，添加以下内容。\n\n编译下载后，在Shell窗口输入`led_thread_test`命令，可以看到两个LED闪烁。\n\n~~~ c\n/*\n * 程序清单：这是一个 pin 设备使用例程\n * 例程导出了 led_thread_test 命令到控制终端\n * 命令调用格式：led_thread_test\n * 程序功能：运行后两个led闪烁，闪烁时间间隔分别为1s和2s\n*/\n\n#include <rtdevice.h>\n#include \"drv_common.h\"\n#include <rtthread.h>\n\n\n// 线程函数体需要传入的参数\ntypedef struct\n{\n    rt_uint32_t flash_ms;\n    rt_uint8_t led_index;\n}Parameter_struct;\n\n\n// 线程相关参数\n#define THREAD_PRIORITY         25\n#define THREAD_STACK_SIZE       512\n#define THREAD_TIMESLICE        5\n\n// LED引脚定义\n#define LED0_PIN    GET_PIN(B, 5)\n#define LED1_PIN    GET_PIN(E, 5)\n\n// LED编号\n#define LED0    0\n#define LED1    1\n\n// 定义LED0的参数结构体\nParameter_struct Parameter0_struct =\n{\n    .flash_ms = 1000,\n    .led_index = LED0,\n};\n\n// 定义LED1的参数结构体\nParameter_struct Parameter1_struct =\n{\n    .flash_ms = 2000,\n    .led_index = LED1,\n};\n\n\n/* led_test：动态创建线程\n * 1. 定义一个 线程结构体指针      这里命名为：led_thread\n * 2. 编写一个 线程函数体          这里命名为：led_thread_entry\n * 3. 调用 rt_thread_create 创建一个线程\n * 4. 调用 rt_thread_startup 启动线程\n */\nstatic rt_thread_t led_thread = NULL;\n\n/**\n * @brief   LED闪烁线程函数体\n *\n * @param   flash_ms     闪烁间隔时间，单位毫秒\n * @param   led_index    led编号，0/1\n *\n * @return  none\n *\n * @note    static防止和其他文件中的重名；此线程不会终止。\n */\nstatic void led_thread_entry (void *parameter)\n{\n    // 接收传过来的参数\n    Parameter_struct *in_parameter = (Parameter_struct *)parameter;\n    // rt_kprintf(\"in_flash_ms = %d, in_led_index = %d \\n\", in_parameter->flash_ms, in_parameter->led_index);\n\n    // 反转使用\n    rt_uint32_t count = 0;\n    while(1)\n    {\n        // 判断LED编号\n        switch(in_parameter->led_index)\n        {\n            case LED0:\n                rt_kprintf(\"led0 flash \\n\");\n                rt_pin_write(LED0_PIN, count % 2);\n                break;\n\n            case LED1:\n                rt_kprintf(\"led1 flash \\n\");\n                rt_pin_write(LED1_PIN, count % 2);\n                break;\n\n            default:\n                rt_kprintf(\"please enter the correct LED index.(0/1) \\n\");\n        }\n        count++;\n        rt_thread_mdelay(in_parameter->flash_ms);\n    }\n}\n\nstatic int led_thread_test(void)\n{\n    // LED模式初始化\n    rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT);\n    rt_pin_mode(LED1_PIN, PIN_MODE_OUTPUT);\n    rt_pin_write(LED0_PIN, 1);\n    rt_pin_write(LED1_PIN, 1);\n\n    /* led0：动态创建线程 start */\n    if(Parameter0_struct.flash_ms != 0)\n    {\n        led_thread = rt_thread_create(\"led0_th\",                        // name\n                                        led_thread_entry,               // 函数体入口\n                                        (void*)&Parameter0_struct,      // 函数体 参数\n                                        THREAD_STACK_SIZE,              // 分配内存大小\n                                        THREAD_PRIORITY,                // 优先级\n                                        THREAD_TIMESLICE);              // 时间片大小\n        /* 如果获得线程控制块，启动这个线程 */\n        if (led_thread != RT_NULL)\n            rt_thread_startup(led_thread);    // 启动线程\n        else\n        {\n            // 输出错误码\n            rt_kprintf(\"led0 flash thread is failed...the error code is %ld \\r\\n\", led_thread->error);\n        }\n    }\n    /* led0：over  */\n\n    led_thread = RT_NULL;\n\n    /* led1：动态创建线程 start */\n    if(Parameter1_struct.flash_ms != 0)\n    {\n        led_thread = rt_thread_create(\"led1_th\",                        // name\n                                        led_thread_entry,               // 函数体入口\n                                        (void*)&Parameter1_struct,      // 函数体 参数\n                                        THREAD_STACK_SIZE,              // 分配内存大小\n                                        THREAD_PRIORITY,                // 优先级\n                                        THREAD_TIMESLICE);              // 时间片大小\n        /* 如果获得线程控制块，启动这个线程 */\n        if (led_thread != RT_NULL)\n            rt_thread_startup(led_thread);    // 启动线程\n        else\n        {\n            // 输出错误码\n            rt_kprintf(\"led1 flash thread is failed...the error code is %ld \\r\\n\", led_thread->error);\n        }\n    }\n\n    /* led1：over  */\n\n    return RT_EOK;\n}\n\nMSH_CMD_EXPORT(led_thread_test, led thread test);\n~~~\n\n\n\n### 2.1.2 按键中断\n\n在工程中新建一个文件夹，在文件夹中新建一个`.c`文件，添加以下内容。\n\n编译下载后，在Shell窗口输入`key_irq_test`命令，然后按下按键，对应LED亮起。\n\n~~~ c\n/*\n * 程序清单：这是一个 PIN 设备绑定中断使用例程\n * 例程导出了 key_irq_test 命令到控制终端\n * 命令调用格式：key_irq_test\n * 程序功能：通过按键控制led亮灭\n*/\n\n#include <rtthread.h>\n#include <rtdevice.h>\n\n#include \"drv_common.h\"\n\n// KEY引脚定义\n#define KEY0_PIN    GET_PIN(E, 4)   // RIGHT\n#define KEY2_PIN    GET_PIN(E, 2)   // LEFT\n// LED引脚定义\n#define LED0_PIN    GET_PIN(B, 5)\n#define LED1_PIN    GET_PIN(E, 5)\n\n\nvoid led0_on(void *args)\n{\n    rt_kprintf(\"led0 on, led1 off!\\n\");\n    rt_pin_write(LED0_PIN, PIN_LOW);\n    rt_pin_write(LED1_PIN, PIN_HIGH);\n}\n\nvoid led1_on(void *args)\n{\n    rt_kprintf(\"led0 off, led1 on!\\n\");\n    rt_pin_write(LED0_PIN, PIN_HIGH);\n    rt_pin_write(LED1_PIN, PIN_LOW);\n}\n\nstatic void key_irq_test(void)\n{\n    /* LED引脚为输出模式 */\n    rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT);\n    rt_pin_mode(LED1_PIN, PIN_MODE_OUTPUT);\n\n    /* 默认高电平 */\n    rt_pin_write(LED0_PIN, PIN_HIGH);\n    rt_pin_write(LED1_PIN, PIN_HIGH);\n\n    /* 按键0引脚为输入模式 */\n    rt_pin_mode(KEY0_PIN, PIN_MODE_INPUT_PULLUP);\n    /* 绑定中断，下降沿模式，回调函数名为led0_on */\n    rt_pin_attach_irq(KEY0_PIN, PIN_IRQ_MODE_FALLING, led0_on, RT_NULL);\n    /* 使能中断 */\n    rt_pin_irq_enable(KEY0_PIN, PIN_IRQ_ENABLE);\n\n    /* 按键2引脚为输入模式 */\n    rt_pin_mode(KEY2_PIN, PIN_MODE_INPUT_PULLUP);\n    /* 绑定中断，下降沿模式，回调函数名为led1_on */\n    rt_pin_attach_irq(KEY2_PIN, PIN_IRQ_MODE_FALLING, led1_on, RT_NULL);\n    /* 使能中断 */\n    rt_pin_irq_enable(KEY2_PIN, PIN_IRQ_ENABLE);\n}\n\n/* 导出到 msh 命令列表中 */\nMSH_CMD_EXPORT(key_irq_test, key irq test);\n~~~\n\n## 2.2 串口设备\n\n**目标：串口二接收串口助手发来的数据，并且将数据重新发送出去。**\n\n> 此设备的开启步骤在`board.h`中是有描述的。\n\n第一步：在 RT-Thread Settings 中 -> 组件 -> 设备驱动程序 -> 使用UART设备驱动程序 -> 使能串口DMA模式，勾选上。\n\n> 使用UART设备驱动程序 默认是打开的，因为串口一用于SHELL窗口了。这里只要把下面的DMA点开即可。\n\n第二步：在 board.h 中，添加如下宏定义。\n\n~~~ c\n// 新增 串口2 设备\n#define BSP_USING_UART2\n#define BSP_UART2_TX_PIN       \"PA2\"\n#define BSP_UART2_RX_PIN       \"PA3\"\n// 串口2 使用接收DMA\n#define BSP_UART2_RX_USING_DMA\n~~~\n\n> 此时如果直接编译，然后在Shell窗口输入list_device命令，就已经能看到uart2设备了。\n\n第三步：编写测试代码\n\n~~~ c\n/*\n * 程序清单：这是一个串口设备 DMA 接收使用例程\n * 例程导出了 uart2_dma_test 命令到控制终端\n * 命令调用格式：uart2_dma_test\n * 程序功能：运行后通过串口输出字符串\"usart2 test is running!\"，之后，串口会将接收到的数据重新发送出去。\n * 此功能需要做出的适配如下：1. 在board.h串口部分添加如下宏定义\n * #define BSP_USING_UART2\n * #define BSP_UART2_TX_PIN       \"PA2\"\n * #define BSP_UART2_RX_PIN       \"PA3\"\n * #define BSP_UART2_RX_USING_DMA\n * 2.在rt-thread settings-组件-设备驱动程序-串口中打开DMA设置\n*/\n\n#include <rtthread.h>\n\n// 串口接收消息结构\nstruct rx_msg\n{\n    rt_device_t dev;\n    rt_size_t size;\n};\n\n//  串口设备名称\n#define TEST_UART_NAME       \"uart2\"\n\n// 串口设备句柄\nstatic rt_device_t usart_serial;\n\n// 消息队列控制块\nstatic struct rt_messagequeue usart_rx_mq;\n\n\n/* 接收数据回调函数 */\n// 若串口以 DMA 接收模式打开，当 DMA 完成一批数据的接收后会调用此回调函数。\n// dev 是设备句柄\n// size 是缓冲区中接收到的数据长度\nstatic rt_err_t uart_input(rt_device_t dev, rt_size_t size)\n{\n    struct rx_msg msg;\n    rt_err_t result;\n\n    // 把接收消息的对象 和 消息的大小放到msg结构体\n    msg.dev = dev;\n    msg.size = size;\n\n    // 把包装好的msg发送到消息队列\n    result = rt_mq_send(&usart_rx_mq, &msg, sizeof(msg));\n\n    // 如果放满了输出提示信息\n    if ( result == -RT_EFULL)\n    {\n        /* 消息队列满 */\n        rt_kprintf(\"message queue full！\\n\");\n    }\n    return result;\n}\n\n// 串口线程函数体\nstatic void serial_thread_entry(void *parameter)\n{\n    struct rx_msg msg;\n    rt_err_t result;\n    rt_uint32_t rx_length;\n\n    static char rx_buffer[RT_SERIAL_RB_BUFSZ + 1];\n\n    // 循环接收消息\n    while (1)\n    {\n        // 将msg中的内容清零\n        rt_memset(&msg, 0, sizeof(msg));\n\n        /* 从消息队列中读取消息 放到msg中，采用一直等待的方式 */\n        result = rt_mq_recv(&usart_rx_mq, &msg, sizeof(msg), RT_WAITING_FOREVER);\n\n        if (result == RT_EOK)\n        {\n            /* 从串口读取 msg.size个字节的数据，并放到rx_buffer中  */\n            rx_length = rt_device_read(msg.dev, 0, rx_buffer, msg.size);\n\n            // 最后补 \\0\n            rx_buffer[rx_length] = '\\0';\n\n            /* 通过串口设备 serial 输出读取到的消息  */\n            rt_device_write(usart_serial, 0, rx_buffer, rx_length);\n\n            /* 打印数据 */\n            rt_kprintf(\"%s\\n\", rx_buffer);\n        }\n    }\n}\n\nstatic int uart2_dma_test(void)\n{\n    rt_err_t ret = RT_EOK;\n\n    static char msg_pool[256];\n\n    char str[] = \"usart2 test is running!\\r\\n\";\n\n    // 步骤1 通过串口名字找到串口句柄, 名称定义在最上边。\n    usart_serial = rt_device_find(TEST_UART_NAME);\n    if (!usart_serial)\n    {\n        // 未找到输出提示\n        rt_kprintf(TEST_UART_NAME);\n        rt_kprintf(\"not find!\\n\");\n\n        return RT_ERROR;\n    }\n\n    // 步骤2 设置串口初始化参数 这里跳过\n\n    // 步骤3 以DMA接收及轮询发送方式打开串口设备\n    rt_device_open(usart_serial, RT_DEVICE_FLAG_DMA_RX);\n\n    // 步骤4 设置串口接收回调函数\n    // 3.1 初始化消息队列（回调函数中需要使用）\n    rt_mq_init(&usart_rx_mq,\n                \"usart_rx_mq\",\n                msg_pool,                 /* 存放消息的缓冲区 */\n                sizeof(struct rx_msg),    /* 一条消息的最大长度 */\n                sizeof(msg_pool),         /* 存放消息的缓冲区大小 */\n                RT_IPC_FLAG_FIFO);        /* 如果有多个线程等待，按照先来先得到的方法分配消息 */\n    // 3.2 设置接收回调函数\n    rt_device_set_rx_indicate(usart_serial, uart_input);\n\n    // 步骤4 创建并启动 串口线程\n    // 发送开始了的提示信息\n    rt_device_write(usart_serial, 0, str, (sizeof(str) - 1));\n    // 创建 serial 线程\n    rt_thread_t thread = rt_thread_create(\"serial\", serial_thread_entry, RT_NULL, 1024, 25, 10);\n    // 创建成功则启动线程\n    if (thread != RT_NULL)\n    {\n        rt_thread_startup(thread);\n    }\n    else\n    {\n        ret = RT_ERROR;\n    }\n\n    return ret;\n}\n\n/* 导出到 msh 命令列表中 */\nMSH_CMD_EXPORT(uart2_dma_test, uart2 device dma test);\n~~~\n\n编译运行后，在SHELL窗口（串口一）输入`uart2_dma_test`命令，然后在串口二中发送信息，串口二会将收到的信息重新发送。\n\n\n\n**如果想要使用串口一，需要做出的改动如下：**\n\n1. board.c中的宏定义\n\n~~~ c\n#define BSP_USING_UART1\n#define BSP_UART1_TX_PIN       \"PA9\"\n#define BSP_UART1_RX_PIN       \"PA10\"\n#define BSP_UART1_RX_USING_DMA\n~~~\n\n2. 在 RT-Thread Settings 中 -> 组件 -> shell命令中，将其关闭。\n\n3. 将上述程序中的`#define TEST_UART_NAME       \"uart2\"`，2 改为 1。\n4. 其余的函数名、命令名改不改都行，不影响运行，要能分辨就行。\n\n**关于串口发送DMA**\n\n经测试，在部分芯片包中貌似不支持发送DMA。（理由未知）\n\n在潘多拉STM32L475VET6中，增加`#define BSP_UART2_TX_USING_DMA`宏定义会报错。\n\n而在电子料架板卡STM32F407VET6中，增加`#define BSP_UART2_TX_USING_DMA`宏定义就可以正常编译通过。\n\n\n\n## 2.3 CAN（需要改驱动）\n\n**目标：使用CAN接口发送和接收数据。**\n\n> 此设备的开启步骤在`board.h`中没有相关描述。但是有BUG。\n\n**硬件配置**\n\n* 硬件设备：CANelyst-Ⅱ，设备的CAN_L与开发板的L连接，设备的CAN_H与开发板的H连接。\n* 软件：USB_CAN TOOL，切记切记要安装驱动，否则会一直显示未找到设备。\n\n> 可以先按照软件上方目录 -> 设备操作 -> USBCAN测试工具中的操作指引，将硬件两个端口连起来，测试硬件是否正常运行，然后在搞软件。\n>\n> 常见问题：\n>\n> 1. 设备一直未找到（无法连接）。打开电脑设备管理器看CAN设备是否正常识别，如果未识别，说明没安装驱动。安装驱动方法参考：软件上方目录 -> 帮助 -> 帮助文档 -> 2. USB驱动安装与卸载说明书.pdf\n\n**程序**\n\n第一步：在 RT-Thread Settings 中 -> 组件 -> 设备驱动程序 -> CAN设备驱动程序，勾选上 -> 使能CAN硬件过滤器，也先勾选上。\n\n> 硬件过滤器：作用未知，等了解了过来写上。\n\n第二步：添加驱动程序。在RT-Thread Studio 软件的安装目录下：D:\\RT-ThreadStudio\\repo\\Extract\\RT-Thread_Source_Code\\RT-Thread\\4.0.3\\bsp\\stm32\\libraries\\HAL_Drivers\\\n\n找到`drv_can.c`放到我们工程的drivers文件夹，找到`drv_can.h`文件放到我们工程的drivers\\include文件夹。\n\n第三步：添加以下宏定义到`board.h`文件中，这里使用 CAN1 进行测试。注意：下面这部分宏定义都是自己添加的，默认是没有关于CAN接口的宏定义的。\n\n~~~ c\n/*-------------------------- CAN CONFIG BEGIN --------------------------*/\n\n#define BSP_USING_CAN\n#define BSP_USING_CAN1\n/*#define BSP_USING_CAN2*/\n\n/*-------------------------- CAN CONFIG END --------------------------*/\n~~~\n\n第四步：从左侧窗口打开cubemx，勾选上CAN接口，引脚是对的就可以，参数配置可以不用管。然后关闭cubemx界面，生成代码后刷新左侧目录界面。即可在cubemx文件夹中的`stm32f1xx_hal_msp.c`文件中看到CAN的引脚初始化代码。\n\n> 此时如果直接编译，然后在Shell窗口输入list_device命令，就已经能看到can1设备了。\n\n第五步：编写测试代码，程序运行后，打开CAN-USB软件并连接设备，波特率设置1000k，然后在Shell窗口输入can_test命令，即可从CAN-USB软件中看到开发板发送的消息。也可以使用CAN-USB软件发送消息，在Shell窗口可看到接收的消息。\n\n~~~ c\n/*\n * 程序清单：这是一个 CAN 设备使用例程\n * 例程导出了 can_test 命令到控制终端\n * 命令调用格式：can_test can1\n * 命令解释：命令第二个参数是要使用的 CAN 设备名称，为空则使用默认的 CAN 设备\n * 程序功能：通过 CAN 设备发送一帧，并创建一个线程接收数据然后打印输出。\n*/\n\n#include <rtthread.h>\n#include \"rtdevice.h\"\n\n#define CAN_DEV_NAME       \"can1\"      /* CAN 设备名称 */\n\nstatic struct rt_semaphore rx_sem;     /* 用于接收消息的信号量 */\nstatic rt_device_t can_dev;            /* CAN 设备句柄 */\n\n/* 接收数据回调函数 */\nstatic rt_err_t can_rx_call(rt_device_t dev, rt_size_t size)\n{\n    /* CAN 接收到数据后产生中断，调用此回调函数，然后发送接收信号量 */\n    rt_sem_release(&rx_sem);\n\n    return RT_EOK;\n}\n\nstatic void can_rx_thread(void *parameter)\n{\n    int i;\n    rt_err_t res;\n    struct rt_can_msg rxmsg = {0};\n\n    /* 设置接收回调函数 */\n    rt_device_set_rx_indicate(can_dev, can_rx_call);\n\n#ifdef RT_CAN_USING_HDR\n    struct rt_can_filter_item items[5] =\n    {\n        RT_CAN_FILTER_ITEM_INIT(0x100, 0, 0, 0, 0x700, RT_NULL, RT_NULL), /* std,match ID:0x100~0x1ff，hdr 为 - 1，设置默认过滤表 */\n        RT_CAN_FILTER_ITEM_INIT(0x300, 0, 0, 0, 0x700, RT_NULL, RT_NULL), /* std,match ID:0x300~0x3ff，hdr 为 - 1 */\n        RT_CAN_FILTER_ITEM_INIT(0x211, 0, 0, 0, 0x7ff, RT_NULL, RT_NULL), /* std,match ID:0x211，hdr 为 - 1 */\n        RT_CAN_FILTER_STD_INIT(0x486, RT_NULL, RT_NULL),                  /* std,match ID:0x486，hdr 为 - 1 */\n        {0x555, 0, 0, 0, 0x7ff, 7,}                                       /* std,match ID:0x555，hdr 为 7，指定设置 7 号过滤表 */\n    };\n    struct rt_can_filter_config cfg = {5, 1, items}; /* 一共有 5 个过滤表 */\n    /* 设置硬件过滤表 */\n    res = rt_device_control(can_dev, RT_CAN_CMD_SET_FILTER, &cfg);\n    RT_ASSERT(res == RT_EOK);\n#endif\n\n    while (1)\n    {\n        /* hdr 值为 - 1，表示直接从 uselist 链表读取数据 */\n        rxmsg.hdr = -1;\n        /* 阻塞等待接收信号量 */\n        rt_sem_take(&rx_sem, RT_WAITING_FOREVER);\n        /* 从 CAN 读取一帧数据 */\n        rt_device_read(can_dev, 0, &rxmsg, sizeof(rxmsg));\n        /* 打印数据 ID 及内容 */\n        rt_kprintf(\"ID:%x\", rxmsg.id);\n        for (i = 0; i < 8; i++)\n        {\n            rt_kprintf(\"%2x\", rxmsg.data[i]);\n        }\n\n        rt_kprintf(\"\\n\");\n    }\n}\n\nint can_test(int argc, char *argv[])\n{\n    struct rt_can_msg msg = {0};\n    rt_err_t res;\n    rt_size_t  size;\n    rt_thread_t thread;\n    char can_name[RT_NAME_MAX];\n\n    if (argc == 2)\n    {\n        rt_strncpy(can_name, argv[1], RT_NAME_MAX);\n    }\n    else\n    {\n        rt_strncpy(can_name, CAN_DEV_NAME, RT_NAME_MAX);\n    }\n\n    /* 查找 CAN 设备 */\n    can_dev = rt_device_find(can_name);\n    if (!can_dev)\n    {\n        rt_kprintf(\"find %s failed!\\n\", can_name);\n        return RT_ERROR;\n    }\n\n    /* 初始化 CAN 接收信号量 */\n    rt_sem_init(&rx_sem, \"rx_sem\", 0, RT_IPC_FLAG_FIFO);\n\n    /* 以中断接收及中断发送方式打开 CAN 设备 */\n    res = rt_device_open(can_dev, RT_DEVICE_FLAG_INT_TX | RT_DEVICE_FLAG_INT_RX);\n    RT_ASSERT(res == RT_EOK);\n\n    /* 创建数据接收线程 */\n    thread = rt_thread_create(\"can_rx\", can_rx_thread, RT_NULL, 1024, 25, 10);\n    if (thread != RT_NULL)\n    {\n        rt_thread_startup(thread);\n    }\n    else\n    {\n        rt_kprintf(\"create can_rx thread failed!\\n\");\n    }\n\n    msg.id = 0x78;              /* ID 为 0x78 */\n    msg.ide = RT_CAN_STDID;     /* 标准格式 */\n    msg.rtr = RT_CAN_DTR;       /* 数据帧 */\n    msg.len = 8;                /* 数据长度为 8 */\n\n    /* 待发送的 8 字节数据 */\n    msg.data[0] = 0x00;\n    msg.data[1] = 0x11;\n    msg.data[2] = 0x22;\n    msg.data[3] = 0x33;\n    msg.data[4] = 0x44;\n    msg.data[5] = 0x55;\n    msg.data[6] = 0x66;\n    msg.data[7] = 0x77;\n    /* 发送一帧 CAN 数据 */\n    size = rt_device_write(can_dev, 0, &msg, sizeof(msg));\n    if (size == 0)\n    {\n        rt_kprintf(\"can dev write data failed!\\n\");\n    }\n\n    // 更改后再发送十次\n    for(rt_uint8_t send_ind = 0; send_ind < 10; send_ind++)\n    {\n        rt_thread_mdelay(1000);\n\n        msg.data[0] = msg.data[0] + 0x01;\n        msg.data[1] = msg.data[1] + 0x01;\n        msg.data[2] = msg.data[2] + 0x01;\n        msg.data[3] = msg.data[3] + 0x01;\n        msg.data[4] = msg.data[4] + 0x01;\n        msg.data[5] = msg.data[5] + 0x01;\n        msg.data[6] = msg.data[6] + 0x01;\n        msg.data[7] = msg.data[7] + 0x01;\n        /* 发送一帧 CAN 数据 */\n        size = rt_device_write(can_dev, 0, &msg, sizeof(msg));\n        if (size == 0)\n        {\n            rt_kprintf(\"can dev write data failed!\\n\");\n        }\n    }\n\n    return res;\n}\n\n/* 导出到 msh 命令列表中 */\nMSH_CMD_EXPORT(can_test, can device sample);\n~~~\n\n\n\n> 另外：上述程序使用F1的开发板没有出现问题，但是使用其他板卡（F407VET6）上一直发送失败。\n>\n> 问题和解决办法如下：https://club.rt-thread.org/ask/article/5cedb728813e6fd8.html\n>\n> 但是相比于上面文章，多更改了关于波特率表的设置，自己测试一下波特率250和500k的需不需要改。\n>\n> **修改后的CAN驱动文件在文件夹中附上了。**\n\n\n\n## 2.4 ADC\n\n**目标：串口打印ADC的值。**\n\n> 此设备的开启步骤在`board.h`中是有描述的。\n\n第一步：在 RT-Thread Settings 中 -> 组件 -> 设备驱动程序 ->  使用ADC设备驱动程序，勾选上。\n\n第二步：在`board.h`中打开`#define BSP_USING_ADC1`宏定义。\n\n> 这里测试使用的引脚为PA1（ADC1的通道1）。\n\n第三步：从左侧窗口打开cubemx，勾选上ADC1的CH1，确认一下引脚是不是对的，参数配置可以不用管。ADC打开了，时钟树配置界面ADC的时钟也要配置一下，不能超过14Mhz（ADC的需求）。然后关闭cubemx界面，生成代码后刷新左侧目录界面。即可在cubemx文件夹中的`stm32f1xx_hal_msp.c`文件中看到ADC的引脚初始化代码。\n\n> 此时如果直接编译，然后在Shell窗口输入list_device命令，就已经能看到adc1设备了。\n\n第四步：编写测试代码，程序运行后，在Shell窗口输入adc_vol_test命令，即可以在Shell窗口看到连续发送50次的ADC采样值和电压值。在此过程中改变PA1接触的地方，可以看到电压值的改变。\n\n~~~ c\n/*\n * 程序清单： ADC 设备使用例程\n * 例程导出了 adc_vol_test 命令到控制终端\n * 命令调用格式：adc_vol_test\n * 程序功能：通过 ADC 设备采样电压值并转换为数值。\n *           示例代码参考电压为3.3V,转换位数为12位。\n*/\n\n#include <rtthread.h>\n#include <rtdevice.h>\n\n\n#define ADC_DEV_NAME        \"adc1\"      /* ADC 设备名称 */\n#define ADC_DEV_CHANNEL     1           /* ADC 通道 */\n#define REFER_VOLTAGE       330         /* 参考电压 3.3V,数据精度乘以100保留2位小数*/\n#define CONVERT_BITS        (1 << 12)   /* 转换位数为12位 */\n\n\nstatic int adc_vol_test(int argc, char *argv[])\n{\n    rt_adc_device_t adc_dev;\n    rt_uint32_t value, vol;\n    rt_err_t ret = RT_EOK;\n\n    /* 查找设备 */\n    adc_dev = (rt_adc_device_t)rt_device_find(ADC_DEV_NAME);\n\n    if (adc_dev == RT_NULL)\n    {\n        rt_kprintf(\"adc test run failed! can't find %s device!\\n\", ADC_DEV_NAME);\n        return RT_ERROR;\n    }\n\n    /* 使能设备 */\n    ret = rt_adc_enable(adc_dev, ADC_DEV_CHANNEL);\n\n    // 连续采集并发送50次\n    for(rt_uint16_t times = 0; times <= 50; times++)\n    {\n        /* 读取采样值 */\n        value = rt_adc_read(adc_dev, ADC_DEV_CHANNEL);\n        /* 转换为对应电压值 */\n        vol = value * REFER_VOLTAGE / CONVERT_BITS;\n        // 输出\n        rt_kprintf(\"the value is :%d, the voltage is :%d.%02d \\n\", value, vol / 100, vol % 100);\n        // 等待一下下再开启下一轮\n        rt_thread_mdelay(500);\n    }\n\n    /* 关闭通道 */\n    ret = rt_adc_disable(adc_dev, ADC_DEV_CHANNEL);\n\n    return ret;\n}\n\n/* 导出到 msh 命令列表中 */\nMSH_CMD_EXPORT(adc_vol_test, adc voltage convert test);\n~~~\n\n\n\n## 2.5 IIC\n\n**目标：实现对24C02的读写功能。**\n\n> 此设备的开启步骤在`board.h`中是有描述的。\n\n第一步：在 RT-Thread Settings 中 -> 组件 -> 设备驱动程序 ->  使用GPIO模拟I2C，勾选上。\n\n第二步：在`board.h`中打开`#define BSP_USING_I2C1`宏定义，并修改对应的引脚。注意这里的引脚是用的软件模拟，跟硬件IIC没关系，所以引脚用哪个写哪个。这里如下：\n\n~~~ c\n#define BSP_USING_I2C1\n#ifdef BSP_USING_I2C1\n#define BSP_I2C1_SCL_PIN    GET_PIN(B, 6)\n#define BSP_I2C1_SDA_PIN    GET_PIN(B, 7)\n#endif\n~~~\n\n> 此时如果直接编译，然后在Shell窗口输入list_device命令，就已经能看到i2c1设备了。\n\n第三步：编写24C02驱动代码及测试代码。\n\nC文件\n\n~~~ c\n#include \"drv_iic_24c02.h\"\n\n#define LOG_TAG               \"AT24C02\"\n#define LOG_LVL               LOG_LVL_DBG\n#include <rtdbg.h>\n\n/* I2C总 线 设 备 句 柄 */\nstatic struct rt_i2c_bus_device *i2c_bus = RT_NULL;\n\n/**\n * @brief   读AT24C02中addr地址的数据\n *\n * @param   addr   读取的地址（0-255）\n *\n * @return  RT_EOK：正常；RT_ERROR：不正常。\n */\nuint8_t at24c02_read_byte(uint8_t addr)\n{\n    struct rt_i2c_msg msg;\n    uint8_t buffer[2];\n    uint8_t data;\n\n    msg.addr = AT24C02_I2C_ADDR;\n    msg.flags = RT_I2C_WR;\n    buffer[0] = addr;\n    msg.buf = buffer;\n    msg.len = 1;\n    // 发送要读数据的地址\n    rt_i2c_transfer(i2c_bus, &msg, 1);\n\n    msg.flags = RT_I2C_RD;\n    msg.buf = &data;\n    // 读数据\n    rt_i2c_transfer(i2c_bus, &msg, 1);\n\n    return data;\n}\n\n/**\n * @brief   AT24C02写一个字节数据\n *\n * @param   addr   写入的地址（0-255）\n * @param   data   写入的数据\n *\n * @return  RT_EOK：正常；RT_ERROR：不正常。\n */\nrt_err_t at24c02_write_byte(uint8_t addr, uint8_t data)\n{\n    struct rt_i2c_msg msg;\n\n    uint8_t buffer[2];\n\n    buffer[0] = addr;\n    buffer[1] = data;\n\n    msg.addr = AT24C02_I2C_ADDR;\n    msg.flags = RT_I2C_WR;\n    msg.buf = buffer;\n    msg.len = 2;\n    // 发送要写数据的地址、写的数据\n    if(rt_i2c_transfer(i2c_bus, &msg, 1) != 1)\n        return RT_ERROR;\n\n    return RT_EOK;\n}\n\n/**\n * @brief   检查AT24C02设备是否正常\n *\n * @param   check   任意传入一个数（1字节），每次检查不要一样。\n *\n * @return  RT_EOK：正常；RT_ERROR：不正常。\n */\nstatic rt_err_t at24c02_check(uint8_t check)\n{\n    uint8_t temp;\n\n    // 读取最后一个字节的数据\n    temp = at24c02_read_byte(AT24C02_SIZE - 1);\n    if(temp != check)\n    {\n        // 把数据写入最后一个字节的位置\n        at24c02_write_byte(AT24C02_SIZE - 1, check);\n        rt_thread_mdelay(5);    // wait 5ms\n        // 再次读取\n        temp = at24c02_read_byte(AT24C02_SIZE - 1);\n        if(temp != check)\n            return RT_ERROR;\n    }\n    return RT_EOK;\n}\n\n/**\n * @brief   初始化AT24C02\n *\n * @param   void\n *\n * @return  none\n */\nrt_err_t at24c02_init()\n{\n    // 查找I2C总线设备，获取I2C总线设备句柄\n    i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(AT24C02_I2C_BUS_NAME);\n    if (i2c_bus == RT_NULL)\n    {\n        LOG_D(\"can't find device! \\n\");\n        return RT_ERROR;\n    }\n\n    // 检查AT24C02\n    if(at24c02_check(AT24C02_CHECK_VALUE) != RT_EOK)\n    {\n        LOG_D(\"at24c02 check fail! \\n\");\n        return RT_ERROR;\n    }\n    LOG_D(\"at24c02 check ok! \\n\");\n    return RT_EOK;\n}\n~~~\n\n头文件\n\n~~~ c\n#ifndef APPLICATIONS_ICODE_IIC_24C02_SUPPORT_DRV_IIC_24C02_H_\n#define APPLICATIONS_ICODE_IIC_24C02_SUPPORT_DRV_IIC_24C02_H_\n\n#include <rtthread.h>\n#include \"drv_soft_i2c.h\"\n\n#define AT24C02_I2C_BUS_NAME    \"i2c1\"      // 挂载IIC1上，PB6、PB7\n#define AT24C02_I2C_ADDR        0x50        // AT24C02从机地址(原有的是0xA0)\n#define AT24C02_SIZE            256         // AT24C02大小，共256字节\n#define AT24C02_CHECK_VALUE     0x5a\n\n/*\n * 24C02是2K，A0/A1/A2均为0，根据数据手册地址应该为，1 0 1 0 0 0 0 R/W；\n * 即\n * 写：R/W=0，1 0 1 0 0 0 0 0，即0xA0；\n * 读：R/W=1，1 0 1 0 0 0 0 1，即0xA1；\n * 但是：对于7位地址模式，rt_i2c_transfer函数调用了bus->ops->master_xfer(bus, msgs, num);\n * 这个函数为：i2c_bit_xfer，这个函数又调用了i2c_bit_send_address。\n * 这个函数对于七位地址的处理为 addr1 = msg->addr << 1;\n * 即 左移了一位。我们原有的 0xA0 左移之后就不对了。\n * 因此，这里将我们的0xA0提前右移一位 变成0x50，然后再发送就可以了。\n *\n * */\n\nrt_err_t at24c02_init();    // 初始化AT24C02\nuint8_t at24c02_read_byte(uint8_t addr);\nrt_err_t at24c02_write_byte(uint8_t addr, uint8_t data);\n\n\n#endif /* APPLICATIONS_ICODE_IIC_24C02_SUPPORT_DRV_IIC_24C02_H_ */\n~~~\n\n测试代码\n\n~~~ c\n#include \"drv_iic_24c02.h\"\n#include <rtthread.h>\n\n\nstatic int iic_at24c02_test(void)\n{\n    rt_uint8_t *read_write_read_buf = RT_NULL;\n\n    // 申请一段内存（256个字节）\n    read_write_read_buf = (rt_uint8_t *)rt_malloc(AT24C02_SIZE);\n\n    // 初始化 at24c02\n    at24c02_init();\n\n    // 擦除(即全部填充为0)\n    for(rt_uint16_t addr = 0; addr < AT24C02_SIZE; addr++)\n    {\n        if(RT_EOK == at24c02_write_byte(addr, 0))\n            rt_kprintf(\"address %x erase OK.\\n\", addr);\n        else\n            rt_kprintf(\"address %x erase Failed.\\n\", addr);\n    }\n\n    // 连续读255字节的数据\n    for(rt_uint16_t addr = 0; addr < AT24C02_SIZE; addr++)\n    {\n        read_write_read_buf[addr] = at24c02_read_byte(addr);\n        rt_kprintf(\"the data at address %x is %d.\\n\", addr, read_write_read_buf[addr]);\n    }\n\n    // 连续写\n    for(rt_uint16_t addr = 0; addr < AT24C02_SIZE; addr++)\n    {\n        if(RT_EOK == at24c02_write_byte(addr, addr))\n            rt_kprintf(\"address %x write OK.\\n\", addr);\n        else\n            rt_kprintf(\"address %x write Failed.\\n\", addr);\n    }\n\n    // 再次连续读255字节的数据\n    for(rt_uint16_t addr = 0; addr < AT24C02_SIZE; addr++)\n    {\n        read_write_read_buf[addr] = at24c02_read_byte(addr);\n        rt_kprintf(\"the data at address %x is %d.\\n\", addr, read_write_read_buf[addr]);\n    }\n\n    // 释放申请的内存\n    rt_free(read_write_read_buf);\n\n    return RT_EOK;\n}\nMSH_CMD_EXPORT(iic_at24c02_test, iic at24c02 read write test);\n\n~~~\n\n程序运行后，在Shell窗口输入`iic_at24c02_test`命令，即可看到程序首先将芯片数据全部擦除，然后读取，读取之后写入，并再次读取查看是否是写入的数据。\n\n\n\n## 2.6 SPI + DFS\n\n**目标：直接上文件系统。**\n\n> 这里用的潘多拉的板子，存储使用SD卡，接口是SPI。\n\n第一步：在 RT-Thread Settings 中 -> 组件 -> 设备驱动程序 ->  使用 SPI 总线/设备驱动程序，勾选上。\n\n第二步：在`board.h`中打开`#define BSP_USING_SPI1`宏定义，根据自己实际使用的SPI接口设置即可。\n\n第三步：从左侧窗口打开cubemx，SPI1，确认一下引脚是不是对的，参数配置可以不用管，然后关闭cubemx界面，生成代码后刷新左侧目录界面。即可在cubemx文件夹中的`stm32l4xx_hal_msp.c`文件中看到SPI的引脚初始化代码。\n\n到了这里SPI就可以使用了。\n\n第四步：在 RT-Thread Settings 中 -> 组件 -> 设备驱动程序 ->  使用 SPI 总线/设备驱动程序 -> 使用 SPI SD/TF 卡驱动程序，勾选上。\n\n勾选上保存之后，就能在 rt-thread -> components 中看到 dfs 文件夹。这个文件夹中的文件定义了系统挂载、打开文件、创建文件夹等等接口。\n\n\n\n## 2.7 PWM（需要改驱动）\n\n**目标：PWM实现呼吸灯。**\n\n> 此设备的开启步骤在`board.h`中是有描述的。但是**不全**，而且有BUG。\n\n第一步：在 RT-Thread Settings 中 -> 组件 -> 设备驱动程序 ->  使用 PWM 设备驱动程序，勾选上。\n\n第二步：在`board.h`中打开`#define BSP_USING_PWM3`宏定义，并添加使用的通道宏定义`#define BSP_USING_PWM3_CH2`。\n\n> 这里测试使用的引脚为PB5（TIM3的通道2）。根据自己使用的定时器和通道进行修改上述宏定义。\n>\n> 另外，通道宏定义board.h里面没写，要自己添加上。\n\n第三步：从左侧窗口打开cubemx，勾选上TIM3的CH2，确认一下引脚是不是对的，参数配置可以不用管，然后关闭cubemx界面，生成代码后刷新左侧目录界面。即可在cubemx文件夹中的`stm32f1xx_hal_msp.c`文件中看到TIM的引脚初始化代码，一共有两个函数。\n\n~~~ c\nvoid HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)\nvoid HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)\n~~~\n\n第四步：**修改drv_pwm.c**\n\n在`drv_pwm.c`文件中的`static rt_err_t stm32_hw_pwm_init(struct stm32_pwm *device)`函数中，添加定时器的初始化。\n\n~~~ c\nstatic rt_err_t stm32_hw_pwm_init(struct stm32_pwm *device)\n{\n    rt_err_t result = RT_EOK;\n    TIM_HandleTypeDef *tim = RT_NULL;\n    TIM_OC_InitTypeDef oc_config = {0};\n    TIM_MasterConfigTypeDef master_config = {0};\n    TIM_ClockConfigTypeDef clock_config = {0};\n\n    RT_ASSERT(device != RT_NULL);\n\n    tim = (TIM_HandleTypeDef *)&device->tim_handle;\n\n    /* configure the timer to pwm mode */\n    tim->Init.Prescaler = 0;\n    tim->Init.CounterMode = TIM_COUNTERMODE_UP;\n    tim->Init.Period = 0;\n    tim->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n#if defined(SOC_SERIES_STM32F1) || defined(SOC_SERIES_STM32L4)\n    tim->Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n#endif\n\n    // 以下是自己添加的\n    // 注意这里是定时器的初始化 别看混了!!!\n    if (HAL_TIM_Base_Init(tim) != HAL_OK)\n    {\n        LOG_E(\"%s tim init failed\", device->name);\n        result = -RT_ERROR;\n        goto __exit;\n    }\n    // 以上是自己添加的\n    \n    if (HAL_TIM_PWM_Init(tim) != HAL_OK)\n    {\n        LOG_E(\"%s pwm init failed\", device->name);\n        result = -RT_ERROR;\n        goto __exit;\n    }\n    ...\n}\n\n~~~\n\n第五步：添加测试例程\n\n~~~ c\n/*\n * 程序清单：这是一个 PWM 设备使用例程\n * 例程导出了 pwm_thread_test 命令到控制终端\n * 命令调用格式：pwm_thread_test\n * 程序功能：通过 PWM 设备控制 LED 灯的亮度，可以看到LED不停的由暗变到亮，然后又从亮变到暗。\n*/\n\n#include <rtthread.h>\n#include <rtdevice.h>\n\n#define PWM_DEV_NAME        \"pwm3\"  /* PWM设备名称 */\n#define PWM_DEV_CHANNEL     2       /* PWM通道 */\n\nstruct rt_device_pwm *pwm_dev;      /* PWM设备句柄 */\n\nstatic rt_thread_t pwm_thread = NULL;\n\n// 线程相关参数\n#define THREAD_PRIORITY         25\n#define THREAD_STACK_SIZE       512\n#define THREAD_TIMESLICE        5\n\nstatic void pwm_led_thread_entry(void *parameter)\n{\n    rt_uint32_t period, pulse, dir;\n\n    period = 500000;    /* 周期为0.5ms，单位为纳秒ns */\n    dir = 1;            /* PWM脉冲宽度值的增减方向 */\n    pulse = 0;          /* PWM脉冲宽度值，单位为纳秒ns */\n\n    /* 查找设备 */\n    pwm_dev = (struct rt_device_pwm *)rt_device_find(PWM_DEV_NAME);\n    if (pwm_dev == RT_NULL)\n    {\n        rt_kprintf(\"pwm sample run failed! can't find %s device!\\n\", PWM_DEV_NAME);\n    }\n\n    /* 设置PWM周期和脉冲宽度默认值 */\n    rt_pwm_set(pwm_dev, PWM_DEV_CHANNEL, period, pulse);\n    /* 使能设备 */\n    rt_pwm_enable(pwm_dev, PWM_DEV_CHANNEL);\n\n    while (1)\n    {\n        rt_thread_mdelay(50);\n        if (dir)\n        {\n            pulse += 5000;      /* 从0值开始每次增加5000ns */\n        }\n        else\n        {\n            pulse -= 5000;      /* 从最大值开始每次减少5000ns */\n        }\n        if (pulse >= period)\n        {\n            dir = 0;\n        }\n        if (0 == pulse)\n        {\n            dir = 1;\n        }\n\n        /* 设置PWM周期和脉冲宽度 */\n        rt_pwm_set(pwm_dev, PWM_DEV_CHANNEL, period, pulse);\n    }\n}\n\n\nstatic int pwm_thread_test(void)\n{\n    pwm_thread = rt_thread_create(\"pwm_th\",                        // name\n                                    pwm_led_thread_entry,           // 函数体入口\n                                    RT_NULL,                        // 函数体 参数\n                                    THREAD_STACK_SIZE,              // 分配内存大小\n                                    THREAD_PRIORITY,                // 优先级\n                                    THREAD_TIMESLICE);              // 时间片大小\n    /* 如果获得线程控制块，启动这个线程 */\n    if (pwm_thread != RT_NULL)\n        rt_thread_startup(pwm_thread);    // 启动线程\n    else\n    {\n        // 输出错误码\n        rt_kprintf(\"pwm led thread is failed...the error code is %ld \\r\\n\", pwm_thread->error);\n    }\n\n    return RT_EOK;\n}\n\n/* 导出到 msh 命令列表中 */\nMSH_CMD_EXPORT(pwm_thread_test, pwm thread test);\n~~~\n\n\n\n## 2.8 网口\n\n\n\n","tags":["RTOS","RT-Thread"],"categories":["RTOS"]},{"title":"C语言","url":"/2017/01/01/01. 编程语法/c/","content":"\n\n\n# 1. C语言概述\n\n## 1.1 特点\n\n1. **代码级别的跨平台**：由于标准的存在，使得几乎同样的C代码可用于多种操作系统。\n2.  **允许直接访问物理地址**，对硬件进行操作。\n3. C语言是一个有结构化程序设计、具有变量作用域（variable scope）以及递归功能的过程式语言。\n4. C语言传递参数可以是值传递（pass by value，值），也可以传递指针（apointer passed by value，地址）。\n5. C语言中，**没有对象**，不同的变量类型可以用结构体（struct）组合在一起。\n6. **预编译处理（preprocessor）,生成目标代码质量高，程序执行效率高**。\n\n## 1.2 运行机制\n\n1. 编辑：比如编写我们的 hello.c 文件，就是源代码.\n2. 编译：将 hello.c 程序翻译成目标文件 (hello.obj) // 在计算机底层执行\n3. 链接：将目标文件 hello.obj + 库文件生成可执行文件(MyProject01.exe) // 在计算机底层执行\n4. 运行：执行.exe文件，得到运行结果\n\n* 编译\n  1. 有了C源文件，通过编译器将其编译成 obj文件(目标文件)。\n  2. 如果程序没有错误，没有任何提示，但在Debug目录下会出现一个 Hello.obj 文件，该文件称为目标文件。\n* 链接\n  1. 有了目标文件(.obj文件)，通过链接程序将其和运行需要的c库文件链接成exe文件(可执行文件)。\n  2.  如果程序没有错误，没有任何提示，但在 Debug 目录下会出现一个项目名.exe文件，该文件称为可执行文件。\n  3. 为什么需要链接库文件呢？因为我们的C程序中会使用C程序库的内容，比如<stdio.h><stdlib.h>中的函数 printf()、system() 等等,这些函数不是程序员自己写的，而是C程序库中提供的，因此需要链接。\n  4. 你会发现链接后，生成的.exe文件，比obj文件大了很多.\n* 运行\n  1. 有了可执行的exe文件,也称为可执行程序(二进制文件)\n  2. 在控制台下可以直接运行exe文件\n\n## 1.3 转义字符\n\n~~~ markdown\n\\t ：一个制表位，实现对齐的功能\n\\n ：换行符\n\\\\ ：一个\\\n\\\" : 一个\"\n\\' ：一个'\n\\r : 一个回车printf(\"张无忌赵敏周\\r芷若小昭\");\n~~~\n\n## 1.4 注释\n\n~~~ c\n// 单行注释\n\n/*\n\t多行注释1\n\t多行注释2\n\t注释不允许嵌套\n*/\n~~~\n\n## 1.5 标准库\n\nC标准库是一组C内置函数、常量和头文件，比如<stdio.h>、<stdlib.h>、<math.h>，等等。\n\n可以查手册来找需要使用的库和函数。\n\n\n\n# 2. 变量\n\n## 2.1 变量介绍\n\n变量相当于**内存中一个数据存储空间的表示**，通过变量名可以访问到变量(值)。\n\n1. 变量表示内存中的一个存储区域（不同的数据类型，占用的空间大小不一样）\n2. 该区域有自己的名称和类型\n3. 变量必须先声明，后使用\n4. 该区域的数据可以在同一类型范围内不断变化\n5. 变量在同一个作用域内不能重名\n6. 变量三要素(变量名+值+数据类型)，这一点请大家注意。\n\n## 2.2 数据类型\n\n* 基本类型\n  * 数值类型\n    * 整型\n      * short短整型\n      * int整形\n      * long长整型\n    * 浮点数\n      * float单精度\n      * double双精度\n  * char字符类型\n* 构造类型\n  * 数组\n  * 结构体struct\n  * 共用体union\n  * 枚举类型enum\n* 指针类型\n* 空类型void\n\n> 在c中，没有字符串类型,使用字符数组表示字符串\n>\n> 在不同系统上，部分数据类型字节长度不一样，int 2 或者 4个字节\n\n## 2.3 整数类型\n\n如\n\n~~~ C\n#include <stdio.h>\nint main(){\n    int num = 3;\n    printf(\"num=%d\", num);\n    return(0);\n}\n~~~\n\n| 类型               | 存储大小    | 值范围                                                       |\n| ------------------ | ----------- | ------------------------------------------------------------ |\n| char               | 1字节       | -128 即 -(2^7)  到 127(2^7 -1)                               |\n| unsigned char      | 1 字节      | 0 到 255 (2^8 - 1)                                           |\n| signed char        | 1 字节      | -128 即-(2^7) 到 127 (2^7-1)                                 |\n| int signed int     | 2 或 4 字节 | -32,768 (- 2^15 ) 到 32,767 (2^15-1) 或 -2,147,483,648 (- 2^31) 到 2,147,483,647 (2^31 -1) |\n| unsigned int       | 2 或 4 字节 | 0 到 65,535 (2^16-1) 或 0 到 4,294,967,295 (2^32 -1)         |\n| short signed short | 2 字节      | -32,768 (- 2^15)到 32,767 (2^15 -1)                          |\n| unsigned short     | 2 字节      | 0 到 65,535 (2^16 - 1)                                       |\n| long signed long   | 4 字节      | -2,147,483,648 (- 2^31) 到 2,147,483,647 (2^31 - 1)          |\n| unsigned long      | 4 字节      | 0 到 4,294,967,295 (2^32 - 1)                                |\n\n* 使用细节\n  1. **各种类型的存储大小与操作系统、系统位数和编译器有关**，目前通用的以 64 位系统为主。 \n  2. C 语言的整型类型，分为有符号 signed 和无符号 unsigned 两种， 默认是 signed。\n  3. C 程序中整型常声明为 int 型，除非不足以表示大数，才使用 long long\n  4. bit(位): 计算机中的最小存储单位。 byte(字节):计算机中基本存储单元。  \n\n## 2.4 浮点类型\n\n如\n\n~~~ c\n#include <stdio.h>\n \nint main()\n{\n    double salary = 10000.56;\n    double num1 = 1.3;\n    double num2 = 4.5;\n    double sum = num1 + num2;\n    printf(\"sum = %.2f \\n\" , sum);\n    printf(\"sum = %f\" , sum);\n    return(0);\n}\n\nsum = 5.80 \nsum = 5.800000\n~~~\n\n|     类型      | 存储大小 |        值范围        |   精度    |\n| :-----------: | :------: | :------------------: | :-------: |\n| float 单精度  |  4 字节  |  1.2E-38 到 3.4E+38  | 6 位小数  |\n| double 双精度 |  8 字节  | 2.3E-308 到 1.7E+308 | 15 位小数 |\n\n* 注意\n  1. 关于浮点数在机器中存放形式的简单说明，浮点数 = 符号位 + 指数位 + 尾数位，浮点数是近似值。\n  2. 尾数部分可能丢失，造成精度损失。\n* 使用细节\n  1. 浮点型常量默认为 double 型，声明 float 型常量时，须后加‘f’ 或‘F’ 。\n  2. 浮点型常量有两种表示形式\n     1. 十进制数形式： 如：5.12、512.0f、.512 (必须有小数点）\n     2. 科学计数法形式：如：5.12e2、5.12E-2\n  3. 通常情况下，应该使用 double 型，因为它比 float 型更精确。\n  4. printf(\"d1=%f \", d1);  // 在输出时，默认保留 小数点 6 位。\n\n~~~ cint main()\nint main(){\n    //浮点型常量默认为 double 型 ， 声明 float 型常量时， 须后加‘f’ 或‘F’\n    float d1 = 1.18909095; //从“double” 到“float” 截断, 1.1 是 double\n    float d2 = 1.1f; // 1.1f 就是 float\n    double d3 = 1.3; // ok\n    double d4 = 5.12;\n    double d5 = .512; // 等价 0.512\n    double d6 = 5.12e2; //等价 5.12 * (10^2) = 512\n    double d7 = 5.12e-2; // 等价 5.12 * (10^-2) = 5.12 / 100 = 0.0512\n    //在输出时， 如果%f 默认保留小数点 6 位\n    printf(\"d1=%.15f d2=%f d3=%f d4=%f d5=%f d6=%f d7=%f\", d1,d2,d3,d4,d5,d6,d7);\n    return(0);\n}\n\nd1=1.189090967178345 d2=1.100000 d3=1.300000 d4=5.120000 d5=0.512000 d6=512.000000 d7=0.051200\n~~~\n\n## 2.5 字符类型\n\n* 字符类型可以表示单个字符，字符类型是 char，char 是 1 个字节(可以存字母或者数字)\n* 多个字符称为字符串，在C 语言中 使用 char 数组 表示，数组不是基本数据类型，而是构造类型。\n\n如\n\n~~~ c\nint main(){\n    char c1 = 'A';\n    char c2 = '0';\n    char c3 = '\\t';\n    printf(\"c1=%c c3=%c c2=%c\", c1, c3, c2); // %c 表示以字符的形式输出\n    return(0);\n}\n\nc1=A c3=\t c2=0\n~~~\n\n* 使用细节\n  1. 字符常量是用单引号括起来的单个字符。 例如：char c1 = 'a'; char c3 = '9';  \n  2. C 中还允许使用转义字符‘\\’ 来将其后的字符转变为特殊字符型常量。例如：char c3 = ‘\\n’ ; // '\\n'表示换行符\n  3. 在 C 中，char 的本质是一个整数，在输出时，是 ASCII 码对应的字符。\n  4. 可以直接给 char 赋一个整数，然后输出时，会按照对应的 ASCII 字符输出 [97]。\n  5. char 类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码。\n\n~~~ c\nint main(){\n    char c1 = 'a';\n    char c2 = 'b';\n    //这时当我们以 %c 输出时，就会按照 ASCII 编码表(理解 字符 <==> 数字 对应关系 ) 对应的 97 对应字符输出\n    char c3 = 97;\n    int num = c2 + 10; // 98 + 10 = 108\n    \n    printf(\"c1=%c c2=%c c3=%c \\n\", c1, c2, c3); // c3= 'a'\n    printf(\"num=%d\", num); // 108\n    return(0);\n}\n\nc1=a c2=b c3=a \nnum=108 \n~~~\n\n## 2.6 布尔类型\n\n* C 语言标准(C89)没有定义布尔类型，所以 C 语言判断真假时以 0 为假，非 0 为真。\n* 但这种做法不直观，所以我们可以借助 C 语言的宏定义。\n\n> C 语言标准(C99)提供了 _Bool 型， _Bool 仍是整数类型， 但与一般整型不同的是， _Bool 变量只能赋值为 0 或 1，非 0 的值都会被存储为 1。\n>\n> _ C99 还提供了一个头文件 <stdbool.h> 定义了 bool 代表_Bool，true 代表 1，false 代表 0。只要导入 stdbool.h，就能方便的操作布尔类型了 , 比如 bool flag = false;\n\n~~~ c\n //宏定义\n#define BOOL int\n#define TURE 1\n#define FALSE 0\n \nint main(){\n    int isPass = -1;\n    //定义一个布尔变量\n    BOOL isOk = TURE; // 等价 int isOK = 0\n    if(isPass) { // 0 表示假， 非 0 表示真\n        printf(\"通过考试\");\n    }\n    if(isOk) {\n        printf(\"ok\");\n    }\n    return(0);\n}\n~~~\n\n## 2.7 基本类型转换\n\n当 C 程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转\n换。  \n\n**数据类型按精度(容量)大小排序（从低到高）：**\n\n1. short\n2. int\n3. unsigned int\n4. long\n5. unsigned long\n6. float\n7. double\n8. long double\n\n**自动转换表**\n\n~~~ mermaid\nflowchart LR\n\nA[Char, short] --> B(int)\nB --> C[unsigned]\nC --> D[long]\nD --> E[double]\nF[float] --> E[double]\n~~~\n\n* 细节说明\n  1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度最大的那种数据类型，然后再进行计算（如int 型 和 short 型 运算时，先把 short 转成 int 型后再进行运算）。\n  2. 若两种类型的字节数不同，转换成字节数大的类型，若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型。\n  3. 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边的类型将转换为左边的类型， 如果右边变量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按四舍五入向前舍入。\n\n~~~ c\nint main(){\n    //举例 1\n    char c1 = 'a';\n    int num1 = c1; // ok\n    double d1 = num1; // ok\n    printf(\"d1=%f \\n\", d1);\n    //ok\n    //举例 2\n    short s1 = 10;\n    int num2 = 20;\n    int num3 = s1 + num2; //ok\n    printf(\"num3=%d \\n\", num3);\n    //举例 3\n    float f1 = 1.1f; //ok\n    double d2 = 4.58667435;\n    f1 = d2; // 出现精度损失 (double -> float )\n    printf(\"f1=%.8f\", f1); // 期望： 4.58667435\n\n    return(0);\n}\n\nd1=97.000000 \nnum3=30 \nf1=4.58667421\n~~~\n\n## 2.8 强制类型转换\n\n将**精度高**的数据类型转换为**精度小**的数据类型。 使用时要加上**强制转换符 ( )**，但可能造成精度降低或溢出，格外要注意。  \n\n~~~ c\nint main(){\n    double d1 = 1.934;\n    int num = (int) d1; //这里注意， 不是进行四舍五入， 而是直接截断小数后的部分\n    printf(\"\\n num=%d d1=%f\" , num, d1); // d1 仍然是 double\n    \n    // 强制转换只对最近的数有效, 如果希望针对更多的表达式转换， 使用（）\n    // int num2 = (int) 3.5 * 10 + 6 * 1.5; // 3 * 10 + 6 * 1.5 = 30 + 9.0 = 39.0\n    int num3 = (int) (3.5 * 10 + 6 * 1.5); // 35.0 + 9.0 = 44.0 -> int = 44\n    printf(\"\\n num3=%d\", num3); // num3 = 44\n    \n    return(0);\n}\n\nnum=1 d1=1.934000\nnum3=44\n~~~\n\n* 注意\n  1. 当进行数据的从 精度高 ——> 精度低，就需要使用到强制转换。\n  2. 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级。\n\n~~~ c\nchar c = 'a';\nint i = 5;\nfloat d = .314F;\ndouble d2 = 1.0;\ndouble result = c+i+d; // c+i+d 类型是 float -> double ok\nchar result = c+i+d+d2; // 提示? // 警告 double -> char\n~~~\n\n## 2.9 指针入门\n\n指针表示一个地址（存放的是地址）。\n\n~~~ c\nint main(){\n    int num = 1;\n    //定义一个指针变量， 指针\n    // 1. int * 表示类型为 指针类型\n    // 2. 名称 ptr , ptr 就是一个 int * 类型\n    // 3. ptr 指向了一个 int 类型的变量的地址\n    int *ptr = &num;\n    // num 的地址是多少\n    // 说明 1：如果要输出一个变量的地址， 使用格式是 %p\n    // 说明 2: &num 表示取出 num 这个变量对应地址\n    printf(\"\\n num的值=%d num的地址=%p\", num, &num);\n    // 1.指针变量，本身也有地址 &ptr\n    // 2.指针变量, 存放的地址 ptr\n    // 3.获取指针指向的值 *ptr\n    printf(\"\\n ptr的地址是 %p ptr存放的值是一个地址为 %p ptr 指向的值=%d\", &ptr, ptr, *ptr);\n\n    return(0);\n}\n~~~\n\n简单来说：\n\n~~~ markdown\nint num = 1;  // 定义了一个值\nint *ptr = &num;  // 定义了一个指针，指针存放的是 num的地址\n\n&ptr 表示 ptr这个指针本身的地址\nptr  表示 ptr这个变量存放的那个地址值，也就是num的地址\n*ptr 表示 ptr存放的地址值上，对应的值，也就是num的值\n\n输出格式：\n像输出地址，格式为 %p\n像输出数值，格式和数值格式一样，%d等。\n~~~\n\n* 细节说明\n  1. 基本类型，都有对应的指针类型，形式为 数据类型 *，比如 int 的对应的指针就是 int *, float 对应的指针类型就是 float * ，依次类推。\n  2. 此外还有**指向数组的指针**、**指向结构体的指针**，**指向共用体的指针**， (二级指针， 多级指针)。  \n\n## 2.10 值传递和地址传递\n\nC 语言传递参数（或者赋值）可以是值传递（pass by value），也可以传递指针（a pointer passed by value），传递指针也叫地址传递。  \n\n1. 默认传递值的类型： **基本数据类型 (整型类型、 小数类型， 字符类型), 结构体, 共用体**。\n2. 默认传递地址的类似： 指针、 数组。\n\n* 特点\n  * 值传递：将变量指向的存储内容， 在传递/赋值时，拷贝一份给接收变量。\n  * 地址传递 也叫 指针传递：如果是指针，就将指针变量存储的地址，传递给接收变量，如果是数组， 就将数组的首地址传递给接收变量。\n\n# 3. 常量\n\n* 常量是**固定值**， 在程序执行期间不能改变。 这些固定的值， 又叫做**字面量**。\n* 常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。\n* 常量的值在定义后不能进行修改。\n\n## 3.1 经常使用的常量\n\n**整数常量**\n\n整数常量可以是十进制、 八进制或十六进制的常量。 \n\n前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 \n\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合， U 表示无符号整数（unsigned） ， L 表示长整数（long） 。 后缀可以是大写， 也可以是小写， U 和 L 的顺序任意。\n\n~~~ markdown\n85      /* 十进制 */\n0213 \t/* 八进制 */\n0x4b \t/* 十六进制 */ 八进制和十六进制后面解释\n30 \t\t/* 整数 */\n30u \t/* 无符号整数 */\n30l \t/* 长整数 */\n30ul \t/* 无符号长整数 */\n~~~\n\n**浮点常量**\n\n浮点常量由整数部分、 小数点、 小数部分和指数部分组成。 您可以使用小数形式或者指数形式来表示浮点常量。\n\n~~~ markdown\n3.14159; \t//double 常量\n314159E-5; \t// 科学计数法\n3.1f; \t\t//float 常量\n~~~\n\n**字符常量**\n\n字符常量是括在单引号中，例如，'x' 可以存储在 char 类型的变量中。字符常量可以是一个普通的字符（例如'x'）、一个转义序列（例如 '\\t'）。\n\n~~~ markdown\n'X'\n'Y'\n'A'\n'b'\n'1'\n'\\t'\n~~~\n\n**字符串常量**\n\n字符串字面值或常量是括在双引号 \"\" 中的。 一个字符串包含类似于字符常量的字符： 普通的字符、 转义序列和通用的字符。 可以使用空格做分隔符， 把一个很长的字符串常量进行分行。\n\n~~~ markdown\n\"hello, world\"\n\"北京\"\n\"hello \\\nworld\"\n~~~\n\n## 3.2 常量的定义\n\n* 方式一\n  * 使用 #define 预处理器。\n* 方式二\n  * 使用 const 关键字。\n\n~~~ c\n#define PI 3.14 //定义常量 PI 常量值 3.14\n\nint main() {\n    // PI = 3.1415 可以吗?=》 不可以修改， 因为 PI 是常量\n    // 可以修改 PI 值?\n    // PI = 3.1415; // 提示 = 左值 必须是可修改的值\n    double area;\n    double r = 1.2;//半径\n    area = PI * r * r;\n    printf(\"面积 : %.2f\", area);\n    getchar();\n    return 0;\n}\n\n面积 : 4.52\n~~~\n\n~~~ c\n//1. const 是一个关键字，规定好，表示后面定义了一个常量\n//2. PI 是常量名，即是一个常量，常量值就是 3.14\n//3. PI 因为是常量，因此不可以修改\n//4. const 定义常量时，需要加 分号\nconst double PI = 3.14;\n\nint main() {\n    //PI = 3.1415 可以吗? => 不可以\n    double area;\n    double r = 1.2;\n    area = PI * r * r;\n    printf(\"面积 : %.2f\", area);\n    getchar();\n    return 0;\n}\n~~~\n\n* const 和 #define 的区别\n  1. const 定义的常量时，带类型，define 不带类型。\n  2. const 是在 编译、运行的时候起作用，而 define 是在编译的预处理阶段起作用。\n  3. define 只是简单的替换，没有类型检查。简单的字符串替换会导致边界效应。\n  4. const 常量可以进行调试的，define 是不能进行调试的，主要是预编译阶段就已经替换掉了， 调试的时候就没它了。\n  5. const 不能重定义，不可以定义两个一样的，而 define 通过 undef 取消某个符号的定义，再重新定义。\n  6. define 可以配合#ifdef、#ifndef、#endif 来使用，可以让代码更加灵活，比如我们可以通过#define 来 启动或者关闭 调试信息。  \n\n~~~ c\n#define A 1\n#define B (A+3) //\n#define C A/B*3 //\n\n// const不能重定义，不可以定义两个一样的，而define通过undef取消某个符号的定义，再重新定义\nconst double PI=3.14;\n// const double PI=3.145;  // 错误\n\n#define PI2 3.14\n#undef PI2 // 取消 PI2 的定义\n#define PI2 3.145\n\nvoid main() {\n    // 分析过程\n    // #define 就是一个简单的替换!!!\n    // C 其实是 A/A+3*3 = 1/1 + 3 * 3 = 1 + 9 = 10\n    // C 其实是 A/(A+3)*3 = 1/(1+3) * 3 = 1/4 *3 = ?\n    double d1 = 1.0/4 *3 ; // 0.25 * 3 = 0.75\n    printf(\"\\nc=%.2f\", C);// 问 c = ?\n    printf(\"\\nd1=%.2f\", d1);\n}\n\nc=0.00\nd1=0.75\n~~~\n\n~~~ c\n// #define DEBUG\nint main() {\n    #ifdef DEBUG //如果定义过 DEBUF\n    \tprintf(\"ok, 调试信息\");\n    #endif\n    #ifndef DEBUG //如果没有定义过 DEBUF\n    \tprintf(\"hello, 另外的信息\");\n    #endif\n    return 0;\n}\n~~~\n\n# 4. 运算符\n\n## 4.1 算术运算符\n\n算术运算符是对数值类型的变量进行运算的， 在 C 程序中使用的非常多。\n\n| 运算符 | 运算 |           实例            |        结果         |\n| :----: | :--: | :-----------------------: | :-----------------: |\n|   +    |  加  |                           |                     |\n|   -    |  减  |                           |                     |\n|   *    |  乘  |                           |                     |\n|   /    |  除  |                           |                     |\n|   %    | 取余 |                           |                     |\n|   ++   |      | a=2;b=++a;<br/>a=2;b=a++; | a=3;b=3<br/>a=3;b=2 |\n|   --   |      | a=2;b=--a;<br/>a=2;b=a--; | a=1;b=1<br/>a=1;b=2 |\n\n* 细节说明\n  1. 对于除号“/” ， 它的整数除和小数除是有区别的： 整数之间做除法时， 只保留整数部分而舍弃小数部分。 例如： int x= 10/3 ,结果是 3。如果想要保留小数，参与运算数必须有浮点数。\n  2. 当对一个数取模时， 可以等价 a%b=a-a/b*b ， 这样我们可以看到 取模的一个本质运算。  \n  3. 当 自增 当做一个 表达式使用时 j = ++i 等价 i = i + 1; j = i;  \n  4. 当 自增 当做一个 表达式使用时 j = i++ 等价 j = i; i = i + 1;  \n\n~~~ c\n//处理的流程 10 / 4 = 2.5 == 截取整数 ==> 2 => 2.00000\ndouble d1 = 10 / 4; //\ndouble d2 = 10.0 / 4; //如果希望保留小数， 参与运算数必须有浮点数\n\nint res1 = 10 % 3; // 求 10/3 的余数 1\nint res2 = -10 % 3; // = -10 - (-10) / 3 * 3 = -10- (-3) * 3 = -10 + 9 = -1\nint res3 = 10 % -3; // 10 - 10 / (-3) * (-3) = 10 - 9 = 1\nint res4 = -10 % -3; // ? -1\n~~~\n\n## 4.2 关系运算符\n\n结果只有 false 和 非0\n\n~~~ markdown\n== 等于\n!= 不等于\n< 小于\n> 大于\n<= 小于等于\n>= 大于等于\n~~~\n\n## 4.3 逻辑运算符\n\n用于连接多个条件（一般来讲就是关系表达式），最终的结果要么是真(非 0 表示)，要么是假(0 表示) 。  \n\n~~~ markdown\n&&\n||\n!\n~~~\n\n> 在进行 && 操作时, 如果第一个条件为 false ,则后面的条件不在判断；\n>\n> 该现象称为 短路现象， 所以 逻辑与 也称为 短路逻辑与。\n\n## 4.4 赋值运算符\n\n赋值运算符就是将某个运算后的值， 赋给指定的变量。\n\n| 运算符 |       描述       |        效果        |\n| :----: | :--------------: | :----------------: |\n|   +=   |                  |                    |\n|   -=   |                  |                    |\n|   *=   |                  |                    |\n|   /=   |                  |                    |\n|   %=   |                  |                    |\n|  <<=   |                  |                    |\n|  >>=   |                  |                    |\n|   &=   |  按位与之后赋值  |  C&=2 等同于C=C&2  |\n|   ^=   | 按位异或之后赋值 |  C^=2 等同于C=C^2  |\n|  \\|=   |  按位或之后赋值  | C\\|=2 等同于C=C\\|2 |\n\n## 4.5 位运算符\n\n位运算符作用于位，并逐位执行操作。\n\n~~~ markdown\n& 按位与\n| 按位或\n^ 按位异或，不一样为1，一样为0\n~ 按照二进制取反\n<< 左移，右边补0\n>> 右移，正数左边补0，负数左边补1。也可以直接认为左边补的就是符号位。\n~~~\n\n## 4.6 三元运算符\n\n~~~ markdown\n条件表达式 ? 表达式 1: 表达式 2;\n\n如果条件表达式为非 0 (真)， 运算后的结果是表达式 1；\n如果条件表达式为 0 (假)， 运算后的结果是表达式 2；\n~~~\n\n* 注意细节\n  1. 表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换), 否则会有精度损失。\n  2. 三元运算符可以转成 if--else 语句。\n\n## 4.7 运算符优先级\n\n| **优先级** | **运算符** |  **名称或含义**  |       **使用形式**        | **结合方向** |  **说明**  |\n| :--------: | :--------: | :--------------: | :-----------------------: | :----------: | :--------: |\n|     1      |     []     |     数组下标     |    数组名[常量表达式]     |    左到右    |            |\n|            |     ()     |      圆括号      | (表达式)   函数名(形参表) |              |            |\n|            |     .      | 成员选择（对象） |        对象.成员名        |              |            |\n|            |     ->     | 成员选择（指针） |     对象指针->成员名      |              |            |\n|     2      |     -      |    负号运算符    |          -表达式          |    右到左    | 单目运算符 |\n|            |   (类型)   |   强制类型转换   |     (数据类型)表达式      |              |            |\n|            |     ++     |    自增运算符    |    ++变量名   变量名++    |              | 单目运算符 |\n|            |     --     |    自减运算符    |    --变量名   变量名--    |              | 单目运算符 |\n|            |     *      |    取值运算符    |         *指针变量         |              | 单目运算符 |\n|            |     &      |   取地址运算符   |          &变量名          |              | 单目运算符 |\n|            |     !      |   逻辑非运算符   |          !表达式          |              | 单目运算符 |\n|            |     ~      |  按位取反运算符  |          ~表达式          |              | 单目运算符 |\n|            |   sizeof   |    长度运算符    |      sizeof(表达式)       |              |            |\n|     3      |     /      |        除        |      表达式 / 表达式      |    左到右    | 双目运算符 |\n|            |     *      |        乘        |       表达式*表达式       |              | 双目运算符 |\n|            |     %      |   余数（取模）   |   整型表达式%整型表达式   |              | 双目运算符 |\n|     4      |     +      |        加        |       表达式+表达式       |    左到右    | 双目运算符 |\n|            |     -      |        减        |       表达式-表达式       |              | 双目运算符 |\n|     5      |     <<     |       左移       |       变量<<表达式        |    左到右    | 双目运算符 |\n|            |     >>     |       右移       |       变量>>表达式        |              | 双目运算符 |\n|     6      |     >      |       大于       |       表达式>表达式       |    左到右    | 双目运算符 |\n|            |     >=     |     大于等于     |      表达式>=表达式       |              | 双目运算符 |\n|            |     <      |       小于       |       表达式<表达式       |              | 双目运算符 |\n|            |     <=     |     小于等于     |      表达式<=表达式       |              | 双目运算符 |\n|     7      |     ==     |       等于       |      表达式==表达式       |    左到右    | 双目运算符 |\n|            |     !=     |      不等于      |      表达式!= 表达式      |              | 双目运算符 |\n|     8      |     &      |      按位与      |       表达式&表达式       |    左到右    | 双目运算符 |\n|     9      |     ^      |     按位异或     |       表达式^表达式       |    左到右    | 双目运算符 |\n|     10     |     \\|     |      按位或      |      表达式\\|表达式       |    左到右    | 双目运算符 |\n|     11     |     &&     |      逻辑与      |      表达式&&表达式       |    左到右    | 双目运算符 |\n|     12     |    \\|\\|    |      逻辑或      |     表达式\\|\\|表达式      |    左到右    | 双目运算符 |\n|     13     |     ?:     |    条件运算符    | 表达式1? 表达式2: 表达式3 |    右到左    | 三目运算符 |\n|     14     |     =      |    赋值运算符    |        变量=表达式        |    右到左    |            |\n|            |     /=     |     除后赋值     |       变量/=表达式        |              |            |\n|            |     *=     |     乘后赋值     |       变量*=表达式        |              |            |\n|            |     %=     |    取模后赋值    |       变量%=表达式        |              |            |\n|            |     +=     |     加后赋值     |       变量+=表达式        |              |            |\n|            |     -=     |     减后赋值     |       变量-=表达式        |              |            |\n|            |    <<=     |    左移后赋值    |       变量<<=表达式       |              |            |\n|            |    >>=     |    右移后赋值    |       变量>>=表达式       |              |            |\n|            |     &=     |   按位与后赋值   |       变量&=表达式        |              |            |\n|            |     ^=     |  按位异或后赋值  |       变量^=表达式        |              |            |\n|            |    \\|=     |   按位或后赋值   |       变量\\|=表达式       |              |            |\n|     15     |     ,      |    逗号运算符    |      表达式,表达式,…      |    左到右    |            |\n\n> 算术运算符 > 关系运算符 > 逻辑运算符(逻辑非! 除外) > 赋值运算符 > 逗号运算符  \n\n## 4.8 表示符名命规范\n\nC 语言 对各种变量、函数等命名时使用的字符序列称为标识符。\n\n凡是自己可以起名字的地方都叫标识符。\n\n* 命名规则\n  1. 由 26 个英文字母大小写， 0-9 ， _或 $ 组成。\n  2. 数字不可以开头。\n  3. 不可以使用关键字和保留字，但能包含关键字和保留字。\n  4. C 语言中严格区分大小写， 长度无限制。\n  5. 标识符不能包含空格。\n\n* 规范\n  1. 程序中不得出现仅靠大小写区分的相似的标识符\n  2. 所有宏定义、 枚举常数、 常量(只读变量)全用大写字母命名， 用下划线分隔单词\n  3. 定义变量别忘了初始化。 定义变量时编译器并不一定清空了这块内存，它的值可能是无效的数据，运行程序，会异常退出。\n  4. 变量名、函数名：多单词组成时，第一个单词首字母小写， 第二个单词开始每个单词首字母大写。小驼峰。\n\n## 4.9 关键字\n\n被C语言用作特殊用途的字符串\n\n~~~ markdown\nauto、break、case、char、const、continue、default、do、\ndouble、else、enum、extern、float、for、goto、if、\nint、long、register、return、short、signed、sizeof、static、\nstruct、switch、typedef、union、unsigned、void、volatile、while\n~~~\n\nC99标准中有增加了5个\n\n~~~ markdown\ninline、retrict、_Bool、_Complex、_Imaginary\n~~~\n\nC11标准中新增了7个\n\n~~~ markdown\n_Alignas、_Alignof、_Atomic、_Static_assert、_Noreturn、\n_Thread_local、_Generic\n~~~\n\n## 4.10 键盘输入语句\n\n步骤\n\n1. include <stdio.h> \n2. 使用 scanf 函数\n3. 使用适当的格式接收\n\n~~~ c\n#include <stdio.h>\n\nvoid main() {\n    //使用字符数组接收名\n    char name[10] = \"\";\n    int age = 0;\n    double sal = 0.0;\n    char gender = ' ';\n    \n    // 提示用户输入信息\n    printf(\"请输入名字： \");\n    // scanf(\"%s\", name) 表示接收 一个字符串， 存放到 name 字符数组\n    scanf(\"%s\", name);\n    \n    printf(\"请输入年龄： \");\n    scanf(\"%d\", &age); // 因为我们将得到输入存放到 age 变量指向地址,因此需要加 &\n    \n    printf(\"请输入薪水： \");\n    scanf(\"%lf\", &sal); // 接收一个 double 时， 格式参数 %lf\n    \n    printf(\"请输入性别(m/f)： \");\n    scanf(\"%c\", &gender); // 这里是接收到了上面的回车字符\n    scanf(\"%c\", &gender); // 等待用户输入.\n    //输 出得到信息\n    printf(\"\\nname %s age %d sal %.2f gender %c\", name, age,sal,gender);\n    getchar(); // 接收到一个回车\n    getchar(); // 这个 getchar() 才会让控制台暂停\n}\n~~~\n\n# 5. 二进制和位运算\n\n## 5.1 进制\n\n~~~ c\nint num2 = 210;     \t// 十进制\nint num3 = 01010; \t\t// 八进制\nint num4 = 0x1010;\t\t// 十六进制\n~~~\n\n## 5.2 位运算\n\n~~~ c\n#define DEBUG\nint main() {\n    int a = 1>>2; // 1 向右位移 2 位 , 这里还涉及到二进制中 原码， 反码， 补码\n    int b = -1>>2;\n    int c = 1<<2;\n    int d = -1<<2;\n    // a,b,c,d,e 结果是多少\n    printf(\"a=%d b=%d c=%d d=%d \",a,b,c,d);\n    return 0;\n}\n\n标准输出：a=0 b=-1 c=4 d=-4 \n~~~\n\n>二进制最高位 表示符号位。0表示正，1表示负。\n>\n>原码：正数 0000 1111、0000 0001、负数 1000 0001、1000 1111\n>\n>反码：         0000 1111、0000 0001、         1111 1110、1111 0000\n>\n>补码：         0000 1111、0000 0001、         1111 1111、1111 0001（就是反码+1）\n>\n>计算机中存储的都是补码。没有原码和反码，移动的也都是补码。\n>\n>对于正数好理解、就按照原码移动理解就好了。\n>\n>对于负数，比如-1，补码是 1111 1111，除去符号位剩下 111 1111，不管右移几位，左边都要补上1，最后加上符号位还是 1111 1111，对应的数还是-1.所以 -1不管左移几位都还是 -1。\n>\n>**计算按位与 按位或等 都是这样的逻辑，用反码算。**\n\n# 6. 程序与流程控制\n\n* 顺序控制\n* 分支控制\n* 循环控制\n\n## 6.1 if 分支控制\n\n~~~ c\nif(条件表达式){\n    // 这是单分支语句\n}\n~~~\n\n~~~ c\nif(条件表达式){\n    // 分支1\n} else {\n    // 分支2\n}\n~~~\n\n~~~ c\nif(条件表达式1){\n    // 分支1\n} else if(条件表达式2){\n    // 分支2\n} else if(条件表达式3){\n    // 分支3\n}\n...\nelse {\n    // 分支n\n}\n~~~\n\n## 6.2 switch 分支结构\n\n~~~ c\nswitch(表达式){\n    case 常量1:\n        语句块1;\n        break;\n    case 常量2:\n        语句块2;\n        break;\n    case 常量3:\n        语句块3;\n        break;\n    case 常量4:\n        语句块4;\n        break;\n    default:\n        default语句块1;\n        break;\n}\n~~~\n\n* 细节\n  1. switch 语句中的 expression 是一个常量表达式， 必须是一个**整型(char、 short, int, long 等) 或枚举类型**。\n  2. case 子句中的值必须是常量，而不能是变量。\n  3. default 子句是可选的，当没有匹配的 case 时，执行 default。\n  4. break 语句用来在执行完一个 case 分支后使程序跳出 switch 语句块。\n  5. 如果没有写 break，会执行下一个 case 语句块，直到遇到 break 或者执行到 switch 结尾，这个现象称为穿透。\n\n## 6.3 for循环控制\n\n~~~ c\n\nfor(int i = 1;i <= 5;i++){\n\tprintf(\"hello world, i=%d\", i);\n}\n~~~\n\n* 使用细节\n  1. 循环条件是 返回一个表示真(非 0)假(0) 的表达式。\n  2. **for(;循环判断条件;)**中的初始化和变量迭代可以不写（写到其它地方），但是两边的分号不能省略。\n  3. 循环初始值可以有多条初始化语句， 但要求类型一样， 并且中间用逗号隔开， 循环变量迭代也可以有多条变量迭代语句， 中间用逗号隔开。  **for(i = 0, j = 0; j < count; i++, j += 2)**\n\n## 6.4 while循环控制\n\n~~~ c\nint i = 1;\nwhile(i < 5){\n    printf(\"hello world, i=%d\", i);\n    i++;\n}\n~~~\n\n## 6.5 do...while循环控制\n\n~~~ c\nint i = 1; //循环变量初始化\nint max = 5; //循环的最大次数\ndo {\n    printf(\"\\n hello，world i=%d\", i); //循环体\n    i++; //循环变量迭代\n}while(i <= max); // 循环条件 后面有一个分号，不能省略.\n~~~\n\n## 6.6 跳转控制语句break\n\n结束循环。\n\n## 6.7 跳转控制语句continue\n\n结束本轮循环。直接开始下一轮循环。**只能配合循环语言使用，不能单独和 switch/if 使用**。  \n\n## 6.8 跳转控制语句goto\n\n1. C 语言的 goto 语句可以无条件地转移到程序中指定的行。\n2. goto 语句通常与条件语句配合使用。可用来实现条件转移，跳出循环体等功能。\n3. 在 C 程序设计中一般不主张使用 goto 语句，以免造成程序流程的混乱，使理解和调试程序都产生困难。\n\n~~~ c\ngoto lable1; //lable1 称为标签\nprintf(\"ok1\\n\");\nprintf(\"ok2\\n\");\nlable1:\nprintf(\"ok3\\n\");\nprintf(\"ok4\\n\");\n~~~\n\n## 6.9 跳转控制语句return\n\nreturn 使用在函数，表示跳出所在的函数。\n\n# 7. 枚举\n\n举个例子， 比如： 一星期有 7 天， 请定义数据表示星期一到星期天. \n\n~~~ c\n// 方式1\n#define MON 1\n#define TUE 2\n#define WED 3\n#define THU 4\n#define FRI 5\n#define SAT 6\n#define SUN 7\n~~~\n\n## 7.1 基本介绍\n\n1. 枚举是 C 语言中的一种构造数据类型，它可以让数据更简洁，更易读, 对于只有几个有限的特定数据，可以使用枚举。\n2. 枚举对应英文(enumeration, 简写 enum)。\n3. 枚举是一组常量的集合，包含一组有限的特定的数据。\n4. 枚举语法定义格式为：`enum 枚举名 {枚举元素1,枚举元素2,……};  `\n\n~~~ c\nint main() {\n    enum DAY{\n        MON=1, TUE=2, WED=3, THU=4, FRI=5, SAT=6, SUN=7\n    }; // 这里 DAY 就是枚举类型, 包含了 7 个枚举元素\n    enum DAY day; // enum DAY 是枚举类型， day 就是枚举变量\n    day = WED; //给枚举变量 day 赋值， 值就是某个枚举元素\n    printf(\"%d\", day); // 3 ， 每个枚举元素对应一个值\n    return 0;\n}\n~~~\n\n## 7.2 枚举的遍历\n\nC 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，枚举类型必须连续是可以实现有条件的遍历。\n\n以下实例使用 for 来遍历枚举的元素\n\n~~~ c\n// 遍历枚举元素\n// day++ 会给出警告， 但是可以运行\nfor (day = MON; day <= SUN; day++) { // 要求枚举元素是连续赋值\n    printf(\"枚举元素： %d \\n\", day);\n}\n~~~\n\n## 7.3 switch 中使用枚举  \n\n~~~ c\nint main() {\n    enum SEASONS {SPRING=1, SUMMER, AUTUMN, WINTER}; //定义枚举类型 enum SEASONS\n    enum SEASONS season;//定义了一个枚举类型变量 season(类型 enum SEASONS )\n    printf(\"请输入你喜欢的季节: (1. spring, 2. summer, 3. autumn 4. winter): \");\n    scanf(\"%d\", &season);\n    switch (season) {\n        case SPRING:\n            printf(\"你喜欢的季节是春天\");\n            break;\n        case SUMMER:\n            printf(\"你喜欢的季节是夏天\");\n            break;\n        case AUTUMN:\n            printf(\"你喜欢的季节是秋天\");\n            break;\n        case WINTER:\n            printf(\"你喜欢的季节是冬天\");\n            break;\n        default:\n            printf(\"你没有选择你喜欢的季节\");\n    }\n    return 0;\n}\n~~~\n\n* 使用细节\n\n  1. 第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。 我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。\n\n  2. 在定义枚举类型时改变枚举元素的值\n\n     ~~~ c\n     enum DAY {\n     MON, TUE, WED, THU=9, FRI, SAT, SUN // 如果没有给赋值， 就会按照顺序赋值\n     } day; // 表示 定义了一个枚举类型 enum Day ,同时定义了一个变量 day(类型是 enum DAY)\n     // 说明 FRI, SAT, SUN 就是 10, 11, 12\n     ~~~\n\n  3. 枚举类型的 三种定义方式。\n\n     1. ~~~ c\n        enum DAY {\n        \tMON=1, TUE, WED, THU, FRI, SAT, SUN\n        };\n        enum DAY day;\n        ~~~\n\n     2. ~~~ c\n        enum DAY {\n        \tMON=1, TUE, WED, THU, FRI, SAT, SUN\n        } day;\n        ~~~\n\n     3. ~~~ c\n        enum {\n        \tMON=1, TUE, WED, THU, FRI, SAT, SUN\n        } day; // 这样使用枚举， 该枚举类型只能使用一次.\n        ~~~\n\n  4. 不能直接将一个整数，赋给枚举变量，但是可以将整数，转成枚举类型，再赋给枚举变量.  \n\n     ~~~ c\n     enum SEASONS {SPRING=1, SUMMER, AUTUMN, WINTER};\n     enum SEASONS season;\n     int n = 4;\n     season = (enum SEASONS) n;\n     printf(\"season=:%d\",season);\n     \n     标准输出：season=:4\n     ~~~\n\n# 8. 函数\n\n* 为完成某一功能的程序指令(语句)的集合，称为函数。\n* 在 C 语言中，函数分为：自定义函数、系统函数(查看 C 语言函数手册)\n* 函数还有其它叫法，比如方法等，我们统一称为 函数。\n\n## 8.1 函数的定义\n\n~~~ markdown\n返回类型 函数名(形参列表){\n\t执行语句;\n\treturn 返回值;  // 如果 返回类型为void 可以没有返回值\n}\n\ndouble cal(int n1, int n2) {\n\tdouble res = 0.0;\n\tres = n1 + n2\n\treturn res;\n}\n\nint main(){\n    int num1 = 10; //第一个数\n    int num2 = 20; //第二个数\n\treturn cal(num1, num2);\n}\n~~~\n\n## 8.2 头文件\n\n在实际的开发中，我们往往需要在不同的文件中，去调用其它文件的定义的函数， 比如 hello.c 中，去使用myfuns.c 文件中的函数。\n\n* 头文件\n  1. 头文件是**扩展名为 .h**的文件， 包含了**C 函数声明和宏定义**， 被多个源文件中引用共享。 有两种类型的头文件：程序员编写的头文件和 C 标准库自带的头文件。\n  2. 在程序中要使用头文件，需要使用**C 预处理指令 #include**来引用它。 前面我们已经看过 stdio.h 头文件，它是C 标准库自带的头文件。\n  3. \\#include 叫做文件包含命令， 用来引入对应的头文件（.h 文件）。#include 也是 C 语言预处理命令的一种。#include 的处理过程很简单， 就是将头文件的内容插入到该命令所在的位置， 从而把头文件和当前源文件连接成一个源文件， 这与复制粘贴的效果相同。 \n  4. **建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。**\n\n如\n\nmyfun.c\n\n~~~ c\n#include <stdio.h>\n\nint myCal(int n1, int n2, char oper) {\n    //定义一个变量 res ,保存运算的结果\n    double res = 0.0;\n    switch(oper) {\n        case '+' :\n            res = n1 + n2;\n            break;\n        case '-':\n            res = n1 - n2;\n            break;\n        case '*':\n            res = n1 * n2;\n            break;\n        case '/':\n            res = n1 / n2;\n            break;\n        default :\n            printf(\"你的运算符有误~\");\n    } \n    printf(\"\\n%d %c %d = %.2f\\n\", n1, oper, n2, res);\n    return res;\n}\n\nvoid sayHello() { //定义函数\n    printf(\"say Hello\");\n}\n~~~\n\nmyfun.h\n\n~~~ c\n#include <stdio.h>\n// 声明函数\nint myCal(int n1, int n2, char oper);\n\nvoid sayHello();\n~~~\n\nhello.c\n\n~~~ c\n#include <stdio.h>\n//引入我们需要的头文件(用户头文件)\n#include \"myfun.h\"\n\nvoid main() {\n    //使用 myCal 完成计算任务\n    int n1 = 10;\n    int n2 = 50;\n    char oper = '-';\n    double res = 0.0;\n    //调用 myfun.c 中定义的函数 myCal\n    res = myCal(n1, n2, oper);\n    printf(\"\\nres=%.2f\", res);\n    sayHello();\n    getchar();\n}\n~~~\n\n* 使用细节\n  1. 引用头文件相当于复制头文件的内容。\n  2. 源文件的名字 可以不和头文件一样，但是为了好管理，一般头文件名和源文件名一样。\n  3. C 语言中 include <> 与 include \"\" 的区别\n     1. include <>：引用的是编译器的类库路径里面的头文件，用于引用系统头文件。\n     2. include \"\"：引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件，用于引用用户头文件。\n     3. **引用系统头文件，两种形式都会可以，include <> 效率高。引用用户头文件，只能使用 include \"\"。**\n  4. 一个 #include 命令只能包含一个头文件，多个头文件需要多个 #include 命令。\n  5. 同一个头文件如果被多次引入，多次引入的效果和一次引入的效果相同，因为头文件在代码层面有防止重复引入的机制。\n  6. 在一个被包含的文件(.c)中又可以包含另一个文件头文件(.h)\n  7. 不管是标准头文件，还是自定义头文件，都只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误。\n\n## 8.3 函数细节\n\n1. 函数的形参列表可以是多个。\n\n2. C 语言传递参数可以是值传递（pass by value） ， 也可以传递指针（a pointer passed by value） 也叫引用传递。\n\n3. 函数的命名遵循标识符命名规范，首字母不能是数字，可以采用 驼峰法 或者 下划线法。\n\n4. 函数中的变量是局部的，函数外不生效。\n\n5. 基本数据类型默认是值传递的， 即进行值拷贝。在函数内修改，不会影响到原来的值。\n\n   ~~~ c\n   // 基本数据类型默认是值传递的， 即进行值拷贝。 在函数内修改， 不会影响到原来的值\n   void f2(int n) {\n       n++;\n       printf(\"\\n f2中的n=%d\", n); // n=10\n   }\n   \n   void main() {\n       //函数中的变量是局部的， 函数外不生效\n       //printf(\"num=%d\", num);\n       int n = 9;\n       f2(n);\n       printf(\"\\n main 函数中 n=%d\", n); // 9\n       getchar();\n   }\n   ~~~\n\n6. 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&，函数内以指针的方式操作变量。从效果上看类似引用(即传递指针)\n\n   ~~~ c\n   // 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&，\n   // 函数内以指针的方式操作变量。 从效果上看类似引用(即传递指针)\n   void f3(int *p) {\n       (*p)++; // 修改会对函数外的变量有影响\n   }\n   \n   void main() {\n       // 函数中的变量是局部的， 函数外不生效\n       // printf(\"num=%d\", num);\n       int n = 9;\n       f3(&n);\n       printf(\"\\nmain 函数中 n=%d\", n); //10\n       getchar();\n   }\n   ~~~\n\n7. C 语言 不支持函数重载。\n\n8. C 语言支持可变参数函数。\n\n   ~~~ c\n   #include <stdio.h>\n   #include <stdarg.h>\n   \n   // 说明\n   // num 表示传递的参数格式\n   // ... 表示可以传递多个参数和 num 一致即可\n   int fun(int num, ...) // 可变函数， 即参数的个数可以不确定, 使用... 表示\n   {\n       int i, totalSum=0;  // totalSum 一定要初始化\n       int val = 0;\n       va_list v1;  // v1 实际是一个字符指针，从头文件里可以找到\n       va_start(v1, num); // 使 v1 指向可变列表中第一个值， 即 num 后的第一个参数\n       printf(\"*v = %d \\n\", *v1);\n       for(i = 0; i < num; i++) //num 减一是为了防止下标超限\n       {\n           val = va_arg(v1, int); // 该函数返回 v1 指向的值， 并使 v1 向下移动一个 int 的距离， 使其指向下一个 int\n           printf(\"val = %d\\n\", val); // val = 10 val=30 val=60\n           totalSum += val;\n       }\n       va_end(v1); //关闭 v1 指针， 使其指向 null\n       return totalSum;\n   } \n   \n   void main() {\n       int res = fun(8, 10,30,60, -100,1,5,7,98);\n       printf(\"和是=%d\", res);\n       getchar();\n   }\n   ~~~\n\n## 8.4 函数参数的传递方式\n\nC 语言传递参数可以是值传递（pass by value） ， 也可以传递指针（a pointer passed by value） 也叫传递地址或者 引用传递。  \n\n> 其实，不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的数据大小，数据越大，效率越低。\n\n* 值传递和引用传递使用特点\n  * 值传递：变量直接存储值，内存通常在栈中分类。\n  * **默认是值传递的数据类型有**：1. 基本数据类型；2. 结构体；3. 共用体；4. 枚举。\n  * 引用传递：变量存储的是一个地址，这个地址对应的空间才真正存储数据（值）。\n  * **默认是引用传递的数据类型有**：指针和数组。\n\n如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&，函数内以指针的方式操作变量(*指针)。\n从效果上看类似引用，比如修改结构体的属性。\n\n## 8.5 变量作用域\n\n所谓变量作用域（Scope），就是指变量的有效范围。\n\n1. 函数内部声明/定义的局部变量，作用域仅限于函数内部。\n2. 函数的参数，形式参数，被当作该**函数内的局部变量**，如果与**全局变量同名**它们会优先使用**局部变量**(编译器使用就近原则)。\n3. 在一个代码块，比如 for / if 中 的局部变量，那么这个变量的的作用域就在该代码块。\n4. 在所有函数外部定义的变量叫全局变量，作用域在整个程序有效。\n\n* 初始化\n  1. 局部变量，系统不会对其默认初始化，必须对局部变量初始化后才能使用，否则，程序运行后可能会异常退出。\n  2. 全局变量，系统会自动对其初始化，如下所示。\n     1. int   0\n     2. char   '\\0'\n     3. float   0.0\n     4. double  0.0\n     5. pointer指针  NULL\n  3. 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。\n\n* 使用细节\n\n  1. **全局变量(Global Variable)保存在内存的全局存储区中**，占用静态的存储单元，它的作用域默认是整个程序，也就是所有的代码文件，包括源文件（.c 文件）和头文件（.h 文件）。\n\n     ![计算机内存](./c/计算机内存.jpg)\n\n  2. **局部变量(Local Variable)保存在栈中**，函数被调用时才动态地为变量分配存储单元，它的作用域仅限于函数内部。 \n\n  3. C 语言规定，**只能从小的作用域向大的作用域中去寻找变量**，而不能反过来。\n\n  4.  在**同一个作用域，变量名不能重复**，在不同的作用域，变量名可以重复，使用时编译器采用就近原则。\n\n  5. 由**{ }包围的代码块也拥有独立的作用域**。\n\n## 8.6 static关键字\n\nstatic 关键字在 c 语言中比较常用，使用恰当能够大大提高程序的模块化特性，有利于扩展和维护。\n\n* 局部变量使用 static 修饰\n\n  1. 局部变量被 static 修饰后，我们称为静态局部变量。\n\n  2. 对应静态局部变量在声明时未赋初值，编译器也会把它初始化为 0。\n\n  3. 静态局部变量存储于进程的静态存储区(全局性质)，只会被初始一次，即使函数返回，它的值也会保持不变。\n\n     ~~~ c\n     void fn(void){\n         int n = 10;  //普通变量, 每次执行都会初始化， n 在栈区\n         printf(\"n=%d \\n\", n);\n         n++;\n         printf(\"n++=%d \\n\", n);\n     } \n     \n     void fn_static(void) {\n         static int n = 10; //静态局部变量， 放在静态存储区， 全局性质空间\n         printf(\"\\n static n=%d \\n\", n); // 10\n         n++; // n = 11\n         printf(\"\\n n++=%d \\n\", n); // 11\n     } \n     \n     int main(void) {\n         fn_static();\n         fn_static();\n         return 0;\n     }\n     \n     标准输出：  // 可以看出  第二次运行的初始化 并没有成功\n     static n=10 \n     n++=11\n     static n=11 \n     n++=12 \n     ~~~\n\n* 全局变量使用 static 修饰\n\n  1. 普通全局变量对整个工程可见，其他文件可以使用 extern 外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了。静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。\n\n  2. 定义不需要与其他文件共享的全局变量时，加上 static 关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。\n\n     ~~~ c\n     file01.c\n     #include <stdio.h>\n         \n     // 在一个文件中， 使用另外一个文件的全局变量, 使用 extern 引入即可\n     extern int num;\n     // extern int num2;  不可以\n     int num2 = 60;\n     void main() {\n         printf(\"\\nnum=%d num2=%d\", num, num2);\n         getchar();\n     }\n     \n     file02.c\n     int num = 10; // 普通全局变量\n     static int num2 = 20;  // 静态全局变量, 只能在本文件中使用， 而不能在其它文件使用\n     ~~~\n\n* 函数使用 static 修饰\n  1. 函数的使用方式与全局变量类似，**在函数的返回类型前加上 static，就是静态函数。**\n  2. 非静态函数可以在另一个文件中通过 extern 引用。\n  3. 静态函数**只能在声明它的文件中可见**，其他文件不能引用该函数。\n  4. **不同的文件可以使用相同名字的静态函数**，互不影响。\n\n## 8.7 字符串中常用的系统函数\n\n头文件 <string.h>\n\n1. 得到字符串的长度\t`size_t strlen(const char *str)`\n2. 拷贝字符串  `char *strcpy(char *dest, const char *src)`   把 src 所指向的字符串复制到 dest。\n3. 连接字符串   `char *strcat(char *dest, const char *src)`    把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。  \n\n~~~ c\n#include <stdlib.h>\n#include <string.h>\n\n\nint main(void) {\n    \n    char src[50] = \"abc\";\n    char dest[50];  // 定义了两个字符数组(字符串) , 大小为 50\n    \n    char * str = \"abcdff\";\n    printf(\"str.len=%d \\n\", strlen(str));  // 统计字符串的大小\n    \n    // 表示将 \"hello\" 拷贝到 src\n    // 注意， 拷贝字符串会将原来的内容覆盖\n    strcpy(src, \"hello\");\n    printf(\"\\s src=%s \\n\", src);\n    \n    strcpy(dest, \"world \");\n    //strcat 是将 src 字符串的内容连接到 dest ,但是不会覆盖 dest 原来的内容， 而是连接!!\n    strcat(dest, src); // \"hello 尚硅谷\"\n    printf(\"最终的目标字符串： dest=%s \\n\", dest);\n    return 0;\n}\n\n标准输出：str.len=6 \ns src=hello \n最终的目标字符串： dest=world hello \n~~~\n\n## 8.8 时间和日期相关函数\n\n头文件 <time.h>\n\n1. 获取当前时间  `char *ctime(const time_t *timer)`    返回一个表示当地时间的字符串， 当地时间是基于参数 timer。  \n2. 编写一段代码来统计 函数 test 执行的时间  `double difftime(time_t time1, time_t time2)`返回 time1 和 time2 之间相差的秒数 (time1-time2)。  \n\n~~~ c\n#include <stdlib.h>\n#include <time.h>\n\n\nvoid test() { // 运行 test 函数， 看看执行花费时间\n    int i = 0;\n    int sum = 0;\n    int j = 0;\n    for(i = 0; i < 77777777;i++) {\n        sum = 0;\n        for (j = 0; j< 10;j++) {\n            sum += j;\n        }\n    }\n}\n\nint main(void) {\n    \n    time_t curtime; // time_h 是一个结构体类型\n    time(&curtime); // time() 完成初始化\n    // ctime 返回一个表示当地时间的字符串， 当地时间是基于参数 timer\n    printf(\"当前时间 = %s\", ctime(&curtime));\n\n    //先得到执行 test 前的时间\n    time_t start_t, end_t;\n    double diff_t; //存放时间差\n    printf(\"程序启动...\\n\");\n    time(&start_t); //初始化得到当前时间\n    test(); //执行 test\n    //再得到执行 test 后的时间\n    time(&end_t);//得到当前时间\n    diff_t = difftime(end_t, start_t); //时间差， 按秒 ent_t - start_t\n    //然后得到两个时间差就是耗用的时间\n    printf(\"执行 test()函数 耗用了%.2f 秒\", diff_t);\n    return 0;\n}\n\n标准输出：当前时间 = Wed Sep  7 10:05:00 2022\n程序启动...\n执行 test()函数 耗用了1.00 秒\n~~~\n\n## 8.9 数学相关函数\n\nmath.h 头文件定义了各种数学函数和一个宏。 在这个库中所有可用的功能都带有一个 double 类型的参数， 且都返回 double 类型的结果。\n\n1. `double exp(double x)  `  返回 e 的 x 次幂的值  \n2. `double log(double x)  `返回 x 的自然对数（基数为 e 的对数）  \n3. `double pow(double x, double y)  `  返回 x 的 y 次幂。  \n4. `double sqrt(double x)  `返回 x 的平方根\n5. `double fabs(double x)  `返回 x 的绝对值。  \n\n~~~ c\n#include <math.h>\n\nint main(void) {\n    double d1 = pow(2.0,3.0);\n    double d2 = sqrt(5.0);\n    printf(\"d1=%.2f\", d1);\n    printf(\"d2=%.2f\", d2);\n    return 0;\n}\n~~~\n\n## 8.10 基本数据类型和字符串类型的转换\n\n我们经常需要将基本数据类型转成字符串类型(即 char 数组 )。  或者将字符串类型转成基本数据类型。\n\n* sprintf 函数的用法\n  1. sprintf 和平时我们常用的 printf 函数的功能很相似。sprintf 函数打印到字符串中，而 printf 函数打印输出到屏幕上。sprintf 函数在我们完成其他数据类型转换成字符串类型的操作中应用广泛。\n  2. 该函数包含在 stdio.h 的头文件中。\n\n**基本类型转字符串类型**\n\n~~~ c\n#include <stdio.h>\n\nint main(void) {\n    char str1[20];  // 字符数组， 即字符串\n    char str2[20];\n    char str3[20];\n    int a = 20984, b = 48090;\n    double d = 14.309948;\n    \n    // 说明\n    // 1. sprintf 是一个系统函数， 可以将结果存放到字符串中\n    // 2. 格式化的结果， 会存放到 str1 中\n    sprintf(str1, \"%d %d\", a, b);\n    sprintf(str2, \"%.2f\", d);\n    sprintf(str3, \"%8.2f\", d); \n    // %8.2f 含义是格式化后， 一共有 8 位， 小数点后占用 2 位， 不够用空格占位\n    \n    printf(\"str1=%s str2=%s str3=%s\", str1, str2, str3);\n    return 0;\n}\n\n标准输出：str1=20984 48090 str2=14.31 str3=   14.31\n~~~\n\n**字符串类型转基本数据类型**\n\n~~~ c\n#include <stdio.h>\n\nint main(void) {\n    // 字符数组\n    char str[10] = \"123456\";\n    char str2[10] = \"12.67423\";\n    char str3[3] = \"ab\";\n    char str4[4] = \"111\";\n    // 说明\n    // 1. atoi(str) 将 str 转成整数\n    int num1 = atoi(str);\n    short s1 = atoi(str4);\n    \n    // 说明\n    // 1. atof(str2); 将 str2 转成小数\n    double d = atof(str2);\n    // 说明\n    // 1. str3[0] 表示获取到 str3 这个字符串(数组)的第一个元素 'a'\n    char c = str3[0];\n    printf(\"num1=%d d=%f c=%c s1=%d\", num1, d, c, s1);//\n    return 0;\n}\n\n标准输出：num1=123456 d=12.674230 c=a s1=111\n~~~\n\n* 注意事项\n  1. 在将 char 数组 类型转成 基本数据类型时，要确保能够转成有效的数据，比如 我们可以把 \"123\" , 转成一个整数，但是不能把 \"hello\" 转成一个整数。\n  2. 如果格式不正确，会默认转成 0 或者 0.0。\n\n# 9. 预处理命令\n\n* 使用库函数之前，应该用 #include 引入对应的头文件。这种以#号开头的命令称为预处理命令。\n* 这些在编译之前对源文件进行简单加工的过程，就称为预处理（即预先处理、 提前处理）\n* 预处理主要是处理以#开头的命令， 例如#include <stdio.h>等。 预处理命令要放在所有函数之外， 而且一般都放在源文件的前面。\n* 预处理是 C 语言的一个重要功能，由预处理程序完成。当对一个源文件进行编译时，系统将自动调用预处理程序对源程序中的预处理部分作处理， 处理完毕自动进入对源程序的编译。\n* C 语言提供了多种预处理功能，如宏定义、文件包含、条件编译等，合理地使用它们会使编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。\n\n## 9.1 预处理命令快速入门\n\n* 要求\n  * 开发一个 C 语言程序，让它暂停 5 秒以后再输出内容 \"helllo, 尚硅谷!~\"，并且要求跨平台，在 Windows 和Linux 下都能运行，如何处理。\n\n> Windows 平台下的暂停函数的原型是 void Sleep(DWORD dwMilliseconds)，参数的单位是“ 毫秒” ，位于 <windows.h> 头文件。 \n>\n> Linux 平台下暂停函数的原型是 unsigned int sleep (unsigned int seconds)， 参数的单位是“秒” ， 位于 <unistd.h> 头文件。\n>\n> \\#if、 #elif、 #endif 就是预处理命令， 它们都是在编译之前由预处理程序来执行的。\n\n~~~ c\n#if _WIN32 //如果是 windows 平台, 就执行 #include <windows.h>\n    #include <windows.h>\n#elif __linux__ //否则判断是不是 linux ,如果是 linux 就引入<unistd.h>\n    #include <unistd.h>\n#endif\n\nint main() {\n    // 不同的平台下调用不同的函数\n    #if _WIN32  // 识别 windows 平台\n        Sleep(5000); //毫秒\n    #elif __linux__ //识别 linux 平台\n        sleep(5); //秒\n    #endif\n    \n    puts(\"hello, world~\"); //输出\n    getchar();\n    return 0;\n}\n~~~\n\n## 9.2 C 语言宏定义\n\n* 基本介绍\n  \n* `#define` 叫做宏定义命令，它也是 C 语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。\n  \n* 宏定义的形式\n\n  * `#define 宏名 字符串`\n  * \\#表示这是一条预处理命令，所有的预处理命令都以 # 开头。宏名是标识符的一种，命名规则和变量相同。字符串可以是数字、表达式、if 语句、函数等。\n  * 这里所说的字符串是一般意义上的字符序列，不要和 C 语言中的字符串等同，它不需要双引号。\n  * 程序中反复使用的表达式就可以使用宏定义。\n\n* 注意细节\n\n  1. 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单的替换。字符串中可以含任何字符，它可以是常数、表达式、if 语句、函数等，预处理程序对它不作任何检查， 如有错误，只能在编译已被宏展开后的源程序时发现。\n\n  2. 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。\n\n  3. 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef 命令。\n\n  4. 代码中的宏名如果被引号包围， 那么预处理程序不对其作宏代替。\n\n     ~~~ c\n     #include <stdio.h>\n     #define OK 100\n     int main(){\n         printf(\"OK \\n\");\n         return 0;\n     }\n     ~~~\n\n  5. 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。\n\n  6. 习惯上宏名用大写字母表示， 以便于与变量区别。 但也允许用小写字母。\n\n  7. 可用宏定义表示数据类型， 使书写方便。\n\n  8. **宏定义表示数据类型**和用 **typedef 定义数据说明符**的区别：**宏定义只是简单的字符串替换，由预处理器来处理**；而 **typedef 是在编译阶段由编译器处理的**， 它并不是简单的字符串替换， 而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。\n\n## 9.3 带参数的宏定义\n\n* C 语言允许宏带有参数。在宏定义中的参数称为“形式参数” ，在宏调用中的参数称为“实际参数” ，这点和\n  函数有些类似。\n* 对带参数的宏， 在展开过程中不仅要进行字符串替换， 还要用实参去替换形参。\n* 带参宏定义的一般形式为 #define 宏名(形参列表) 字符串 ,在字符串中可以含有各个形参。\n* 带参宏调用的一般形式为 : `宏名(实参列表)`\n\n~~~ c\n// 说明\n// 1. MAX 就是带参数的宏\n// 2. (a,b) 就是形参\n// 3. (a>b) ? a : b 是带参数的宏对应字符串， 该字符串中可以使用形参\n#define MAX(a,b) (a>b) ? a : b\nint main(){\n    int x , y, max;\n    printf(\"input two numbers: \");\n    scanf(\"%d %d\", &x, &y);\n    // 说明\n    // 1. MAX(x, y); 调用带参数宏定义\n    // 2. 在宏替换时(预处理， 由预处理器)， 会进行字符串的替换， 同时会使用实参， 去替换形参\n    // 3. 即 MAX(x, y) 宏替换后 (x>y) ? x : y\n    max = MAX(x, y);\n    printf(\"max=%d\\n\", max);\n    return 0;\n}\n\n标准输出：input two numbers: max=32764\n~~~\n\n* 使用细节\n\n  1. 带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现。\n\n     `#define MAX(a,b) (a>b)?a:b` 如果写成了`#define MAX (a, b) (a>b)?a:b`  \n\n  2. 在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。\n\n  3. 在宏定义中，字符串内的形参通常要用括号括起来以避免出错。\n\n     `#define SQ(y) (y)*(y)` // 带参宏定义,字符串内的形参通常要用括号括起来以避免出错  \n\n## 9.4 带参宏定义和函数的区别\n\n1. 宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。\n2. 函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。\n\n## 9.5 预处理命令总结\n\n|   指令   |                             说明                             |\n| :------: | :----------------------------------------------------------: |\n|    #     |                     空指令， 无任何效果                      |\n| #include |                      包含一个源代码文件                      |\n| #define  |                            定义宏                            |\n|  #undef  |                        取消已定义的宏                        |\n|   #if    |              如果给定条件为真， 则编译下面代码               |\n|  #ifdef  |               如果宏已经定义， 则编译下面代码                |\n| #ifndef  |               如果宏没有定义， 则编译下面代码                |\n|  #elif   | 如果前面的#if 给定条件不为真， 当前条件 为真， 则编译下面代码 |\n|  #endif  |                结束一个#if……#else 条件编译块                 |\n\n* 注意事项\n  1. 预处理功能是 C 语言特有的功能， 它是在对源程序正式编译前由预处理程序完成的， 程序员在程序中用预处理命令来调用这些功能。\n  2. 宏定义可以带有参数，宏调用时是以实参代换形参，而不是“值传送” 。\n  3. 为了避免宏代换时发生错误，宏定义中的字符串应加括号，字符串中出现的形式参数两边也应加括号。\n  4. 文件包含是预处理的一个重要功能，它可用来把多个源文件连接成一个源文件进行编译，结果将生成一个目标文件。\n  5. 条件编译允许只编译源程序中满足条件的程序段，使生成的目标程序较短，从而减少了内存的开销并提高了程序的效率。\n  6. 使用预处理功能便于程序的修改、阅读、移植和调试，也便于实现模块化程序设计\n\n# 10. 数组\n\n**数组可以存放多个同一类型数据**。数组也是一种数据类型，是**构造类型**。传递是以**引用的方式传递**(即传递的是地址)\n\n## 10.1 数组定义\n\n* `数据类型 数组名 [数组大小];` 如 `int a[5]`  赋初值 a[0] = 1; a[1] = 30;  \n* 内存\n  1. `数组名` 就代表 `该数组的首地址`， 即 a[0]地址。\n  2. **数组的各个元素是连续分布的**\n     1. 假如 a[0] 地址 0x1122\n     2. a[1] 地址 = a[0]的地址 + int 字节数(4) = 0x1122 + 4 =  0x1126\n     3. a[2] 地址 = a[1]地址 + int 字节数(4) = 0x1126 + 4 = 0x112A\n* 访问：数组名[下标]\n\n**三种初始化方式**\n\n~~~ c\nint main(){\n    // 方式\n    int arr1[3];\n    arr1[0] = 100;\n    arr1[1] = 200;\n    arr1[2] = 300;\n    \n    // 方式2\n    int arr2[3] = {4, 5, 6};\n    \n    // 方式3\n    int arr3[] = {7, 8, 9, 10};\n    for (int i = 0; i < sizeof(arr3) / sizeof(int); i++){\n        printf(\"%d\", arr3[i]);\n    }\n    return 0;\n}\n~~~\n\n* 使用细节\n  1. 数组是多个相同类型数据的组合，一个数组一旦声明/定义了，其**长度是固定的**，不能动态变化。\n  2. 数组创建后，如果没有赋值，则遵守如下规则。\n     1. 全局数组默认值 0\n     2. 非全局数组初值是机器垃圾值(即： 原来系统分配给这块空间的值)\n  3. 使用数组的步骤 1. 定义数组 2 给数组各个元素赋值 3 使用数组, 也可以一步到位\n  4. C 的数组属构造类型，是引用传递(传递的是地址)，因此当把一个数组传递给一个函数时/或者变量，函数/变量操作数组会影响到原数组。\n\n## 10.2 字符数组与字符串\n\n用来存放字符的数组称为字符数组。\n\n1. `char a[10]; `  //  一维字符数组, 长度为 10\n2. `char b[5][10]`;   //  二维字符数组\n3. `char c[20]={'c', ' ', 'p', 'r', 'o', 'g', 'r', 'a','m'};`  //  给部分数组元素赋值\n\n字符数组实际上是一系列字符的集合，也就是字符串（String）。在 C 语言中，没有专门的字符串变量，没有string 类型，通常就用一个字符数组来存放一个字符串。\n\n> 在 C 语言中，字符串实际上是使用 null 字符 ('\\0') 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。\n>\n> '\\0' 是 ASCII 码表中的第 0 个字符，用 NUL 表示，称为空字符。该字符既不能显示，也不是控制字符，输出该字符不会有任何效果，它在 C 语言中仅作为字符串的结束标志。\n\n如果在给某个字符数组赋值时，\n\n1. 赋给的元素的个数小于该数组的长度，则会自动在后面加 '\\0'，表示字符串结束。\n2. 赋给的元素的个数等于该数组的长度，则不会自动添加 '\\0'\n\n~~~ c\nint main(){\n    // c 是一个一维字符数组， 给部分元素赋值\n    char c[7]={'t','o','m'};\n    char str[4] = {'a','b','d','\\0'};\n    char str2[] = {'j','a','c','k'}; // 这个后面系统也不会自动添加 '\\0'\n    \n    // 输出 c , 系统会这样处理\n    //1. 从第一个字符开始输出， 直到遇到 \\0 , 表示该字符串结束\n    printf(\"\\n c=%s\", c);  // tom\n    printf(\"\\n str=%s\", str); // abc（最后一个结束符不会输出）\n    printf(\"\\n str2=%s\", str2); // jack 乱码（乱码直到碰到结束符为止）\n    return 0;\n}\n\n标准输出： \nc=tom\nstr=abd\nstr2=jackabd\n~~~\n\n* 访问和遍历\n\n  * 因为字符串的本质就是字符数组，因此可以按照数组的方式遍历和访问某个元素即可。\n\n    ~~~ c\n    int main(){\n        char greeting[] = \"Hello\";\n        int i;\n        int len = strlen(greeting); // len = 5\n        printf(\"\\n greeting=%s\", greeting);\n        printf(\"\\n len=%d\", len); //5\n        printf(\"\\n 字符串第 3 个字符是=%c\", greeting[2]); //l\n        printf(\"\\n\");\n        for(i = 0; i < len; i++) {//遍历\n            printf(\"%c \", greeting[i]); //H e l l o\n        }\n        return 0;\n    }\n    \n    标准输出： greeting=Hello\n    len=5\n    字符串第 3 个字符是=l\n    H e l l o \n    ~~~\n\n## 10.3 字符串的表示形式\n\n* 两种表示形式\n  1. 用字符数组存放一个字符串\n     1. `char str[] = \"hello tom\";`\n     2. `char str2[] = {'h', 'e'};`\n  2. 用字符指针指向一个字符串\n     1. `char* pStr = \" hello tom\";`\n     2. C 语言对字符串常量\" hello tom\"是按字符数组处理的，在内存中开辟了一个字符数组用来存放字符串常量，程序在定义字符串指针变量 pStr 时只是把字符串首地址（即存放字符串的字符数组的首地址） 赋给 pStr。\n     3. `printf(\"%s \\n\",pStr);` 可以输出 str 指向的字符串\n\n* 区别\n  1. 字符数组由若干个元素组成，每个元素放一个字符；而字符指针变量中存放的是地址（字符串/字符数组的首地址），绝不是将字符串放到字符指针变量中（是字符串首地址）\n  2. 对字符数组只能对各个元素赋值，不能用`char str[14]; str=\"hello tom\";`对字符数组赋值。\n  3. 对字符指针变量，采用下面方法赋值，是可以的`char* a=\"yes\"; a=\" hello tom\";`\n  4. 如果定义了一个字符数组，那么它有确定的内存地址(即字符数组名是一个常量)；而定义一个字符指针变量时，它并未指向某个确定的字符数据，并且可以多次赋值。\n\n## 10.4 字符串相关函数\n\n|                |                                                              |\n| -------------- | ------------------------------------------------------------ |\n| strcpy(s1, s2) | 复制字符串S2到S1                                             |\n| strcat(s1, s2) | 链接字符串S2到字符串S1的末尾                                 |\n| strlen(s1)     | 返回字符串S1的长度                                           |\n| strcmp(s1, s2) | 如果S1和S2是相同的，则返回0，如果S1<S2则返回小于0，如果S1>S2返回大于0 |\n| strchr(s1, ch) | 返回一个指针，指向字符串S1中字符ch第一次出现的位置           |\n| strstr(s1, s2) | 返回一个指针，指向字符串S1中字符串S2第一次出现的位置         |\n\n~~~ c\n#include <string.h>\n\nint main(){\n    char str1[12] = \"Hello\";\n    char str2[12] = \"World\";\n    char str3[12];\n    int len ;\n    \n    /* 复制 str1 到 str3 */\n    strcpy(str3, str1); // str3 内容 \"Hello\"\n    printf(\"strcpy( str3, str1) : %s \\n\", str3 ); //\"Hello\"\n    \n    /* 连接 str1 和 str2 */\n    strcat( str1, str2);\n    printf(\"strcat( str1, str2): %s\\n\", str1 ); //\"HelloWorld\"\n    \n    /* 连接后， str1 的总长度 */\n    len = strlen(str1);//\n    printf(\"strlen(str1) : %d\\n\", len );//10\n    return 0;\n}\n\n标准输出：strcpy( str3, str1) : Hello \nstrcat( str1, str2): HelloWorld\nstrlen(str1) : 10\n~~~\n\n* 使用注意事项和细节\n\n  1. 程序中往往依靠检测 '\\0' 的位置来判定字符串是否结束，而不是根据数组的长度来决定字符串长度。 因此，字符串长度不会统计 '\\0', 字符数组长度会统计。\n\n  2. 在定义字符数组时应估计实际字符串长度，保证数组长度始终大于字符串实际长度，否则，在输出字符数组时可能出现未知字符。\n\n  3. 系统对字符串常量也自动加一个'\\0'作为结束符。例如\"C Program” 共有 9 个字符，但在内存中占 10 个字节，最后一个字节'\\0'是系统自动加上的。 \n\n  4. 定义字符数组时，如果给的字符个数比数组的长度小，则系统会默认将剩余的元素空间，全部设置为 '\\0', 比如 char str[6] = \"ab\" , str 内存布局就是`[a][b][\\0][\\0][\\0][\\0]`。\n\n  5. 字符数组定义和初始化的方式比较多\n\n     ~~~ c\n     char str1[ ] = {\"I am happy\"}; // 默认后面加 '\\0'\n     char str2[ ] = \"I am happy\"; // 省略{}号 ,默认后面加 '\\0'\n     char str3[ ] = {'I',' ','a','m',' ','h','a','p','p','y'}; // 字符数组后面不会加 '\\0', 可能有乱码\n     char str4[5] = {'C','h','i','n','a'}; //字符数组后面不会加 '\\0', 可能有乱码\n     char * pStr = \"hello\"; //ok\n     ~~~\n\n# 11. 排序和查找\n\n## 11.1 冒泡排序\n\n~~~ c\n//冒泡排序的函数\nvoid bubbleSort(int arr[], int arrLen) {\n    //因为每轮排序几乎一样， 因此， 我们可以使用 for 循环处理\n    int j,i;\n    int t;//临时变量\n    for(i=0; i < arrLen - 1; i++) {\n        for(j = 0; j < arrLen-1-i; j++) {\n        //如果前面的数大于后面的数， 就交换\n        if(arr[j] > arr[j+1]) {\n            t = arr[j];\n            arr[j] = arr[j+1];\n            arr[j+1] = t;\n            }\n        }\n    }\n}\n\nint main(){\n    int arr[] = {3, 9, -1, 10, -2,-11} ;\n    int arrLen = sizeof(arr) / sizeof(int); // 通过计算得到\n    int j;\n    bubbleSort(arr, arrLen); // 数组默认是地址传递(指针)\n    \n    printf(\"\\n 排序后(函数)\\n\");\n    for(j= 0; j < arrLen; j++) {\n        printf(\"%d \", arr[j]);\n    }\n    return 0;\n}\n~~~\n\n## 11.2 二分查找\n\n~~~ c\nint seqSearch(int arr[], int arrLen, int val) {\n    int i;\n    for(i = 0; i < arrLen; i++) {\n        if(arr[i] == val) {\n            return i;\n        }\n    } \n    // 如果在 for 循环中， 没有执行到 return ,说明没有找到\n    return -1;\n}\n\nint main(){\n    // 有一个数列： {23， 1， 34,89， 101}\n    // 猜数游戏： 从键盘中任意输入一个数， 判断数列中是否包含该数【顺序查找】 要求: 如果找到了，\n    // 就提示找到， 并给出下标值, 找不到提示 没有。\n    // 分析思路\n    // 1. 安装数组进行遍历， 一个一个的比较， 如果相等， 则找到\n    int arr[] = {23, 1, 34, 89, 101};\n    int arrLen = sizeof(arr) / sizeof(int);\n    \n    int index = seqSearch(arr, arrLen, 101);\n    if (index != -1) { //找到\n        printf(\"找到 下标为 %d\", index);\n    } else {\n        printf(\"没有找到\");\n    }\n    return 0;\n}\n~~~\n\n## 11.3 多维数组-二维数组\n\n**使用方式1**\n\n`类型 数组名[大小][大小];`比如：比如: `int a[2][3]`;\n\n二维数组在内存的存在形式，各个元素的地址是连续分布的，即在前一个元素基础上。\n\n~~~ c\nint main(){\n    int a[4][6]; // 没有初始化， 则是分配的内存垃圾值\n    int i, j;\n    //全部初始化 0\n    for(int i = 0; i < 4; i++) { //先遍历行\n        for(int j = 0; j < 6; j++) {//遍历列\n            a[i][j] = 0;\n        }\n    }\n    \n    //看看二维数组的内存布局\n    printf(\"\\n 二维数组 a 的首地址=%p\", a);\n    printf(\"\\n 二维数组 a[0]的地址=%p\", a[0]);\n    printf(\"\\n 二维数组 a[0][0]的地址=%p\", &a[0][0]);\n    printf(\"\\n 二维数组 a[0][1]的地址=%p\", &a[0][1]);\n    //将二维数组的各个元素得地址输出\n    printf(\"\\n\");\n    \n    for(i = 0; i < 4; i++) {\n        printf(\"a[%d]的地址=%p \", i, a[i]);\n        for(j=0; j < 6; j++) {\n            printf(\"a[%d][%d]的地址=%p \", i, j , &a[i][j]);\n        } \n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n标准输出： 二维数组 a 的首地址=0x7ffdc984fb40\n 二维数组 a[0]的地址=0x7ffdc984fb40\n 二维数组 a[0][0]的地址=0x7ffdc984fb40\n 二维数组 a[0][1]的地址=0x7ffdc984fb44\na[0]的地址=0x7ffdc984fb40 a[0][0]的地址=0x7ffdc984fb40 a[0][1]的地址=0x7ffdc984fb44 a[0][2]的地址=0x7ffdc984fb48 a[0][3]的地址=0x7ffdc984fb4c a[0][4]的地址=0x7ffdc984fb50 a[0][5]的地址=0x7ffdc984fb54 \na[1]的地址=0x7ffdc984fb58 a[1][0]的地址=0x7ffdc984fb58 a[1][1]的地址=0x7ffdc984fb5c a[1][2]的地址=0x7ffdc984fb60 a[1][3]的地址=0x7ffdc984fb64 a[1][4]的地址=0x7ffdc984fb68 a[1][5]的地址=0x7ffdc984fb6c \na[2]的地址=0x7ffdc984fb70 a[2][0]的地址=0x7ffdc984fb70 a[2][1]的地址=0x7ffdc984fb74 a[2][2]的地址=0x7ffdc984fb78 a[2][3]的地址=0x7ffdc984fb7c a[2][4]的地址=0x7ffdc984fb80 a[2][5]的地址=0x7ffdc984fb84 \na[3]的地址=0x7ffdc984fb88 a[3][0]的地址=0x7ffdc984fb88 a[3][1]的地址=0x7ffdc984fb8c a[3][2]的地址=0x7ffdc984fb90 a[3][3]的地址=0x7ffdc984fb94 a[3][4]的地址=0x7ffdc984fb98 a[3][5]的地址=0x7ffdc984fb9c \n\n~~~\n\n**使用方式2**\n\n`类型 数组名[大小][大小] = {{值 1,值 2..},{值 1,值 2..},{值 1,值 2..}};  `\n\n`类型 数组名[大小][大小] = { 值 1,值 2,值 3,值 4,值 5,值 6 ..};  `\n\n~~~ c\nint main(){\n    int map[3][3] = {{0,0,1},{1,1,1},{1,1,3}};\n    \n    // 遍历\n    // 先得到行\n    // 1. sizeof(map) 得到这个 map 数组的大小 9 * 4 = 36\n    // 2. sizeof(map[0]) 得到 map 中， 第一行有多大 3 * 4 = 12\n    int rows = sizeof(map) / sizeof(map[0]); // 3\n    \n    // 得到列\n    int cols = sizeof(map[0]) / sizeof(int); // 12 / 4 = 3\n    int i,j, sum=0;\n    for(i = 0; i < rows; i++) {\n        for(j = 0; j < cols; j++) {\n            printf(\"%d \", map[i][j]);\n            sum += map[i][j];  //累计到 sum\n        } \n        printf(\"\\n\");\n    }\n    \n    printf(\"\\n sum=%d\", sum);\n    \n    return 0;\n}\n~~~\n\n* 使用细节\n  1. 可以只对部分元素赋值，未赋值的元素自动取“零” 值。\n  2. 如果对全部元素赋值，那么第一维的长度可以不给出。\n  3. 二维数组可以看作是由一维数组嵌套而成的；如果一个数组的每个元素又是一个数组，那么它就是二维数组。\n\n# 12. 指针\n\n1. 指针，也就是内存的地址；所谓指针变量，也就是保存了内存地址的变量。\n\n2. 获取变量的地址，用&，比如：int num = 10，获取 num 的地址：&num。\n\n3. 指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值。\n\n   比如：`int *ptr = &num;` ptr 就是指向 int 类型的指针变量，即 ptr 是 int * 类型。\n\n4. 获取指针类型所指向的值，使用：*(取值符号)，比如：int * ptr，使用 *ptr 获取 ptr 指向的值。\n\n~~~ markdown\nint *ip;   一个整型的指针 \ndouble *dp; 一个 double 型的指针\nfloat *fp;  一个浮点型的指针\nchar *ch; 一个字符型的指针 \n~~~\n\n## 12.1 指针的算术运算\n\n指针是一个用数值表示的地址。可以对指针执行算术运算。可以对指针进行四种算术运算：++、 --、 +、 -。\n\n当对指针进行++时，指针会按照它指向的数据类型字节数大小增加，比如 int * 指针，每++ ，就增加 4 个字节。\n\n~~~ c\nconst int MAX = 3; // 常量\n\nint main(){\n    int var[] = {10, 100, 200}; // int 数组\n    int i, *ptr; // ptr 是一个 int* 指针\n    ptr = var; // ptr 指向了 var 数组的首地址\n    \n    for ( i = 0; i < MAX; i++) {\n        printf(\"var[%d] 地址= %p \\n\", i, ptr );\n        printf(\"存储值： var[%d] = %d\\n\", i, *ptr );\n        ptr++;// ptr = ptr + 1(1 个 int 字节数); ptr 存放值+4 字节(int)\n    }\n    return 0;\n}\n\n标准输出：var[0] 地址= 0x7fff2cdffde4 \n存储值： var[0] = 10\nvar[1] 地址= 0x7fff2cdffde8 \n存储值： var[1] = 100\nvar[2] 地址= 0x7fff2cdffdec \n存储值： var[2] = 200\n\n/* 指针中最后一个元素的地址 */\nptr = &var[MAX-1]; // &var[2]\nptr--;\n~~~\n\n> 如果是 ptr += 2；那就是一次增加8个字节（2个int类型的空间）。减法同理。\n\n## 12.2 指针的比较\n\n指针可以用关系运算符进行比较，如 ==、 <、<=  和 >、>=。\n\n~~~ c\nint main(){\n    int var[] = {10, 100, 200};\n    int *ptr;\n    ptr = var; // ptr 指向 var 首地址(第一个元素)\n    // if(ptr == var[0]) {//错误,类型不一样 (int *) 和 (int )\n    //     printf(\"ok1\");\n    // }\n    if(ptr == &var[0]) { // 可以\n        printf(\"\\n ok2\"); //输出\n    }\n    if(ptr == var) { //可以\n        printf(\"\\n ok3\"); //输出\n    }\n    if(ptr >= &var[1]) { //可以比较,但是返回 false\n        printf(\"\\n ok4\"); //不会输出\n    }\n\n    return 0;\n}\n~~~\n\n> 其实就是说 地址也是可以用来比较的。\n\n## 12.3 指针数组\n\n要让数组的元素 指向 int 或其他数据类型的地址(指针)。可以使用指针数组。\n\n`数据类型 *指针数组名[大小];` 比如：int *ptr[3];   ptr 声明为一个指针数组。\n\n由 3 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。\n\n~~~ c\nint main(){\n    // 定义一个指针数组， 该数组的每个元素， 指向的是一个字符串\n    char *books[] = {\n                    \"三国演义\",\n                    \"西游记\",\n                    \"红楼梦\",\n                    \"水浒传\"\n                    };\n    char * pStr = \"abc\";\n    // 遍历\n    int i, len = 4;\n    for(i = 0; i < len; i++) {\n        printf(\"\\nbooks[%d] 指向字符串是=%s pStr 指向的内容=%s\", i, books[i], pStr);\n    }\n    return 0;\n}\n\n标准输出：books[0] 指向字符串是=三国演义 pStr 指向的内容=abc\nbooks[1] 指向字符串是=西游记 pStr 指向的内容=abc\nbooks[2] 指向字符串是=红楼梦 pStr 指向的内容=abc\nbooks[3] 指向字符串是=水浒传 pStr 指向的内容=abc\n~~~\n\n## 12.4 指向指针的指针\n\n又叫`多重指针`\n\n指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。\n\n当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。\n\n一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。\n\n `int **ptr; // ptr 的类型是 int **  `\n\n~~~ c\nint main () {\n    int var;\n    int *ptr; //一级指针\n    int **pptr; //二级指针\n    int ***ppptr; // 三级指针\n    var = 3000;\n    ptr = &var; // var 变量的地址赋给 ptr\n    pptr = &ptr;// 表示将 ptr 存放的地址， 赋给 pptr\n    ppptr = &pptr; // 表示将 pptr 存放的地址， 赋给 ppptr\n    printf(\"var 的地址=%p var = %d \\n\", &var, var );// 0x1133 3000\n    printf(\"ptr 的本身的地址=%p ptr 存放的地址=%p *ptr = %d \\n\", &ptr, ptr, *ptr );\n    printf(\"pptr 本身地址 = %p pptr 存放的地址=%p **pptr = %d\\n\", &pptr, pptr, **pptr);\n    printf(\"ppptr 本身地址 = %p ppptr 存放的地址=%p ***pptr = %d\\n\", &ppptr, ppptr, ***ppptr);\n    getchar();\n    return 0;\n}\n~~~\n\n## 12.5 传递指针(地址)给函数\n\n当函数的形参类型是指针类型时，是使用该函数时，需要传递指针，或者地址，或者数组给该形参。\n\n## 12.6 传数组给指针变量\n\n数组名本身就代表该数组首地址，因此传数组的本质就是传地址。\n\n## 12.7 指针函数\n\n返回指针的函数\n\nC 语言 允许函数的返回值是一个指针（地址），这样的函数称为指针函数。\n\n~~~ c\n// 请编写一个函数 strlong()， 返回两个字符串中较长的一个。\n\n#include <string.h>\nchar *strlong(char *str1, char *str2){ // 函数返回的 char * (指针)\n    printf(\"\\nstr1 的长度%d str2 的长度%d\", strlen(str1), strlen(str2));\n    if(strlen(str1) >= strlen(str2)){\n        return str1;\n    }else{\n        return str2;\n    }\n}\n\nint main(){\n    char str1[30], str2[30], *str; // str 是一个指针类型， 指向一个字符串\n    printf(\"\\n 请输入第 1 个字符串\");\n    gets(str1);\n    printf(\"\\n 请输入第 2 个字符串\");\n    gets(str2);\n    str = strlong(str1, str2);\n    printf(\"\\nLonger string: %s \\n\", str);\n    return 0;\n}\n\n输入：aaa bbbb\n\n标准输出： \n请输入第 1 个字符串\n请输入第 2 个字符串\nstr1 的长度3 str2 的长度4\nLonger string: bbbb \n~~~\n\n* 指针函数注意事项和细节\n\n  1. 用指针作为函数返回值时需要注意，**函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数**，函数返回的指针不能指向这些数据。\n  2. 函数运行结束后会销毁该函数所有的局部数据，这里所谓的销毁并不是将局部数据所占用的内存全部清零，而是程序放弃对它的使用权限，后面的代码可以使用这块内存。\n  3. **C 语言不支持在调用函数时返回局部变量的地址， 如果确实有这样的需求， 需要定义局部变量为 static 变量**。\n\n  ~~~ c\n  int *func(){\n      // int n = 100; //局部变量, 在 func 返回时，就会销毁\n      static int n = 100; // 如果这个局部变量是 static 性质的，那么n存放数据的空间在静态数据区\n      return &n;\n  } \n  int main(){\n      int *p = func(); //func 返回指针\n      int n;\n      printf(\"okoook~~\"); //可能是使用到 局部变量 int n = 100 占用空间\n      n = *p;\n      printf(\"\\n value = %d\\n\", n);// 思考，是否能够输出 100? 不一定\n      return 0;\n  }\n  ~~~\n\n## 12.8 函数指针\n\n就是：指向函数的指针\n\n1. 一个函数总是占用一段连续的内存区域， 函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。\n2. **把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域**，然后通过指针变量就可以找到并调用该函数。这种**指针就是函数指针**。\n\n* 定义`returnType (*pointerName)(param list);`\n  1. returnType 为函数指针指向的函数返回值类型\n  2. pointerName 为函数指针名称\n  3. param list 为函数指针指向的函数的参数列表\n  4. 参数列表中可以同时给出参数的类型和名称， 也可以只给出参数的类型， 省略参数的名称\n  5. 注意( )的优先级高于*，第一个括号不能省略，如果写作 returnType *pointerName(param list);就成了函数原型，它表明函数的返回值类型为 returnType *\n\n~~~ c\n// 用函数指针来实现对函数的调用, 返回两个整数中的最大值.\n// 说明\n// 1. max 函数\n// 2. 接收两个 int ,返回较大数\nint max(int a, int b){\n    return a>b ? a : b;\n}\n\nint main(){\n    int x, y, maxVal;\n    // 说明 函数指针\n    // 1. 函数指针的名字 pmax\n    // 2. int 表示 该函数指针指向的函数是返回 int 类型\n    // 3. (int, int) 表示 该函数指针指向的函数形参是接收两个 int\n    // 4. 在定义函数指针时， 也可以写上形参名 int (*pmax)(int x, int y) = max;\n    int (*pmax)(int , int) = max; //\n    printf(\"Input two numbers:\");\n    scanf(\"%d %d\", &x, &y);\n    // (*pmax)(x, y) 通过函数指针去调用 函数 max\n    maxVal = (*pmax)(x, y);\n    printf(\"Max value: %d pmax=%p pmax 本身的地址=%p\\n\", maxVal, pmax, &pmax);\n    return(0);\n}\n~~~\n\n## 12.9 回调函数\n\n1. 函数指针变量可以作为某个函数的参数来使用的， 回调函数就是一个通过函数指针调用的函数。\n2. 回调函数是由别人的函数执行时调用你传入的函数（通过函数指针完成）\n\n~~~ c\n// 使用回调函数的方式， 给一个整型数组 int arr[10] 赋 10 个随机数\n\n// 回调函数\n// 1. int (*f)(void)\n// 2. f 就是 函数指针, 它可以接收的函数是 (返回 int ,没有形参的函数)\n// 3. f 在这里被 initArray 调用， 充当了回调函数角色\nvoid initArray(int *array, int arraySize, int (*f)(void)) {\n    int i;\n    // 循环 10\n    for (i=0; i<arraySize; i++) {\n        array[i] = f(); //通过 函数指针调用了 getNextRandomValue 函数\n    }\n}\n\n// 获取随机值\nint getNextRandomValue(void) {\n    return rand(); // rand 系统函数， 会返回一个随机整数\n}\n\nint main(void) {\n    int myarray[10],i; //定义一个数组和 int\n    // 说明\n    // 1. 调用 initArray 函数\n    // 2. 传入了一个函数名 getNextRandomValue (地址), 需要使用函数指针接收\n    initArray(myarray, 10, getNextRandomValue);\n    // 输出赋值后的数组\n    for(i = 0; i < 10; i++) {\n        printf(\"%d \", myarray[i]);\n    } \n    printf(\"\\n\");\n    return 0;\n}\n~~~\n\n* 指针的注意事项和细节\n  1. 指针变量存放的是地址，从这个角度看指针的本质就是地址。\n  2. 变量声明的时候，如果没有确切的地址赋值，为指针变量赋一个 NULL 值是好的编程习惯。\n  3. 赋为 NULL 值的指针被称为空指针，NULL 指针是一个定义在标准库 <stdio.h> 中的值为零的常量 #define NULL 0\n\n## 12.10 动态内存分配\n\n1. 全局变量——内存中的静态存储区\n2. 非静态的局部变量——内存中的动态存储区——stack 栈\n3. 临时使用的数据---建立动态内存分配区域， 需要时随时开辟， 不需要时及时释放——heap 堆\n4. 根据需要向系统申请所需大小的空间，由于未在声明部分定义其为变量或者数组，不能通过变量名或者数组名来引用这些数据，只能通过指针来引用\n\n* 相关函数  头文件 `#include <stdlib.h>` 声明了四个关于内存动态分配的函数\n  * 函数原型 `void * malloc（usigned int size） // memory allocation`\n    * 作用——在内存的动态存储区(堆区)中分配一个长度为 size 的连续空间。\n    * 形参 size 的类型为无符号整型， 函数返回值是所分配区域的第一个字节的地址， 即此函数是一个指针型函数，返回的指针指向该分配域的开头位置。\n    * malloc(100); 开辟 100 字节的临时空间， 返回值为其第一个字节的地址\n  * 函数原型`void *calloc（unsigned n,unsigned size）`\n    * 作用——在内存的动态存储区中分配 n 个长度为 size 的连续空间， 这个空间一般比较大， 足以保存一个数组。\n    * 用 calloc 函数可以为一维数组开辟动态存储空间，n 为数组元素个数，每个元素长度为 size.  \n    * 函数返回指向所分配域的起始位置的指针； 分配不成功， 返回 NULL。 \n    * p = calloc(50, 4); //开辟 50*4 个字节临时空间， 把起始地址分配给指针变量 p\n  * 函数原型： `void free（void *p）`\n    * 作用——释放变量 p 所指向的动态空间， 使这部分空间能重新被其他变量使用。 \n    * p 是最近一次调用 calloc 或 malloc 函数时的函数返回值\n    * free 函数无返回值  \n    * free(p); // 释放 p 所指向的已分配的动态空间\n  * 函数原型：`void *realloc（void *p，unsigned int size)`  \n    * 作用——重新分配 malloc 或 calloc 函数获得的动态空间大小，将 p 指向的动态空间大小改变为 size，p 的值不变，分配失败返回 NULL\n    * realloc(p, 50); // 将 p 所指向的已分配的动态空间 改为 50 字节\n\n~~~ c\n#include <stdlib.h>\n#include <stdio.h>\nint main() {\n    void check(int *);\n    int * p,i;\n    // 在堆区开辟一个 5 * 4 的空间， 并将地址 (void *） ， 转成 (int *) , 赋给 p\n    p = (int *)malloc(5*sizeof(int));\n    for( i = 0; i < 5; i++){\n        scanf(\"%d\", p + i);\n    } \n    check(p);\n    // free(p); //销毁 堆区 p 指向的空间\n    return 0;\n} \n\nvoid check(int *p) {\n    int i;\n    printf(\"\\n 不及格的成绩 有: \");\n    for(i =0; i < 5; i++){\n        if(p[i] < 60) {\n            printf(\" %d \", p[i]);\n        }\n    }\n}\n~~~\n\n* 动态分配内存的基本原则\n  1. 避免分配大量的小内存块。分配堆上的内存有一些系统开销，所以分配许多小的内存块比分配几个大内存块的系统开销大。\n  2. 仅在需要时分配内存。 只要使用完堆上的内存块， 就需要及时释放它(如果使用动态分配内存， 需要遵守原则：谁分配， 谁释放)， 否则可能出现内存泄漏。\n  3. 总是确保释放以分配的内存。在编写分配内存的代码时，就要确定在代码的什么地方释放内存。\n  4. 在释放内存之前， 确保不会无意中覆盖堆上已分配的内存地址， 否则程序就会出现内存泄漏。 \n\n# 13. 结构体和共用体\n\n## 13.1 结构体\n\n~~~ c\nvoid main() {\n    /*\n    张老太养了两只猫猫:一只名字叫小白,今年 3 岁,白色。 还有一只叫小花,今年 100 岁,花色。\n    请编写一个程序， 当用户输入小猫的名字时， 就显示该猫的名字， 年龄， 颜色。\n    如果用户输入的小猫名错误， 则显示 张老太没有这只猫猫。\n    分析：\n    1. 猫猫有 三个成员(变量)组成\n    2. 使用结构体解决\n    */\n    // 创建 结构体 Cat 【是数据类型】\n    struct Cat { // 结构体名 Cat, Cat 就是我们自己构造的一个数据类型\n        char * name; //名字， 使用指针， 指向一个字符串\n        int age; //年龄\n        char *color; //颜色\n    };\n    // 使用 Cat 结构体， 创建变量\n    struct Cat cat1; // cat1 就是 struct Cat 的一个变量\n    struct Cat cat2; // cat2 就是 struct Cat 的一个变量\n    // 给 cat1 的各个成员赋值\n    cat1.name = \"小白\";\n    cat1.age = 3;\n    cat1.color = \"白色\";\n    //给 cat2 的各个成员赋值\n    cat2.name = \"小花\";\n    cat2.age = 100;\n    cat2.color = \"花色\";\n    //输出两只猫的信息\n    printf(\"\\n 第 1 只猫 name=%s age=%d color=%s\", cat1.name, cat1.age, cat1.color);\n    printf(\"\\n 第 2 只猫 name=%s age=%d color=%s\", cat2.name, cat2.age, cat2.color);\n}\n~~~\n\n* 结构体和结构体变量的区别和联系\n  1. 结构体是自定义的数据类型， 表示的是一种数据类型.\n  2. 结构体变量代表一个具体变量\n\n> 其实就是面向对象里面说的，类 和 对象之间的关系。\n\n* 声明结构体\n\n  ~~~ c\n  struct 结构体名称 { // 结构体名首字母大写， 比如 Cat, Person\n      成员列表;\n  };\n  \n  struct Student{\n      char *name; //姓名\n      int num; //学号\n      int age; //年龄\n      char group; //所在学习小组\n      float score; //成绩\n      //成员也可以是结构体\n  };\n  ~~~\n\n* 成员\n  * 成员是结构体的一个组成部分，一般是基本数据类型、也可以是数组、指针、结构体等。 \n  * 成员声明语法同变量，示例：数据类型 成员名; \n  * 字段的类型可以为：基本类型、数组或指针、结构体等。\n  * 在创建一个结构体变量后，需要给成员赋值，如果没有赋值就使用可能导致程序异常终止。\n  * 不同结构体变量的成员是独立，互不影响，一个结构体变量的成员更改，不影响另外一个。 \n\n**创建方式1**\n\n~~~ c\nstruct Stu{\n    char *name; //姓名\n    int num; //学号\n    int age; //年龄\n    char group; //所在学习小组\n    float score; //成绩\n};\n\nstruct Stu stu1, stu2;\n// 定义了两个变量 stu1 和 stu2， 它们都是 Stu 类型， 都由 5 个成员组成\n// 注意关键字 struct 不能少\n~~~\n\n**创建方式2**\n\n~~~ c\nstruct Stu{\n    char *name; //姓名\n    int num; //学号\n    int age; //年龄\n    char group; //所在学习小组\n    float score; //成绩\n} stu1, stu2;\n// 在定义结构体 Stu 的同时， 创建了两个结构体变量 stu1 和 stu2\n~~~\n\n**创建方式3**\n\n~~~ c\n// 如果只需要 stu1、 stu2 两个变量， 后面不需要再使用结构体数据类型， \nstruct { // 没有写 Stu\n    char *name; //姓名\n    int num; //学号\n    int age; //年龄\n    char group; //所在学习小组\n    float score; //成绩\n} stu1, stu2;\nstu1.name = \"tom\"; stu1.num = 100;....\n// 1. 该结构体数据类型， 没有名, 匿名结构体\n// 2. stu1 和 stu2 就是 该结构体的两个变量\n~~~\n\n* 成员获取和赋值\n\n  * 获取：结构体变量名.成员名;  \n\n  * 赋值：\n\n    1. struct Student stu3 = {\"林黛玉 2\", 12, 16, 'A', 100 }; \n\n    2. ~~~ c\n       struct Student{\n           char *name; //姓名\n           int num; //学号\n           int age; //年龄\n           char group; //所在小组\n           float score; //成绩\n       } stu1 = {\"贾宝玉\", 11, 18, 'B', 90.50}, stu2 = { \"林黛玉\", 12, 16, 'A', 100 };\n       ~~~\n\n    3. ~~~ c\n       struct Student stu4;\n       //stu4 = {\"林黛玉 2\", 12, 16, 'A', 100 }; // 这样赋值不可以\n       ~~~\n\n常用操作\n\n~~~ c\ntypedef struct stu\n{\n    rt_base_t pin;\n    rt_base_t mode;\n}stu_t;\n// 定义一个名字叫stu的结构体类型，然后又把这个类型重定义了个叫stu_t的类型。\n// 后续创建结构体的时候，就只需要\n// stu_t studentA; 就可以了\n\ntypedef Stu_t *stu_ptr;\n// 重定义了个指针类型\n// stu_ptr studentA_t;\n// 效果等同于\n// stu_t * studentA_t;\n~~~\n\n## 13.2 共用体\n\n共用体（Union）属于构造类型，它可以包含多个类型不同的成员。和结构体非常类似，但是也有不同的地方。\n\n结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。\n\n~~~ c\nunion 共用体名{\n    成员列表\n};\n~~~\n\n**定义**\n\n~~~ c\nunion data{\n    int n;\n    char ch;\n    double f;\n};\nunion data a, b, c;\n\nunion data{\n    int n;\n    char ch;\n    double f;\n}a, b, c;\n\nunion {\n    int n;\n    char ch;\n    double f;\n}a, b, c;\n~~~\n\n内存问题\n\n~~~ c\nunion data{ // data 就是一个共用体(内存布局)， 包含三个成员, 共享数据空间, 该空间的大小以占用最大的成员为准\n    int n;\n    char ch;\n    short m;\n};\n\nint main(){\n    union data a;  // 定义一个 共用体变量 a\n    printf(\"%d, %d\\n\", sizeof(a), sizeof(union data) ); // 4, 4\n    a.n = 0x40;\t   // 16 进制\n    printf(\"%d, %c, %d \\n\", a.n, a.ch, a.m);\n    a.ch = '9'; //\n    printf(\"%d, %c, %d \\n\", a.n, a.ch, a.m);\n    a.m = 0x2059;\n    printf(\"%d, %c, %d \\n\", a.n, a.ch, a.m);\n    a.n = 0x3E25AD54;\n    printf(\"%d, %c, %d \\n\", a.n, a.ch, a.m);\n    return 0;\n}\n\n标准输出：4, 4\n64, @, 64\n57, 9, 57\n8281, Y, 8281\n1042656596, T, -21164\n~~~\n\n![共用体内存](./c/共用体内存.jpg)\n\n现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：请使用共用体编程完成。\n\n| Name | Num  | Sex  | Profession | Score / Course |\n| ---- | ---- | ---- | ---------- | -------------- |\n| 张三 | 111  | 女   | 学生       | 80.1           |\n| 李四 | 222  | 男   | 老师       | math           |\n| 王五 | 333  | 女   | 老师       | English        |\n| 赵六 | 444  | 男   | 学生       | 60.1           |\n\n~~~ c\n#define TOTAL 2 //人员总数\n\nstruct Person{\n    char name[20]; //name\n    int num; //编号\n    char sex;//性别 f => 女 m=>男\n    char profession; //职员 s=>学生 t=>老师\n    union{\n        float score;\n        char course[20];\n    } sc; // sc 是一个共用体变量\n};\n\nint main(){\n    int i;\n    struct Person persons[TOTAL];  // 定义了一个结构体数组\n    // 输入人员信息\n    for(i=0; i<TOTAL; i++){\n        printf(\"Input info: \");\n        scanf(\"%s %d %c %c\", persons[i].name, &(persons[i].num), &(persons[i].sex), &(persons[i].profession));\n        \n        if(persons[i].profession == 's'){ //如果是学生\n            printf(\"请输入该学生成绩:\");\n            scanf(\"%f\", &persons[i].sc.score);\n        }else{ //如果是老师\n            printf(\"请输入该老师课程:\");\n            scanf(\"%s\", persons[i].sc.course);\n        } \n        fflush(stdin);//刷新\n    }\n        \n    // 输出人员信息\n    printf(\"\\nName\\t\\tNum\\tSex\\tProfession\\tScore / Course\\n\");\n    for(i=0; i<TOTAL; i++){\n        if(persons[i].profession == 's'){ //如果是学生\n            printf(\"%s\\t\\t%d\\t%c\\t%c\\t\\t%f\\n\", persons[i].name, persons[i].num, persons[i].sex, persons[i].profession,\n            persons[i].sc.score);\n        }else{ //如果是老师\n            printf(\"%s\\t\\t%d\\t%c\\t%c\\t\\t%s\\n\", persons[i].name, persons[i].num, persons[i].sex, persons[i].profession,\n            persons[i].sc.course);\n        }\n    }\n    return 0;\n}\n~~~\n\n# 14. 文件操作\n\n* 文件在程序中是以流的形式来操作的。\n  * 流： 数据在数据源(文件)和程序(内存)之间经历的路径\n  * 输入流： 数据从数据源(文件)到程序(内存)的路径\n  * 输出流： 数据从程序(内存)到数据源(文件)的路径\n\nC 标准库 - stdio .h 该头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出, 在开发过程中，可以来查询.  \n\nC 语言中的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数。 scanf() 函数用于从标准输入（键盘） 读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）\n\n## 14.1 getchar() & putchar() 函数\n\n1. int getchar(void) 函数从屏幕读取下一个可用的字符， 并把它返回为一个整数。 这个函数在同一个时间内只会读取一个单一的字符。 您可以在循环内使用这个方法， 以便从屏幕上读取多个字符。 \n2. int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。 这个函数在同一个时间内只会输出一个单一的字符。 您可以在循环内使用这个方法， 以便在屏幕上输出多个字符。 \n\n~~~ c\n#include <stdio.h>\nint main( ){\n    int c;\n    printf( \"Enter a value :\");\n    c = getchar( );\n    printf( \"\\nYou entered: \");\n    putchar( c );\n    printf( \"\\n\");\n    return 0;\n}\n~~~\n\n## 14.2 gets() & puts() 函数\n\n1. char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区， 直到一个终止符或 EOF。\n2. int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。  \n\n~~~ c\nint main( ){\n    char str[100];\n    printf( \"Enter a value :\");\n    gets( str );\n    printf( \"\\nYou entered: \");\n    puts( str );\n    return 0;\n}\n~~~\n\n## 14.3 scanf() 和 printf() 函数\n\n1. int scanf(const char *format, ...) 函数从标准输入流 stdin 读取输入， 并根据提供的 format 来浏览输入。\n2. int printf(const char *format, ...) 函数把输出写入到标准输出流 stdout ， 并根据提供的格式产生输出。  \n3. format 可以是一个简单的常量字符串， 但是您可以分别指定 %s、 %d、 %c、 %f 等来输出或读取字符串、整数、字符或浮点数。 还有许多其他可用的格式选项， 可以根据需要使用。   \n\n~~~ c\n// 您输入一个文本并按下回车键时， 程序读取输入，\n#include <stdio.h>\nint main( ) {\n    char str[100];\n    int i;\n    printf( \"Enter a value :\");\n    scanf(\"%s %d\", str, &i);\n    printf( \"\\nYou entered: %s %d \", str, i);\n    printf(\"\\n\");\n    return 0;\n}\n~~~\n\n## 14.4 文件操作\n\n**打开文件**\n\n使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件， 这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。  \n\nFILE *fopen( const char * filename, const char * mode );  \n\n1. filename 是字符串， 用来命名文件， 访问模式 mode 的值可以是下列值中的一个  \n2. 如果处理的是二进制文件(图片， 视频..)， 则需使用下面的访问模式: \"rb\", \"wb\", \"ab\", \"rb+\", \"r+b\", \"wb+\", \"w+b\",  \"ab+\", \"a+b\" //b :binary 二进制  \n\n![读取文件](./c/读取文件.jpg)\n\n**关闭文件**\n\n关闭文件， 使用 fclose( ) 函数。int fclose( FILE *fp );  \n\n1. 如果成功关闭文件， fclose( ) 函数返回零， 如果关闭文件时发生错误， 函数返回 EOF。 这个函数实际上， 会清空缓冲区中的数据， 关闭文件， 并释放用于该文件的所有内存。 EOF 是一个定义在头文件 stdio.h 中的常量。\n2. C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。\n3. 使用完文件后(读， 写)， 一定要将该文件关闭。\n\n**写入文件**\n\n下面是把字符写入到流中的函数  \n\nint fputc( int c, FILE *fp );  \n\n说明：函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。 如果写入成功， 它会返回写入的字符，如果发生错误， 则会返回 EOF。 您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：\n\n int fputs( const char *s, FILE *fp );  \n\n说明： 函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。 如果写入成功， 它会返回一个非负值， 如果发生错误， 则会返回 EOF。 您也可以使用 int fprintf(FILE *fp,const char *format, ...) 函数来写把一个字符串写入到文件中  \n\n~~~ c\nvoid main() {\n    // 创建一个文件指针\n    FILE *fp = NULL;\n    // 打开该文件\n    fp = fopen(\"d:/test100.txt\", \"w+\"); // w+ 模式是 文件会被截断为零长度\n    // fp = fopen(\"d:/test100.txt\", \"a+\"); //w+ 模式是 文件会被截断为零长度\n    // 将内容写入到文件中\n    /* \n    fprintf(fp, \"你好 北京~~ \\n\");\n    fputs(\"你好，上海~~ \\n\", fp);\n    */\n    //关闭文件!!!\n    fclose(fp);\n    printf(\"创建， 写入信息完成\");\n}\n    \n~~~\n\n**读取文件**\n\n下面是从文件读取单个字符的函数\n\nint fgetc( FILE * fp );  \n\n说明： fgetc() 函数从 fp 所指向的输入文件中读取一个字符。 返回值是读取的字符， 如果发生错误则返回 EOF。  \n\n下面的函数从流中读取一个字符串：\n\nchar *fgets( char *buf, int n, FILE *fp );  \n\n1. 说明： 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。 它会把读取的字符串复制到缓冲区 buf， 并在最后追加一个 null 字符来终止字符串。 \n2. 如果这个函数在读取最后一个字符之前就遇到一个换行符 '\\n' 或文件的末尾 EOF， 则只会返回读取到的字符，包括换行符。  \n\n~~~ c\nvoid main() {\n    // 创建一个文件指针\n    FILE *fp = NULL;\n    // 定义一个缓冲区\n    char buff[1024];\n    // 打开文件\n    fp = fopen(\"d:/test200.txt\", \"r\");\n    // 方法 1\n    // fscanf(fp, \"%s\", buff);\n    // 输出\n    // printf(\"%s\\n\", buff);\n    // 方法 2 读取整个文件\n    // 说明， 循环读取 fp 指向的文件内容， 如果读到 NULL,就结束\n    while(fgets(buff, 1024,fp)!=NULL) {\n        printf(\"%s\", buff);\n    }\n    // 关闭文件\n    fclose(fp);\n    getchar();\n}\n~~~\n\n\n\n\n\n\n\n\n\n\n\n","tags":["C语言"],"categories":["编程语法"]}]